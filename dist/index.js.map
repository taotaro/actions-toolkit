{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1wCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxytBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5jDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtIA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChEA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://deploy-to-sae/./node_modules/@actions/core/lib/command.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/core.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/file-command.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/path-utils.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/summary.js","../webpack://deploy-to-sae/./node_modules/@actions/core/lib/utils.js","../webpack://deploy-to-sae/./node_modules/@actions/http-client/lib/auth.js","../webpack://deploy-to-sae/./node_modules/@actions/http-client/lib/index.js","../webpack://deploy-to-sae/./node_modules/@actions/http-client/lib/proxy.js","../webpack://deploy-to-sae/./node_modules/@actions/io/lib/io-util.js","../webpack://deploy-to-sae/./node_modules/@actions/io/lib/io.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/access_key_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/bearer_token_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/config.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/credential_model.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/default_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/ecs_ram_role_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/oidc_role_arn_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/credentials_uri_provider.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/environment_variable_credentials_provider.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/instance_ram_role_credentials_provider.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/oidc_role_arn_credentials_provider.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/profile_credentials_provider.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/provider/provider_chain.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/ram_role_arn_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/rsa_key_pair_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/session_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/sts_token_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/uri_credential.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/util/helper.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/util/http.js","../webpack://deploy-to-sae/./node_modules/@alicloud/credentials/dist/src/util/utils.js","../webpack://deploy-to-sae/./node_modules/@alicloud/endpoint-util/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/gateway-spi/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/openapi-client/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/openapi-util/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/sae20190506/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/tea-typescript/dist/tea.js","../webpack://deploy-to-sae/./node_modules/@alicloud/tea-util/dist/client.js","../webpack://deploy-to-sae/./node_modules/@alicloud/tea-xml/dist/client.js","../webpack://deploy-to-sae/./node_modules/debug/src/browser.js","../webpack://deploy-to-sae/./node_modules/debug/src/common.js","../webpack://deploy-to-sae/./node_modules/debug/src/index.js","../webpack://deploy-to-sae/./node_modules/debug/src/node.js","../webpack://deploy-to-sae/./node_modules/has-flag/index.js","../webpack://deploy-to-sae/./node_modules/httpx/lib/index.js","../webpack://deploy-to-sae/./node_modules/ini/ini.js","../webpack://deploy-to-sae/./node_modules/kitx/lib/index.js","../webpack://deploy-to-sae/./node_modules/ms/index.js","../webpack://deploy-to-sae/./node_modules/sax/lib/sax.js","../webpack://deploy-to-sae/./node_modules/supports-color/index.js","../webpack://deploy-to-sae/./node_modules/tunnel/index.js","../webpack://deploy-to-sae/./node_modules/tunnel/lib/tunnel.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/index.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/md5.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/nil.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/parse.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/regex.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/rng.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/sha1.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/stringify.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/v1.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/v3.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/v35.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/v4.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/v5.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/validate.js","../webpack://deploy-to-sae/./node_modules/uuid/dist/version.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/bom.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/builder.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/defaults.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/parser.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/processors.js","../webpack://deploy-to-sae/./node_modules/xml2js/lib/xml2js.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/DocumentPosition.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/NodeType.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/Utility.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/WriterState.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLAttribute.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLCData.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLCharacterData.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLComment.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDOMImplementation.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDOMStringList.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDTDAttList.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDTDElement.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDTDEntity.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDTDNotation.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDeclaration.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDocType.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDocument.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDocumentCB.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLDummy.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLElement.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLNode.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLNodeList.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLRaw.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLStreamWriter.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLStringWriter.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLStringifier.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLText.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/XMLWriterBase.js","../webpack://deploy-to-sae/./node_modules/xmlbuilder/lib/index.js","../webpack://deploy-to-sae/external node-commonjs \"assert\"","../webpack://deploy-to-sae/external node-commonjs \"child_process\"","../webpack://deploy-to-sae/external node-commonjs \"crypto\"","../webpack://deploy-to-sae/external node-commonjs \"events\"","../webpack://deploy-to-sae/external node-commonjs \"fs\"","../webpack://deploy-to-sae/external node-commonjs \"http\"","../webpack://deploy-to-sae/external node-commonjs \"https\"","../webpack://deploy-to-sae/external node-commonjs \"net\"","../webpack://deploy-to-sae/external node-commonjs \"os\"","../webpack://deploy-to-sae/external node-commonjs \"path\"","../webpack://deploy-to-sae/external node-commonjs \"querystring\"","../webpack://deploy-to-sae/external node-commonjs \"stream\"","../webpack://deploy-to-sae/external node-commonjs \"string_decoder\"","../webpack://deploy-to-sae/external node-commonjs \"timers\"","../webpack://deploy-to-sae/external node-commonjs \"tls\"","../webpack://deploy-to-sae/external node-commonjs \"tty\"","../webpack://deploy-to-sae/external node-commonjs \"url\"","../webpack://deploy-to-sae/external node-commonjs \"util\"","../webpack://deploy-to-sae/external node-commonjs \"zlib\"","../webpack://deploy-to-sae/webpack/bootstrap","../webpack://deploy-to-sae/webpack/runtime/compat","../webpack://deploy-to-sae/./src/deploy.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n//# sourceMappingURL=proxy.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rename = exports.readlink = exports.readdir = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\n_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\nexports.IS_WINDOWS = process.platform === 'win32';\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n// Get the path of cmd.exe in windows\nfunction getCmdPath() {\n    var _a;\n    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;\n}\nexports.getCmdPath = getCmdPath;\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;\nconst assert_1 = require(\"assert\");\nconst childProcess = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst util_1 = require(\"util\");\nconst ioUtil = __importStar(require(\"./io-util\"));\nconst exec = util_1.promisify(childProcess.exec);\nconst execFile = util_1.promisify(childProcess.execFile);\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive, copySourceDirectory } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory() && copySourceDirectory\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another\n            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.\n            // Check for invalid characters\n            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n            if (/[*\"<>|]/.test(inputPath)) {\n                throw new Error('File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows');\n            }\n            try {\n                const cmdPath = ioUtil.getCmdPath();\n                if (yield ioUtil.isDirectory(inputPath, true)) {\n                    yield exec(`${cmdPath} /s /c \"rd /s /q \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n                else {\n                    yield exec(`${cmdPath} /s /c \"del /f /a \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that\n            try {\n                yield ioUtil.unlink(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n        }\n        else {\n            let isDir = false;\n            try {\n                isDir = yield ioUtil.isDirectory(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n                return;\n            }\n            if (isDir) {\n                yield execFile(`rm`, [`-rf`, `${inputPath}`]);\n            }\n            else {\n                yield ioUtil.unlink(inputPath);\n            }\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        yield ioUtil.mkdir(fsPath, { recursive: true });\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n            return result;\n        }\n        const matches = yield findInPath(tool);\n        if (matches && matches.length > 0) {\n            return matches[0];\n        }\n        return '';\n    });\n}\nexports.which = which;\n/**\n * Returns a list of all occurrences of the given tool on the system path.\n *\n * @returns   Promise<string[]>  the paths of the tool\n */\nfunction findInPath(tool) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // build the list of extensions to try\n        const extensions = [];\n        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {\n            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {\n                if (extension) {\n                    extensions.push(extension);\n                }\n            }\n        }\n        // if it's rooted, return it if exists. otherwise return empty.\n        if (ioUtil.isRooted(tool)) {\n            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n            if (filePath) {\n                return [filePath];\n            }\n            return [];\n        }\n        // if any path separators, return empty\n        if (tool.includes(path.sep)) {\n            return [];\n        }\n        // build the list of directories\n        //\n        // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n        // it feels like we should not do this. Checking the current directory seems like more of a use\n        // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n        // across platforms.\n        const directories = [];\n        if (process.env.PATH) {\n            for (const p of process.env.PATH.split(path.delimiter)) {\n                if (p) {\n                    directories.push(p);\n                }\n            }\n        }\n        // find all matches\n        const matches = [];\n        for (const directory of directories) {\n            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);\n            if (filePath) {\n                matches.push(filePath);\n            }\n        }\n        return matches;\n    });\n}\nexports.findInPath = findInPath;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    const copySourceDirectory = options.copySourceDirectory == null\n        ? true\n        : Boolean(options.copySourceDirectory);\n    return { force, recursive, copySourceDirectory };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass AccessKeyCredential extends default_credential_1.default {\n    constructor(accessKeyId, accessKeySecret) {\n        if (!accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for access_key');\n        }\n        if (!accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for access_key');\n        }\n        const conf = new config_1.default({\n            type: 'access_key',\n            accessKeyId,\n            accessKeySecret\n        });\n        super(conf);\n    }\n}\nexports.default = AccessKeyCredential;\n//# sourceMappingURL=access_key_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass BearerTokenCredential extends default_credential_1.default {\n    constructor(bearerToken) {\n        if (!bearerToken) {\n            throw new Error('Missing required bearerToken option in config for bearer');\n        }\n        const conf = new config_1.default({\n            type: 'bearer'\n        });\n        super(conf);\n        this.bearerToken = bearerToken;\n    }\n}\nexports.default = BearerTokenCredential;\n//# sourceMappingURL=bearer_token_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Config = void 0;\nconst access_key_credential_1 = __importDefault(require(\"./access_key_credential\"));\nconst sts_token_credential_1 = __importDefault(require(\"./sts_token_credential\"));\nconst ecs_ram_role_credential_1 = __importDefault(require(\"./ecs_ram_role_credential\"));\nconst ram_role_arn_credential_1 = __importDefault(require(\"./ram_role_arn_credential\"));\nconst oidc_role_arn_credential_1 = __importDefault(require(\"./oidc_role_arn_credential\"));\nconst rsa_key_pair_credential_1 = __importDefault(require(\"./rsa_key_pair_credential\"));\nconst bearer_token_credential_1 = __importDefault(require(\"./bearer_token_credential\"));\nconst DefaultProvider = __importStar(require(\"./provider/provider_chain\"));\nconst config_1 = __importDefault(require(\"./config\"));\nexports.Config = config_1.default;\nconst uri_credential_1 = __importDefault(require(\"./uri_credential\"));\nclass Credential {\n    constructor(config = null, runtime = {}) {\n        this.load(config, runtime);\n    }\n    getAccessKeyId() {\n        return this.credential.getAccessKeyId();\n    }\n    getAccessKeySecret() {\n        return this.credential.getAccessKeySecret();\n    }\n    getSecurityToken() {\n        return this.credential.getSecurityToken();\n    }\n    getBearerToken() {\n        return this.credential.getBearerToken();\n    }\n    getType() {\n        return this.credential.getType();\n    }\n    getCredential() {\n        return this.credential.getCredential();\n    }\n    load(config, runtime) {\n        if (!config) {\n            this.credential = DefaultProvider.getCredentials();\n            return;\n        }\n        if (!config.type) {\n            throw new Error('Missing required type option');\n        }\n        switch (config.type) {\n            case 'access_key':\n                this.credential = new access_key_credential_1.default(config.accessKeyId, config.accessKeySecret);\n                break;\n            case 'sts':\n                this.credential = new sts_token_credential_1.default(config.accessKeyId, config.accessKeySecret, config.securityToken);\n                break;\n            case 'ecs_ram_role':\n                this.credential = new ecs_ram_role_credential_1.default(config.roleName, runtime, config.enableIMDSv2, config.metadataTokenDuration);\n                break;\n            case 'ram_role_arn':\n                this.credential = new ram_role_arn_credential_1.default(config, runtime);\n                break;\n            case 'oidc_role_arn':\n                this.credential = new oidc_role_arn_credential_1.default(config, runtime);\n                break;\n            case 'rsa_key_pair':\n                this.credential = new rsa_key_pair_credential_1.default(config.publicKeyId, config.privateKeyFile);\n                break;\n            case 'bearer':\n                this.credential = new bearer_token_credential_1.default(config.bearerToken);\n                break;\n            case 'credentials_uri':\n                this.credential = new uri_credential_1.default(config.credentialsURI);\n                break;\n            default:\n                throw new Error('Invalid type option, support: access_key, sts, ecs_ram_role, ram_role_arn, rsa_key_pair, credentials_uri');\n        }\n    }\n}\nexports.default = Credential;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass Config extends $tea.Model {\n    constructor(config) {\n        super(config);\n    }\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accessKeySecret: 'accessKeySecret',\n            securityToken: 'securityToken',\n            bearerToken: 'bearerToken',\n            durationSeconds: 'durationSeconds',\n            roleArn: 'roleArn',\n            policy: 'policy',\n            roleSessionExpiration: 'roleSessionExpiration',\n            roleSessionName: 'roleSessionName',\n            publicKeyId: 'publicKeyId',\n            privateKeyFile: 'privateKeyFile',\n            roleName: 'roleName',\n            enableIMDSv2: 'enableIMDSv2',\n            metadataTokenDuration: 'metadataTokenDuration',\n            credentialsURI: 'credentialsURI',\n            oidcProviderArn: 'oidcProviderArn',\n            oidcTokenFilePath: 'oidcTokenFilePath',\n            type: 'type',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accessKeySecret: 'string',\n            securityToken: 'string',\n            bearerToken: 'string',\n            durationSeconds: 'number',\n            roleArn: 'string',\n            policy: 'string',\n            roleSessionExpiration: 'number',\n            roleSessionName: 'string',\n            publicKeyId: 'string',\n            privateKeyFile: 'string',\n            roleName: 'string',\n            enableIMDSv2: 'boolean',\n            metadataTokenDuration: 'number',\n            credentialsURI: 'string',\n            oidcProviderArn: 'string',\n            oidcTokenFilePath: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.default = Config;\n//# sourceMappingURL=config.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass CredentialModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accessKeySecret: 'accessKeySecret',\n            securityToken: 'securityToken',\n            bearerToken: 'bearerToken',\n            type: 'type',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accessKeySecret: 'string',\n            securityToken: 'string',\n            bearerToken: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.default = CredentialModel;\n//# sourceMappingURL=credential_model.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst credential_model_1 = __importDefault(require(\"./credential_model\"));\nclass DefaultCredential {\n    constructor(config) {\n        this.accessKeyId = config.accessKeyId || '';\n        this.accessKeySecret = config.accessKeySecret || '';\n        this.securityToken = config.securityToken || '';\n        this.bearerToken = config.bearerToken || '';\n        this.type = config.type || '';\n    }\n    async getAccessKeyId() {\n        return this.accessKeyId;\n    }\n    async getAccessKeySecret() {\n        return this.accessKeySecret;\n    }\n    async getSecurityToken() {\n        return this.securityToken;\n    }\n    getBearerToken() {\n        return this.bearerToken;\n    }\n    getType() {\n        return this.type;\n    }\n    async getCredential() {\n        return new credential_model_1.default({\n            accessKeyId: this.accessKeyId,\n            accessKeySecret: this.accessKeySecret,\n            securityToken: this.securityToken,\n            bearerToken: this.bearerToken,\n            type: this.type,\n        });\n    }\n}\nexports.default = DefaultCredential;\n//# sourceMappingURL=default_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst config_1 = __importDefault(require(\"./config\"));\nconst SECURITY_CRED_URL = 'http://100.100.100.200/latest/meta-data/ram/security-credentials/';\nconst SECURITY_CRED_TOKEN_URL = 'http://100.100.100.200/latest/api/token';\nclass EcsRamRoleCredential extends session_credential_1.default {\n    constructor(roleName = '', runtime = {}, enableIMDSv2 = false, metadataTokenDuration = 21600) {\n        const conf = new config_1.default({\n            type: 'ecs_ram_role',\n        });\n        super(conf);\n        this.roleName = roleName;\n        this.enableIMDSv2 = enableIMDSv2;\n        this.metadataTokenDuration = metadataTokenDuration;\n        this.runtime = runtime;\n        this.sessionCredential = null;\n        this.metadataToken = null;\n        this.staleTime = 0;\n    }\n    async getBody(url, options = {}) {\n        const response = await httpx_1.default.request(url, options);\n        return (await httpx_1.default.read(response, 'utf8'));\n    }\n    async getMetadataToken() {\n        if (this.needToRefresh()) {\n            let tmpTime = new Date().getTime() + this.metadataTokenDuration * 1000;\n            const response = await httpx_1.default.request(SECURITY_CRED_TOKEN_URL, {\n                headers: {\n                    'X-aliyun-ecs-metadata-token-ttl-seconds': `${this.metadataTokenDuration}`\n                }\n            });\n            if (response.statusCode !== 200) {\n                throw new Error(`Failed to get token from ECS Metadata Service. HttpCode=${response.statusCode}`);\n            }\n            this.staleTime = tmpTime;\n            return (await httpx_1.default.read(response, 'utf8'));\n        }\n        return this.metadataToken;\n    }\n    async updateCredential() {\n        let options = {};\n        if (this.enableIMDSv2) {\n            this.metadataToken = await this.getMetadataToken();\n            options = {\n                headers: {\n                    'X-aliyun-ecs-metadata-token': this.metadataToken\n                }\n            };\n        }\n        const roleName = await this.getRoleName();\n        const url = SECURITY_CRED_URL + roleName;\n        const body = await this.getBody(url, options);\n        const json = JSON.parse(body);\n        this.sessionCredential = {\n            AccessKeyId: json.AccessKeyId,\n            AccessKeySecret: json.AccessKeySecret,\n            Expiration: json.Expiration,\n            SecurityToken: json.SecurityToken,\n        };\n    }\n    async getRoleName() {\n        if (this.roleName && this.roleName.length) {\n            return this.roleName;\n        }\n        return await this.getBody(SECURITY_CRED_URL);\n    }\n    needToRefresh() {\n        return new Date().getTime() >= this.staleTime;\n    }\n}\nexports.default = EcsRamRoleCredential;\n//# sourceMappingURL=ecs_ram_role_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nclass OidcRoleArnCredential extends session_credential_1.default {\n    constructor(config, runtime = {}) {\n        if (!config.roleArn) {\n            config.roleArn = process.env.ALIBABA_CLOUD_ROLE_ARN;\n            if (!config.roleArn) {\n                throw new Error('roleArn does not exist and env ALIBABA_CLOUD_ROLE_ARN is null.');\n            }\n        }\n        if (!config.oidcProviderArn) {\n            config.oidcProviderArn = process.env.ALIBABA_CLOUD_OIDC_PROVIDER_ARN;\n            if (!config.oidcProviderArn) {\n                throw new Error('oidcProviderArn does not exist and env ALIBABA_CLOUD_OIDC_PROVIDER_ARN is null.');\n            }\n        }\n        if (!config.oidcTokenFilePath) {\n            config.oidcTokenFilePath = process.env.ALIBABA_CLOUD_OIDC_TOKEN_FILE;\n            if (!config.oidcTokenFilePath) {\n                throw new Error('oidcTokenFilePath is not exists and env ALIBABA_CLOUD_OIDC_TOKEN_FILE is null.');\n            }\n        }\n        if (!config.roleSessionName && process.env.ALIBABA_CLOUD_ROLE_SESSION_NAME) {\n            config.roleSessionName = process.env.ALIBABA_CLOUD_ROLE_SESSION_NAME;\n        }\n        const conf = new config_1.default({\n            type: 'oidc_role_arn'\n        });\n        super(conf);\n        this.oidcTokenFilePath = config.oidcTokenFilePath;\n        this.roleArn = config.roleArn;\n        this.policy = config.policy;\n        this.oidcProviderArn = config.oidcProviderArn;\n        this.durationSeconds = config.roleSessionExpiration || 3600;\n        this.roleSessionName = config.roleSessionName || 'role_session_name';\n        runtime.method = 'POST';\n        runtime.anonymous = true;\n        this.runtime = runtime;\n        this.host = 'https://sts.aliyuncs.com';\n    }\n    getOdicToken(oidcTokenFilePath) {\n        if (!fs_1.default.existsSync(oidcTokenFilePath)) {\n            throw new Error(`oidcTokenFilePath ${oidcTokenFilePath}  is not exists.`);\n        }\n        let oidcToken = null;\n        try {\n            oidcToken = fs_1.default.readFileSync(oidcTokenFilePath, 'utf-8');\n        }\n        catch (err) {\n            throw new Error(`oidcTokenFilePath ${oidcTokenFilePath} cannot be read.`);\n        }\n        return oidcToken;\n    }\n    async updateCredential() {\n        const oidcToken = this.getOdicToken(this.oidcTokenFilePath);\n        const params = {\n            Action: 'AssumeRoleWithOIDC',\n            RoleArn: this.roleArn,\n            OIDCProviderArn: this.oidcProviderArn,\n            OIDCToken: oidcToken,\n            DurationSeconds: this.durationSeconds,\n            RoleSessionName: this.roleSessionName\n        };\n        if (this.policy) {\n            params.policy = this.policy;\n        }\n        const json = await http_1.request(this.host, params, this.runtime);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = OidcRoleArnCredential;\n//# sourceMappingURL=oidc_role_arn_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri_credential_1 = __importDefault(require(\"../uri_credential\"));\nexports.default = {\n    getCredential() {\n        const credentialsURI = process.env.ALIBABA_CLOUD_CREDENTIALS_URI;\n        if (credentialsURI) {\n            return new uri_credential_1.default(credentialsURI);\n        }\n        return null;\n    }\n};\n//# sourceMappingURL=credentials_uri_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst access_key_credential_1 = __importDefault(require(\"../access_key_credential\"));\nexports.default = {\n    getCredential() {\n        const accessKeyId = process.env.ALIBABA_CLOUD_ACCESS_KEY_ID;\n        const accessKeySecret = process.env.ALIBABA_CLOUD_ACCESS_KEY_SECRET;\n        if (accessKeyId === undefined || accessKeySecret === undefined) {\n            return null;\n        }\n        if (accessKeyId === null || accessKeyId === '') {\n            throw new Error('Environment variable ALIBABA_CLOUD_ACCESS_KEY_ID cannot be empty');\n        }\n        if (accessKeySecret === null || accessKeySecret === '') {\n            throw new Error('Environment variable ALIBABA_CLOUD_ACCESS_KEY_SECRET cannot be empty');\n        }\n        return new access_key_credential_1.default(accessKeyId, accessKeySecret);\n    }\n};\n//# sourceMappingURL=environment_variable_credentials_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ecs_ram_role_credential_1 = __importDefault(require(\"../ecs_ram_role_credential\"));\nexports.default = {\n    getCredential() {\n        const roleName = process.env.ALIBABA_CLOUD_ECS_METADATA;\n        const enableIMDSv2 = process.env.ALIBABA_CLOUD_ECS_IMDSV2_ENABLE;\n        if (roleName && roleName.length) {\n            return new ecs_ram_role_credential_1.default(roleName, {}, enableIMDSv2 && enableIMDSv2.toLowerCase() === 'true');\n        }\n        return null;\n    }\n};\n//# sourceMappingURL=instance_ram_role_credentials_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst oidc_role_arn_credential_1 = __importDefault(require(\"../oidc_role_arn_credential\"));\nconst config_1 = __importDefault(require(\"../config\"));\nexports.default = {\n    getCredential() {\n        if (process.env.ALIBABA_CLOUD_ROLE_ARN\n            && process.env.ALIBABA_CLOUD_OIDC_PROVIDER_ARN\n            && process.env.ALIBABA_CLOUD_OIDC_TOKEN_FILE) {\n            return new oidc_role_arn_credential_1.default(new config_1.default({}));\n        }\n        return null;\n    }\n};\n//# sourceMappingURL=oidc_role_arn_credentials_provider.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst access_key_credential_1 = __importDefault(require(\"../access_key_credential\"));\nconst sts_token_credential_1 = __importDefault(require(\"../sts_token_credential\"));\nconst ecs_ram_role_credential_1 = __importDefault(require(\"../ecs_ram_role_credential\"));\nconst ram_role_arn_credential_1 = __importDefault(require(\"../ram_role_arn_credential\"));\nconst oidc_role_arn_credential_1 = __importDefault(require(\"../oidc_role_arn_credential\"));\nconst rsa_key_pair_credential_1 = __importDefault(require(\"../rsa_key_pair_credential\"));\nconst bearer_token_credential_1 = __importDefault(require(\"../bearer_token_credential\"));\nconst utils = __importStar(require(\"../util/utils\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst config_1 = __importDefault(require(\"../config\"));\nconst DEFAULT_PATH = process.env.HOME + '/.alibabacloud/credentials';\nexports.default = {\n    getCredential(credentialName = 'default') {\n        let fileContent = null;\n        const credentialFile = process.env.ALIBABA_CLOUD_CREDENTIALS_FILE;\n        if (credentialFile === undefined) {\n            if (fs_1.default.existsSync(DEFAULT_PATH)) {\n                const content = utils.parseFile(DEFAULT_PATH, true);\n                if (content) {\n                    fileContent = content;\n                }\n            }\n        }\n        else {\n            if (credentialFile === null || credentialFile === '') {\n                throw new Error('Environment variable credentialFile cannot be empty');\n            }\n            if (!fs_1.default.existsSync(credentialFile)) {\n                throw new Error(`credentialFile ${credentialFile} cannot be empty`);\n            }\n            fileContent = utils.parseFile(credentialFile);\n        }\n        if (!fileContent) {\n            return null;\n        }\n        const config = fileContent[credentialName] || {};\n        if (!config.type) {\n            throw new Error('Missing required type option in credentialFile');\n        }\n        switch (config.type) {\n            case 'access_key':\n                return new access_key_credential_1.default(config.access_key_id, config.access_key_secret);\n            case 'sts':\n                return new sts_token_credential_1.default(config.access_key_id, config.access_key_secret, config.security_token);\n            case 'ecs_ram_role':\n                return new ecs_ram_role_credential_1.default(config.role_name);\n            case 'ram_role_arn': {\n                const conf = new config_1.default({\n                    roleArn: config.role_arn,\n                    accessKeyId: config.access_key_id,\n                    accessKeySecret: config.access_key_secret\n                });\n                return new ram_role_arn_credential_1.default(conf);\n            }\n            case 'oidc_role_arn':\n                const conf = new config_1.default({\n                    roleArn: config.role_arn,\n                    oidcProviderArn: config.oidc_provider_arn,\n                    oidcTokenFilePath: config.oidc_token_file_path\n                });\n                return new oidc_role_arn_credential_1.default(conf);\n            case 'rsa_key_pair':\n                return new rsa_key_pair_credential_1.default(config.public_key_id, config.private_key_file);\n            case 'bearer':\n                return new bearer_token_credential_1.default(config.bearer_token);\n            default:\n                throw new Error('Invalid type option, support: access_key, sts, ecs_ram_role, ram_role_arn, oidc_role_arn, rsa_key_pair, bearer');\n        }\n    }\n};\n//# sourceMappingURL=profile_credentials_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCredentials = void 0;\nconst environment_variable_credentials_provider_1 = __importDefault(require(\"./environment_variable_credentials_provider\"));\nconst profile_credentials_provider_1 = __importDefault(require(\"./profile_credentials_provider\"));\nconst instance_ram_role_credentials_provider_1 = __importDefault(require(\"./instance_ram_role_credentials_provider\"));\nconst credentials_uri_provider_1 = __importDefault(require(\"./credentials_uri_provider\"));\nconst oidc_role_arn_credentials_provider_1 = __importDefault(require(\"./oidc_role_arn_credentials_provider\"));\nconst defaultProviders = [\n    environment_variable_credentials_provider_1.default,\n    oidc_role_arn_credentials_provider_1.default,\n    profile_credentials_provider_1.default,\n    instance_ram_role_credentials_provider_1.default,\n    credentials_uri_provider_1.default\n];\nfunction getCredentials(providers = null) {\n    const providerChain = providers || defaultProviders;\n    for (const provider of providerChain) {\n        const credential = provider.getCredential();\n        if (credential) {\n            return credential;\n        }\n    }\n    return null;\n}\nexports.getCredentials = getCredentials;\n//# sourceMappingURL=provider_chain.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nclass RamRoleArnCredential extends session_credential_1.default {\n    constructor(config, runtime = {}) {\n        if (!config.accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for ram_role_arn');\n        }\n        if (!config.accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for ram_role_arn');\n        }\n        if (!config.roleArn) {\n            throw new Error('Missing required roleArn option in config for ram_role_arn');\n        }\n        const conf = new config_1.default({\n            type: 'ram_role_arn',\n            accessKeyId: config.accessKeyId,\n            accessKeySecret: config.accessKeySecret,\n            securityToken: config.securityToken\n        });\n        super(conf);\n        this.roleArn = config.roleArn;\n        this.policy = config.policy;\n        this.durationSeconds = config.roleSessionExpiration || 3600;\n        this.roleSessionName = config.roleSessionName || 'role_session_name';\n        this.runtime = runtime;\n        this.host = 'https://sts.aliyuncs.com';\n    }\n    async updateCredential() {\n        const params = {\n            accessKeyId: this.accessKeyId,\n            securityToken: this.securityToken,\n            roleArn: this.roleArn,\n            action: 'AssumeRole',\n            durationSeconds: this.durationSeconds,\n            roleSessionName: this.roleSessionName\n        };\n        if (this.policy) {\n            params.policy = this.policy;\n        }\n        const json = await http_1.request(this.host, params, this.runtime, this.accessKeySecret);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = RamRoleArnCredential;\n//# sourceMappingURL=ram_role_arn_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst utils = __importStar(require(\"./util/utils\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nconst SECURITY_CRED_URL = 'http://100.100.100.200/latest/meta-data/ram/security-credentials/';\nclass RsaKeyPairCredential extends session_credential_1.default {\n    constructor(publicKeyId, privateKeyFile) {\n        if (!publicKeyId) {\n            throw new Error('Missing required publicKeyId option in config for rsa_key_pair');\n        }\n        if (!privateKeyFile) {\n            throw new Error('Missing required privateKeyFile option in config for rsa_key_pair');\n        }\n        if (!fs_1.default.existsSync(privateKeyFile)) {\n            throw new Error(`privateKeyFile ${privateKeyFile} cannot be empty`);\n        }\n        const conf = new config_1.default({\n            type: 'rsa_key_pair'\n        });\n        super(conf);\n        this.privateKey = utils.parseFile(privateKeyFile);\n        this.publicKeyId = publicKeyId;\n    }\n    async updateCredential() {\n        const url = SECURITY_CRED_URL + this.roleName;\n        const json = await http_1.request(url, {\n            accessKeyId: this.publicKeyId,\n            action: 'GenerateSessionAccessKey',\n            durationSeconds: 3600,\n            signatureMethod: 'SHA256withRSA',\n            signatureType: 'PRIVATEKEY',\n        }, {}, this.privateKey);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = RsaKeyPairCredential;\n//# sourceMappingURL=rsa_key_pair_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst utils = __importStar(require(\"./util/utils\"));\nconst config_1 = __importDefault(require(\"./config\"));\nconst credential_model_1 = __importDefault(require(\"./credential_model\"));\nclass SessionCredential extends default_credential_1.default {\n    constructor(config) {\n        const conf = new config_1.default({\n            type: config.type,\n            accessKeyId: config.accessKeyId,\n            accessKeySecret: config.accessKeySecret,\n            securityToken: config.securityToken\n        });\n        super(conf);\n        this.sessionCredential = null;\n        this.durationSeconds = config.durationSeconds || 3600;\n    }\n    async updateCredential() {\n        throw new Error('need implemented in sub-class');\n    }\n    async ensureCredential() {\n        const needUpdate = this.needUpdateCredential();\n        if (needUpdate) {\n            await this.updateCredential();\n        }\n    }\n    async getAccessKeyId() {\n        await this.ensureCredential();\n        return this.sessionCredential.AccessKeyId;\n    }\n    async getAccessKeySecret() {\n        await this.ensureCredential();\n        return this.sessionCredential.AccessKeySecret;\n    }\n    async getSecurityToken() {\n        await this.ensureCredential();\n        return this.sessionCredential.SecurityToken;\n    }\n    needUpdateCredential() {\n        if (!this.sessionCredential || !this.sessionCredential.Expiration || !this.sessionCredential.AccessKeyId || !this.sessionCredential.AccessKeySecret || !this.sessionCredential.SecurityToken) {\n            return true;\n        }\n        const expireTime = utils.timestamp(new Date(), this.durationSeconds * 0.05 * 1000);\n        if (this.sessionCredential.Expiration < expireTime) {\n            return true;\n        }\n        return false;\n    }\n    async getCredential() {\n        await this.ensureCredential();\n        return new credential_model_1.default({\n            accessKeyId: this.sessionCredential.AccessKeyId,\n            accessKeySecret: this.sessionCredential.AccessKeySecret,\n            securityToken: this.sessionCredential.SecurityToken,\n            bearerToken: this.bearerToken,\n            type: this.type,\n        });\n    }\n}\nexports.default = SessionCredential;\n//# sourceMappingURL=session_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass StsTokenCredential extends default_credential_1.default {\n    constructor(accessKeyId, accessKeySecret, securityToken) {\n        if (!accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for sts');\n        }\n        if (!accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for sts');\n        }\n        if (!securityToken) {\n            throw new Error('Missing required securityToken option in config for sts');\n        }\n        const conf = new config_1.default({\n            type: 'sts',\n            accessKeyId,\n            accessKeySecret,\n            securityToken\n        });\n        super(conf);\n    }\n}\nexports.default = StsTokenCredential;\n//# sourceMappingURL=sts_token_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst config_1 = __importDefault(require(\"./config\"));\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nclass URICredential extends session_credential_1.default {\n    constructor(uri) {\n        const conf = new config_1.default({\n            type: 'credentials_uri',\n            credentialsURI: uri\n        });\n        super(conf);\n        if (!uri) {\n            this.credentialsURI = process.env['ALIBABA_CLOUD_CREDENTIALS_URI'];\n        }\n        else {\n            this.credentialsURI = uri;\n        }\n        if (!this.credentialsURI) {\n            throw new Error('Missing required credentialsURI option in config or environment variable for credentials_uri');\n        }\n    }\n    async updateCredential() {\n        const url = this.credentialsURI;\n        const response = await httpx_1.default.request(url, {});\n        if (response.statusCode !== 200) {\n            throw new Error(`Get credentials from ${url} failed, status code is ${response.statusCode}`);\n        }\n        const body = (await httpx_1.default.read(response, 'utf8'));\n        let json;\n        try {\n            json = JSON.parse(body);\n        }\n        catch (ex) {\n            throw new Error(`Get credentials from ${url} failed, unmarshal response failed, JSON is: ${body}`);\n        }\n        if (json.Code !== 'Success') {\n            throw new Error(`Get credentials from ${url} failed, Code is ${json.Code}`);\n        }\n        this.sessionCredential = {\n            AccessKeyId: json.AccessKeyId,\n            AccessKeySecret: json.AccessKeySecret,\n            Expiration: json.Expiration,\n            SecurityToken: json.SecurityToken,\n        };\n    }\n}\nexports.default = URICredential;\n//# sourceMappingURL=uri_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_CLIENT = exports.DEFAULT_UA = void 0;\nconst os = __importStar(require(\"os\"));\nconst package_json_1 = __importDefault(require(\"../../package.json\"));\nexports.DEFAULT_UA = `AlibabaCloud (${os.platform()}; ${os.arch()}) ` +\n    `Node.js/${process.version} Core/${package_json_1.default.version}`;\nexports.DEFAULT_CLIENT = `Node.js(${process.version}), ${package_json_1.default.name}: ${package_json_1.default.version}`;\n//# sourceMappingURL=helper.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.request = void 0;\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst helper = __importStar(require(\"./helper\"));\nconst utils = __importStar(require(\"./utils\"));\nconst STATUS_CODE = new Set([200, '200', 'OK', 'Success']);\nfunction firstLetterUpper(str) {\n    return str.slice(0, 1).toUpperCase() + str.slice(1);\n}\nfunction formatParams(params) {\n    const keys = Object.keys(params);\n    const newParams = {};\n    for (const key of keys) {\n        newParams[firstLetterUpper(key)] = params[key];\n    }\n    return newParams;\n}\nfunction encode(str) {\n    const result = encodeURIComponent(str);\n    return result.replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nfunction replaceRepeatList(target, key, repeat) {\n    for (let i = 0; i < repeat.length; i++) {\n        const item = repeat[i];\n        if (item && typeof item === 'object') {\n            const keys = Object.keys(item);\n            for (const itemKey of keys) {\n                target[`${key}.${i + 1}.${itemKey}`] = item[itemKey];\n            }\n        }\n        else {\n            target[`${key}.${i + 1}`] = item;\n        }\n    }\n}\nfunction flatParams(params) {\n    const target = {};\n    const keys = Object.keys(params);\n    for (const key of keys) {\n        const value = params[key];\n        if (Array.isArray(value)) {\n            replaceRepeatList(target, key, value);\n        }\n        else {\n            target[key] = value;\n        }\n    }\n    return target;\n}\nfunction normalize(params) {\n    const list = [];\n    const flated = flatParams(params);\n    const keys = Object.keys(flated).sort();\n    for (const key of keys) {\n        const value = flated[key];\n        list.push([encode(key), encode(value)]); // push []\n    }\n    return list;\n}\nfunction canonicalize(normalized) {\n    const fields = [];\n    for (const [key, value] of normalized) {\n        fields.push(key + '=' + value);\n    }\n    return fields.join('&');\n}\nfunction _buildParams() {\n    const defaultParams = {\n        Format: 'JSON',\n        SignatureMethod: 'HMAC-SHA1',\n        SignatureNonce: kitx.makeNonce(),\n        SignatureVersion: '1.0',\n        Timestamp: utils.timestamp(),\n        Version: '2015-04-01',\n        RegionId: 'cn-hangzhou'\n    };\n    return defaultParams;\n}\nasync function request(host, params = {}, opts = {}, accessKeySecret) {\n    // 1. compose params and opts\n    let options = Object.assign({ headers: {\n            'x-sdk-client': helper.DEFAULT_CLIENT,\n            'user-agent': helper.DEFAULT_UA\n        } }, opts);\n    // format params until formatParams is false\n    if (options.formatParams !== false) {\n        params = formatParams(params);\n    }\n    params = Object.assign(Object.assign({}, _buildParams()), params);\n    // 2. calculate signature\n    const method = (opts.method || 'GET').toUpperCase();\n    const normalized = normalize(params);\n    if (!options.anonymous) {\n        const canonicalized = canonicalize(normalized);\n        // 2.1 get string to sign\n        const stringToSign = `${method}&${encode('/')}&${encode(canonicalized)}`;\n        // 2.2 get signature\n        const key = accessKeySecret + '&';\n        const signature = kitx.sha1(stringToSign, key, 'base64');\n        // add signature\n        normalized.push(['Signature', encode(signature)]);\n    }\n    // 3. generate final url\n    const url = opts.method === 'POST' ? `${host}/` : `${host}/?${canonicalize(normalized)}`;\n    // 4. send request\n    if (opts.method === 'POST') {\n        opts.headers = opts.headers || {};\n        opts.headers['content-type'] = 'application/x-www-form-urlencoded';\n        opts.data = canonicalize(normalized);\n    }\n    const response = await httpx_1.default.request(url, opts);\n    const buffer = await httpx_1.default.read(response, 'utf8');\n    const json = JSON.parse(buffer);\n    if (json.Code && !STATUS_CODE.has(json.Code)) {\n        const err = new Error(`${json.Message}`);\n        err.name = json.Code + 'Error';\n        err.data = json;\n        err.code = json.Code;\n        err.url = url;\n        throw err;\n    }\n    return json;\n}\nexports.request = request;\n//# sourceMappingURL=http.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseFile = exports.timestamp = void 0;\nconst ini = __importStar(require(\"ini\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nfunction timestamp(dateStr, timeChange) {\n    let date = new Date(dateStr);\n    if (!dateStr || isNaN(date.getTime())) {\n        date = new Date();\n    }\n    if (timeChange) {\n        date.setTime(date.getTime() + timeChange);\n    }\n    const YYYY = date.getUTCFullYear();\n    const MM = kitx.pad2(date.getUTCMonth() + 1);\n    const DD = kitx.pad2(date.getUTCDate());\n    const HH = kitx.pad2(date.getUTCHours());\n    const mm = kitx.pad2(date.getUTCMinutes());\n    const ss = kitx.pad2(date.getUTCSeconds());\n    // \n    return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}Z`;\n}\nexports.timestamp = timestamp;\nfunction parseFile(file, ignoreErr = false) {\n    // check read permission\n    try {\n        fs_1.default.accessSync(file, fs_1.default.constants.R_OK);\n    }\n    catch (e) {\n        if (ignoreErr) {\n            return null;\n        }\n        throw new Error('Has no read permission to credentials file');\n    }\n    return ini.parse(fs_1.default.readFileSync(file, 'utf-8'));\n}\nexports.parseFile = parseFile;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Client = /** @class */ (function () {\n    function Client() {\n    }\n    Client.getEndpointRules = function (product, regionId, endpointType, network, suffix) {\n        var result;\n        if (network && network.length && network != \"public\") {\n            network = \"-\" + network;\n        }\n        else {\n            network = \"\";\n        }\n        suffix = suffix || \"\";\n        if (suffix.length) {\n            suffix = \"-\" + suffix;\n        }\n        if (endpointType == \"regional\") {\n            if (!regionId || !regionId.length) {\n                throw new Error(\"RegionId is empty, please set a valid RegionId\");\n            }\n            result = \"\" + product + suffix + network + \".\" + regionId + \".aliyuncs.com\";\n        }\n        else {\n            result = \"\" + product + suffix + network + \".aliyuncs.com\";\n        }\n        return result;\n    };\n    return Client;\n}());\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InterceptorContextResponse = exports.InterceptorContextConfiguration = exports.InterceptorContextRequest = exports.AttributeMap = exports.InterceptorContext = void 0;\n// This file is auto-generated, don't edit it\nconst credentials_1 = __importDefault(require(\"@alicloud/credentials\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass InterceptorContext extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            request: 'request',\n            configuration: 'configuration',\n            response: 'response',\n        };\n    }\n    static types() {\n        return {\n            request: InterceptorContextRequest,\n            configuration: InterceptorContextConfiguration,\n            response: InterceptorContextResponse,\n        };\n    }\n}\nexports.InterceptorContext = InterceptorContext;\nclass AttributeMap extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            attributes: 'attributes',\n            key: 'key',\n        };\n    }\n    static types() {\n        return {\n            attributes: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },\n            key: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n        };\n    }\n}\nexports.AttributeMap = AttributeMap;\nclass InterceptorContextRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            query: 'query',\n            body: 'body',\n            stream: 'stream',\n            hostMap: 'hostMap',\n            pathname: 'pathname',\n            productId: 'productId',\n            action: 'action',\n            version: 'version',\n            protocol: 'protocol',\n            method: 'method',\n            authType: 'authType',\n            bodyType: 'bodyType',\n            reqBodyType: 'reqBodyType',\n            style: 'style',\n            credential: 'credential',\n            signatureVersion: 'signatureVersion',\n            signatureAlgorithm: 'signatureAlgorithm',\n            userAgent: 'userAgent',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            query: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'any',\n            stream: 'Readable',\n            hostMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            pathname: 'string',\n            productId: 'string',\n            action: 'string',\n            version: 'string',\n            protocol: 'string',\n            method: 'string',\n            authType: 'string',\n            bodyType: 'string',\n            reqBodyType: 'string',\n            style: 'string',\n            credential: credentials_1.default,\n            signatureVersion: 'string',\n            signatureAlgorithm: 'string',\n            userAgent: 'string',\n        };\n    }\n}\nexports.InterceptorContextRequest = InterceptorContextRequest;\nclass InterceptorContextConfiguration extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            regionId: 'regionId',\n            endpoint: 'endpoint',\n            endpointRule: 'endpointRule',\n            endpointMap: 'endpointMap',\n            endpointType: 'endpointType',\n            network: 'network',\n            suffix: 'suffix',\n        };\n    }\n    static types() {\n        return {\n            regionId: 'string',\n            endpoint: 'string',\n            endpointRule: 'string',\n            endpointMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            endpointType: 'string',\n            network: 'string',\n            suffix: 'string',\n        };\n    }\n}\nexports.InterceptorContextConfiguration = InterceptorContextConfiguration;\nclass InterceptorContextResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            statusCode: 'statusCode',\n            headers: 'headers',\n            body: 'body',\n            deserializedBody: 'deserializedBody',\n        };\n    }\n    static types() {\n        return {\n            statusCode: 'number',\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'Readable',\n            deserializedBody: 'any',\n        };\n    }\n}\nexports.InterceptorContextResponse = InterceptorContextResponse;\nclass Client {\n    constructor() {\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Params = exports.OpenApiRequest = exports.Config = exports.GlobalParameters = void 0;\n// This file is auto-generated, don't edit it\n/**\n * This is for OpenApi SDK\n */\nconst tea_util_1 = __importDefault(require(\"@alicloud/tea-util\"));\nconst credentials_1 = __importStar(require(\"@alicloud/credentials\")), $Credential = credentials_1;\nconst openapi_util_1 = __importDefault(require(\"@alicloud/openapi-util\"));\nconst $SPI = __importStar(require(\"@alicloud/gateway-spi\"));\nconst tea_xml_1 = __importDefault(require(\"@alicloud/tea-xml\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass GlobalParameters extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            queries: 'queries',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            queries: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n        };\n    }\n}\nexports.GlobalParameters = GlobalParameters;\n/**\n * Model for initing client\n */\nclass Config extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accessKeySecret: 'accessKeySecret',\n            securityToken: 'securityToken',\n            bearerToken: 'bearerToken',\n            protocol: 'protocol',\n            method: 'method',\n            regionId: 'regionId',\n            readTimeout: 'readTimeout',\n            connectTimeout: 'connectTimeout',\n            httpProxy: 'httpProxy',\n            httpsProxy: 'httpsProxy',\n            credential: 'credential',\n            endpoint: 'endpoint',\n            noProxy: 'noProxy',\n            maxIdleConns: 'maxIdleConns',\n            network: 'network',\n            userAgent: 'userAgent',\n            suffix: 'suffix',\n            socks5Proxy: 'socks5Proxy',\n            socks5NetWork: 'socks5NetWork',\n            endpointType: 'endpointType',\n            openPlatformEndpoint: 'openPlatformEndpoint',\n            type: 'type',\n            signatureVersion: 'signatureVersion',\n            signatureAlgorithm: 'signatureAlgorithm',\n            globalParameters: 'globalParameters',\n            key: 'key',\n            cert: 'cert',\n            ca: 'ca',\n            disableHttp2: 'disableHttp2',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accessKeySecret: 'string',\n            securityToken: 'string',\n            bearerToken: 'string',\n            protocol: 'string',\n            method: 'string',\n            regionId: 'string',\n            readTimeout: 'number',\n            connectTimeout: 'number',\n            httpProxy: 'string',\n            httpsProxy: 'string',\n            credential: credentials_1.default,\n            endpoint: 'string',\n            noProxy: 'string',\n            maxIdleConns: 'number',\n            network: 'string',\n            userAgent: 'string',\n            suffix: 'string',\n            socks5Proxy: 'string',\n            socks5NetWork: 'string',\n            endpointType: 'string',\n            openPlatformEndpoint: 'string',\n            type: 'string',\n            signatureVersion: 'string',\n            signatureAlgorithm: 'string',\n            globalParameters: GlobalParameters,\n            key: 'string',\n            cert: 'string',\n            ca: 'string',\n            disableHttp2: 'boolean',\n        };\n    }\n}\nexports.Config = Config;\nclass OpenApiRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            query: 'query',\n            body: 'body',\n            stream: 'stream',\n            hostMap: 'hostMap',\n            endpointOverride: 'endpointOverride',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            query: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'any',\n            stream: 'Readable',\n            hostMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            endpointOverride: 'string',\n        };\n    }\n}\nexports.OpenApiRequest = OpenApiRequest;\nclass Params extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            action: 'action',\n            version: 'version',\n            protocol: 'protocol',\n            pathname: 'pathname',\n            method: 'method',\n            authType: 'authType',\n            bodyType: 'bodyType',\n            reqBodyType: 'reqBodyType',\n            style: 'style',\n        };\n    }\n    static types() {\n        return {\n            action: 'string',\n            version: 'string',\n            protocol: 'string',\n            pathname: 'string',\n            method: 'string',\n            authType: 'string',\n            bodyType: 'string',\n            reqBodyType: 'string',\n            style: 'string',\n        };\n    }\n}\nexports.Params = Params;\nclass Client {\n    /**\n     * Init client with Config\n     * @param config config contains the necessary information to create a client\n     */\n    constructor(config) {\n        if (tea_util_1.default.isUnset(config)) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'config' can not be unset\",\n            });\n        }\n        if (!tea_util_1.default.empty(config.accessKeyId) && !tea_util_1.default.empty(config.accessKeySecret)) {\n            if (!tea_util_1.default.empty(config.securityToken)) {\n                config.type = \"sts\";\n            }\n            else {\n                config.type = \"access_key\";\n            }\n            let credentialConfig = new $Credential.Config({\n                accessKeyId: config.accessKeyId,\n                type: config.type,\n                accessKeySecret: config.accessKeySecret,\n            });\n            credentialConfig.securityToken = config.securityToken;\n            this._credential = new credentials_1.default(credentialConfig);\n        }\n        else if (!tea_util_1.default.empty(config.bearerToken)) {\n            let cc = new $Credential.Config({\n                type: \"bearer\",\n                bearerToken: config.bearerToken,\n            });\n            this._credential = new credentials_1.default(cc);\n        }\n        else if (!tea_util_1.default.isUnset(config.credential)) {\n            this._credential = config.credential;\n        }\n        this._endpoint = config.endpoint;\n        this._endpointType = config.endpointType;\n        this._network = config.network;\n        this._suffix = config.suffix;\n        this._protocol = config.protocol;\n        this._method = config.method;\n        this._regionId = config.regionId;\n        this._userAgent = config.userAgent;\n        this._readTimeout = config.readTimeout;\n        this._connectTimeout = config.connectTimeout;\n        this._httpProxy = config.httpProxy;\n        this._httpsProxy = config.httpsProxy;\n        this._noProxy = config.noProxy;\n        this._socks5Proxy = config.socks5Proxy;\n        this._socks5NetWork = config.socks5NetWork;\n        this._maxIdleConns = config.maxIdleConns;\n        this._signatureVersion = config.signatureVersion;\n        this._signatureAlgorithm = config.signatureAlgorithm;\n        this._globalParameters = config.globalParameters;\n        this._key = config.key;\n        this._cert = config.cert;\n        this._ca = config.ca;\n        this._disableHttp2 = config.disableHttp2;\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doRPCRequest(action, version, protocol, method, authType, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            key: tea_util_1.default.defaultString(runtime.key, this._key),\n            cert: tea_util_1.default.defaultString(runtime.cert, this._cert),\n            ca: tea_util_1.default.defaultString(runtime.ca, this._ca),\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = \"/\";\n                let globalQueries = {};\n                let globalHeaders = {};\n                if (!tea_util_1.default.isUnset(this._globalParameters)) {\n                    let globalParams = this._globalParameters;\n                    if (!tea_util_1.default.isUnset(globalParams.queries)) {\n                        globalQueries = globalParams.queries;\n                    }\n                    if (!tea_util_1.default.isUnset(globalParams.headers)) {\n                        globalHeaders = globalParams.headers;\n                    }\n                }\n                let extendsHeaders = {};\n                let extendsQueries = {};\n                if (!tea_util_1.default.isUnset(runtime.extendsParameters)) {\n                    let extendsParameters = runtime.extendsParameters;\n                    if (!tea_util_1.default.isUnset(extendsParameters.headers)) {\n                        extendsHeaders = extendsParameters.headers;\n                    }\n                    if (!tea_util_1.default.isUnset(extendsParameters.queries)) {\n                        extendsQueries = extendsParameters.queries;\n                    }\n                }\n                request_.query = Object.assign(Object.assign(Object.assign({ Action: action, Format: \"json\", Version: version, Timestamp: openapi_util_1.default.getTimestamp(), SignatureNonce: tea_util_1.default.getNonce() }, globalQueries), extendsQueries), request.query);\n                let headers = this.getRpcHeaders();\n                if (tea_util_1.default.isUnset(headers)) {\n                    // endpoint is setted in product client\n                    request_.headers = Object.assign(Object.assign({ host: this._endpoint, 'x-acs-version': version, 'x-acs-action': action, 'user-agent': this.getUserAgent() }, globalHeaders), extendsHeaders);\n                }\n                else {\n                    request_.headers = Object.assign(Object.assign(Object.assign({ host: this._endpoint, 'x-acs-version': version, 'x-acs-action': action, 'user-agent': this.getUserAgent() }, globalHeaders), extendsHeaders), headers);\n                }\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    let m = tea_util_1.default.assertAsMap(request.body);\n                    let tmp = tea_util_1.default.anyifyMapValue(openapi_util_1.default.query(m));\n                    request_.body = new $tea.BytesReadable(tea_util_1.default.toFormString(tmp));\n                    request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let credentialType = await this.getType();\n                    if (tea_util_1.default.equalString(credentialType, \"bearer\")) {\n                        let bearerToken = await this.getBearerToken();\n                        request_.query[\"BearerToken\"] = bearerToken;\n                        request_.query[\"SignatureType\"] = \"BEARERTOKEN\";\n                    }\n                    else {\n                        let accessKeyId = await this.getAccessKeyId();\n                        let accessKeySecret = await this.getAccessKeySecret();\n                        let securityToken = await this.getSecurityToken();\n                        if (!tea_util_1.default.empty(securityToken)) {\n                            request_.query[\"SecurityToken\"] = securityToken;\n                        }\n                        request_.query[\"SignatureMethod\"] = \"HMAC-SHA1\";\n                        request_.query[\"SignatureVersion\"] = \"1.0\";\n                        request_.query[\"AccessKeyId\"] = accessKeyId;\n                        let t = null;\n                        if (!tea_util_1.default.isUnset(request.body)) {\n                            t = tea_util_1.default.assertAsMap(request.body);\n                        }\n                        let signedParam = Object.assign(Object.assign({}, request_.query), openapi_util_1.default.query(t));\n                        request_.query[\"Signature\"] = openapi_util_1.default.getRPCSignature(signedParam, request_.method, accessKeySecret);\n                    }\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    let requestId = Client.defaultAny(err[\"RequestId\"], err[\"requestId\"]);\n                    err[\"statusCode\"] = response_.statusCode;\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${requestId}`,\n                        data: err,\n                        description: `${Client.defaultAny(err[\"Description\"], err[\"description\"])}`,\n                        accessDeniedDetail: Client.defaultAny(err[\"AccessDeniedDetail\"], err[\"accessDeniedDetail\"]),\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param pathname pathname of every api\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doROARequest(action, version, protocol, method, authType, pathname, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            key: tea_util_1.default.defaultString(runtime.key, this._key),\n            cert: tea_util_1.default.defaultString(runtime.cert, this._cert),\n            ca: tea_util_1.default.defaultString(runtime.ca, this._ca),\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = pathname;\n                let globalQueries = {};\n                let globalHeaders = {};\n                if (!tea_util_1.default.isUnset(this._globalParameters)) {\n                    let globalParams = this._globalParameters;\n                    if (!tea_util_1.default.isUnset(globalParams.queries)) {\n                        globalQueries = globalParams.queries;\n                    }\n                    if (!tea_util_1.default.isUnset(globalParams.headers)) {\n                        globalHeaders = globalParams.headers;\n                    }\n                }\n                let extendsHeaders = {};\n                let extendsQueries = {};\n                if (!tea_util_1.default.isUnset(runtime.extendsParameters)) {\n                    let extendsParameters = runtime.extendsParameters;\n                    if (!tea_util_1.default.isUnset(extendsParameters.headers)) {\n                        extendsHeaders = extendsParameters.headers;\n                    }\n                    if (!tea_util_1.default.isUnset(extendsParameters.queries)) {\n                        extendsQueries = extendsParameters.queries;\n                    }\n                }\n                request_.headers = Object.assign(Object.assign(Object.assign({ date: tea_util_1.default.getDateUTCString(), host: this._endpoint, accept: \"application/json\", 'x-acs-signature-nonce': tea_util_1.default.getNonce(), 'x-acs-signature-method': \"HMAC-SHA1\", 'x-acs-signature-version': \"1.0\", 'x-acs-version': version, 'x-acs-action': action, 'user-agent': tea_util_1.default.getUserAgent(this._userAgent) }, globalHeaders), extendsHeaders), request.headers);\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    request_.body = new $tea.BytesReadable(tea_util_1.default.toJSONString(request.body));\n                    request_.headers[\"content-type\"] = \"application/json; charset=utf-8\";\n                }\n                request_.query = Object.assign(Object.assign({}, globalQueries), extendsQueries);\n                if (!tea_util_1.default.isUnset(request.query)) {\n                    request_.query = Object.assign(Object.assign({}, request_.query), request.query);\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let credentialType = await this.getType();\n                    if (tea_util_1.default.equalString(credentialType, \"bearer\")) {\n                        let bearerToken = await this.getBearerToken();\n                        request_.headers[\"x-acs-bearer-token\"] = bearerToken;\n                        request_.headers[\"x-acs-signature-type\"] = \"BEARERTOKEN\";\n                    }\n                    else {\n                        let accessKeyId = await this.getAccessKeyId();\n                        let accessKeySecret = await this.getAccessKeySecret();\n                        let securityToken = await this.getSecurityToken();\n                        if (!tea_util_1.default.empty(securityToken)) {\n                            request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                            request_.headers[\"x-acs-security-token\"] = securityToken;\n                        }\n                        let stringToSign = openapi_util_1.default.getStringToSign(request_);\n                        request_.headers[\"authorization\"] = `acs ${accessKeyId}:${openapi_util_1.default.getROASignature(stringToSign, accessKeySecret)}`;\n                    }\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.equalNumber(response_.statusCode, 204)) {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    let requestId = Client.defaultAny(err[\"RequestId\"], err[\"requestId\"]);\n                    requestId = Client.defaultAny(requestId, err[\"requestid\"]);\n                    err[\"statusCode\"] = response_.statusCode;\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${requestId}`,\n                        data: err,\n                        description: `${Client.defaultAny(err[\"Description\"], err[\"description\"])}`,\n                        accessDeniedDetail: Client.defaultAny(err[\"AccessDeniedDetail\"], err[\"accessDeniedDetail\"]),\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network with form body\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param pathname pathname of every api\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doROARequestWithForm(action, version, protocol, method, authType, pathname, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            key: tea_util_1.default.defaultString(runtime.key, this._key),\n            cert: tea_util_1.default.defaultString(runtime.cert, this._cert),\n            ca: tea_util_1.default.defaultString(runtime.ca, this._ca),\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = pathname;\n                let globalQueries = {};\n                let globalHeaders = {};\n                if (!tea_util_1.default.isUnset(this._globalParameters)) {\n                    let globalParams = this._globalParameters;\n                    if (!tea_util_1.default.isUnset(globalParams.queries)) {\n                        globalQueries = globalParams.queries;\n                    }\n                    if (!tea_util_1.default.isUnset(globalParams.headers)) {\n                        globalHeaders = globalParams.headers;\n                    }\n                }\n                let extendsHeaders = {};\n                let extendsQueries = {};\n                if (!tea_util_1.default.isUnset(runtime.extendsParameters)) {\n                    let extendsParameters = runtime.extendsParameters;\n                    if (!tea_util_1.default.isUnset(extendsParameters.headers)) {\n                        extendsHeaders = extendsParameters.headers;\n                    }\n                    if (!tea_util_1.default.isUnset(extendsParameters.queries)) {\n                        extendsQueries = extendsParameters.queries;\n                    }\n                }\n                request_.headers = Object.assign(Object.assign(Object.assign({ date: tea_util_1.default.getDateUTCString(), host: this._endpoint, accept: \"application/json\", 'x-acs-signature-nonce': tea_util_1.default.getNonce(), 'x-acs-signature-method': \"HMAC-SHA1\", 'x-acs-signature-version': \"1.0\", 'x-acs-version': version, 'x-acs-action': action, 'user-agent': tea_util_1.default.getUserAgent(this._userAgent) }, globalHeaders), extendsHeaders), request.headers);\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    let m = tea_util_1.default.assertAsMap(request.body);\n                    request_.body = new $tea.BytesReadable(openapi_util_1.default.toForm(m));\n                    request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                }\n                request_.query = Object.assign(Object.assign({}, globalQueries), extendsQueries);\n                if (!tea_util_1.default.isUnset(request.query)) {\n                    request_.query = Object.assign(Object.assign({}, request_.query), request.query);\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let credentialType = await this.getType();\n                    if (tea_util_1.default.equalString(credentialType, \"bearer\")) {\n                        let bearerToken = await this.getBearerToken();\n                        request_.headers[\"x-acs-bearer-token\"] = bearerToken;\n                        request_.headers[\"x-acs-signature-type\"] = \"BEARERTOKEN\";\n                    }\n                    else {\n                        let accessKeyId = await this.getAccessKeyId();\n                        let accessKeySecret = await this.getAccessKeySecret();\n                        let securityToken = await this.getSecurityToken();\n                        if (!tea_util_1.default.empty(securityToken)) {\n                            request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                            request_.headers[\"x-acs-security-token\"] = securityToken;\n                        }\n                        let stringToSign = openapi_util_1.default.getStringToSign(request_);\n                        request_.headers[\"authorization\"] = `acs ${accessKeyId}:${openapi_util_1.default.getROASignature(stringToSign, accessKeySecret)}`;\n                    }\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.equalNumber(response_.statusCode, 204)) {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    err[\"statusCode\"] = response_.statusCode;\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${Client.defaultAny(err[\"RequestId\"], err[\"requestId\"])}`,\n                        data: err,\n                        description: `${Client.defaultAny(err[\"Description\"], err[\"description\"])}`,\n                        accessDeniedDetail: Client.defaultAny(err[\"AccessDeniedDetail\"], err[\"accessDeniedDetail\"]),\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doRequest(params, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            key: tea_util_1.default.defaultString(runtime.key, this._key),\n            cert: tea_util_1.default.defaultString(runtime.cert, this._cert),\n            ca: tea_util_1.default.defaultString(runtime.ca, this._ca),\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, params.protocol);\n                request_.method = params.method;\n                request_.pathname = params.pathname;\n                let globalQueries = {};\n                let globalHeaders = {};\n                if (!tea_util_1.default.isUnset(this._globalParameters)) {\n                    let globalParams = this._globalParameters;\n                    if (!tea_util_1.default.isUnset(globalParams.queries)) {\n                        globalQueries = globalParams.queries;\n                    }\n                    if (!tea_util_1.default.isUnset(globalParams.headers)) {\n                        globalHeaders = globalParams.headers;\n                    }\n                }\n                let extendsHeaders = {};\n                let extendsQueries = {};\n                if (!tea_util_1.default.isUnset(runtime.extendsParameters)) {\n                    let extendsParameters = runtime.extendsParameters;\n                    if (!tea_util_1.default.isUnset(extendsParameters.headers)) {\n                        extendsHeaders = extendsParameters.headers;\n                    }\n                    if (!tea_util_1.default.isUnset(extendsParameters.queries)) {\n                        extendsQueries = extendsParameters.queries;\n                    }\n                }\n                request_.query = Object.assign(Object.assign(Object.assign({}, globalQueries), extendsQueries), request.query);\n                // endpoint is setted in product client\n                request_.headers = Object.assign(Object.assign(Object.assign({ host: this._endpoint, 'x-acs-version': params.version, 'x-acs-action': params.action, 'user-agent': this.getUserAgent(), 'x-acs-date': openapi_util_1.default.getTimestamp(), 'x-acs-signature-nonce': tea_util_1.default.getNonce(), accept: \"application/json\" }, globalHeaders), extendsHeaders), request.headers);\n                if (tea_util_1.default.equalString(params.style, \"RPC\")) {\n                    let headers = this.getRpcHeaders();\n                    if (!tea_util_1.default.isUnset(headers)) {\n                        request_.headers = Object.assign(Object.assign({}, request_.headers), headers);\n                    }\n                }\n                let signatureAlgorithm = tea_util_1.default.defaultString(this._signatureAlgorithm, \"ACS3-HMAC-SHA256\");\n                let hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(\"\"), signatureAlgorithm));\n                if (!tea_util_1.default.isUnset(request.stream)) {\n                    let tmp = await tea_util_1.default.readAsBytes(request.stream);\n                    hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tmp, signatureAlgorithm));\n                    request_.body = new $tea.BytesReadable(tmp);\n                    request_.headers[\"content-type\"] = \"application/octet-stream\";\n                }\n                else {\n                    if (!tea_util_1.default.isUnset(request.body)) {\n                        if (tea_util_1.default.equalString(params.reqBodyType, \"byte\")) {\n                            let byteObj = tea_util_1.default.assertAsBytes(request.body);\n                            hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(byteObj, signatureAlgorithm));\n                            request_.body = new $tea.BytesReadable(byteObj);\n                        }\n                        else if (tea_util_1.default.equalString(params.reqBodyType, \"json\")) {\n                            let jsonObj = tea_util_1.default.toJSONString(request.body);\n                            hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(jsonObj), signatureAlgorithm));\n                            request_.body = new $tea.BytesReadable(jsonObj);\n                            request_.headers[\"content-type\"] = \"application/json; charset=utf-8\";\n                        }\n                        else {\n                            let m = tea_util_1.default.assertAsMap(request.body);\n                            let formObj = openapi_util_1.default.toForm(m);\n                            hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(formObj), signatureAlgorithm));\n                            request_.body = new $tea.BytesReadable(formObj);\n                            request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                        }\n                    }\n                }\n                request_.headers[\"x-acs-content-sha256\"] = hashedRequestPayload;\n                if (!tea_util_1.default.equalString(params.authType, \"Anonymous\")) {\n                    let credentialModel = await this._credential.getCredential();\n                    let authType = credentialModel.type;\n                    if (tea_util_1.default.equalString(authType, \"bearer\")) {\n                        let bearerToken = credentialModel.bearerToken;\n                        request_.headers[\"x-acs-bearer-token\"] = bearerToken;\n                        if (tea_util_1.default.equalString(params.style, \"RPC\")) {\n                            request_.query[\"SignatureType\"] = \"BEARERTOKEN\";\n                        }\n                        else {\n                            request_.headers[\"x-acs-signature-type\"] = \"BEARERTOKEN\";\n                        }\n                    }\n                    else {\n                        let accessKeyId = credentialModel.accessKeyId;\n                        let accessKeySecret = credentialModel.accessKeySecret;\n                        let securityToken = credentialModel.securityToken;\n                        if (!tea_util_1.default.empty(securityToken)) {\n                            request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                            request_.headers[\"x-acs-security-token\"] = securityToken;\n                        }\n                        request_.headers[\"Authorization\"] = openapi_util_1.default.getAuthorization(request_, signatureAlgorithm, hashedRequestPayload, accessKeyId, accessKeySecret);\n                    }\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let err = {};\n                    if (!tea_util_1.default.isUnset(response_.headers[\"content-type\"]) && tea_util_1.default.equalString(response_.headers[\"content-type\"], \"text/xml;charset=utf-8\")) {\n                        let _str = await tea_util_1.default.readAsString(response_.body);\n                        let respMap = tea_xml_1.default.parseXml(_str, null);\n                        err = tea_util_1.default.assertAsMap(respMap[\"Error\"]);\n                    }\n                    else {\n                        let _res = await tea_util_1.default.readAsJSON(response_.body);\n                        err = tea_util_1.default.assertAsMap(_res);\n                    }\n                    err[\"statusCode\"] = response_.statusCode;\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${Client.defaultAny(err[\"RequestId\"], err[\"requestId\"])}`,\n                        data: err,\n                        description: `${Client.defaultAny(err[\"Description\"], err[\"description\"])}`,\n                        accessDeniedDetail: Client.defaultAny(err[\"AccessDeniedDetail\"], err[\"accessDeniedDetail\"]),\n                    });\n                }\n                if (tea_util_1.default.equalString(params.bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n                else {\n                    let anything = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: anything,\n                        headers: response_.headers,\n                        statusCode: response_.statusCode,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async execute(params, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            key: tea_util_1.default.defaultString(runtime.key, this._key),\n            cert: tea_util_1.default.defaultString(runtime.cert, this._cert),\n            ca: tea_util_1.default.defaultString(runtime.ca, this._ca),\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n            disableHttp2: Client.defaultAny(this._disableHttp2, false),\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                // spi = new Gateway();//Gateway implements SPI SDK \n                let headers = this.getRpcHeaders();\n                let globalQueries = {};\n                let globalHeaders = {};\n                if (!tea_util_1.default.isUnset(this._globalParameters)) {\n                    let globalParams = this._globalParameters;\n                    if (!tea_util_1.default.isUnset(globalParams.queries)) {\n                        globalQueries = globalParams.queries;\n                    }\n                    if (!tea_util_1.default.isUnset(globalParams.headers)) {\n                        globalHeaders = globalParams.headers;\n                    }\n                }\n                let extendsHeaders = {};\n                let extendsQueries = {};\n                if (!tea_util_1.default.isUnset(runtime.extendsParameters)) {\n                    let extendsParameters = runtime.extendsParameters;\n                    if (!tea_util_1.default.isUnset(extendsParameters.headers)) {\n                        extendsHeaders = extendsParameters.headers;\n                    }\n                    if (!tea_util_1.default.isUnset(extendsParameters.queries)) {\n                        extendsQueries = extendsParameters.queries;\n                    }\n                }\n                let requestContext = new $SPI.InterceptorContextRequest({\n                    headers: Object.assign(Object.assign(Object.assign(Object.assign({}, globalHeaders), extendsHeaders), request.headers), headers),\n                    query: Object.assign(Object.assign(Object.assign({}, globalQueries), extendsQueries), request.query),\n                    body: request.body,\n                    stream: request.stream,\n                    hostMap: request.hostMap,\n                    pathname: params.pathname,\n                    productId: this._productId,\n                    action: params.action,\n                    version: params.version,\n                    protocol: tea_util_1.default.defaultString(this._protocol, params.protocol),\n                    method: tea_util_1.default.defaultString(this._method, params.method),\n                    authType: params.authType,\n                    bodyType: params.bodyType,\n                    reqBodyType: params.reqBodyType,\n                    style: params.style,\n                    credential: this._credential,\n                    signatureVersion: this._signatureVersion,\n                    signatureAlgorithm: this._signatureAlgorithm,\n                    userAgent: this.getUserAgent(),\n                });\n                let configurationContext = new $SPI.InterceptorContextConfiguration({\n                    regionId: this._regionId,\n                    endpoint: tea_util_1.default.defaultString(request.endpointOverride, this._endpoint),\n                    endpointRule: this._endpointRule,\n                    endpointMap: this._endpointMap,\n                    endpointType: this._endpointType,\n                    network: this._network,\n                    suffix: this._suffix,\n                });\n                let interceptorContext = new $SPI.InterceptorContext({\n                    request: requestContext,\n                    configuration: configurationContext,\n                });\n                let attributeMap = new $SPI.AttributeMap({});\n                // 1. spi.modifyConfiguration(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyConfiguration(interceptorContext, attributeMap);\n                // 2. spi.modifyRequest(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyRequest(interceptorContext, attributeMap);\n                request_.protocol = interceptorContext.request.protocol;\n                request_.method = interceptorContext.request.method;\n                request_.pathname = interceptorContext.request.pathname;\n                request_.query = interceptorContext.request.query;\n                request_.body = interceptorContext.request.stream;\n                request_.headers = interceptorContext.request.headers;\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                let responseContext = new $SPI.InterceptorContextResponse({\n                    statusCode: response_.statusCode,\n                    headers: response_.headers,\n                    body: response_.body,\n                });\n                interceptorContext.response = responseContext;\n                // 3. spi.modifyResponse(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyResponse(interceptorContext, attributeMap);\n                return {\n                    headers: interceptorContext.response.headers,\n                    statusCode: interceptorContext.response.statusCode,\n                    body: interceptorContext.response.deserializedBody,\n                };\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    async callApi(params, request, runtime) {\n        if (tea_util_1.default.isUnset(params)) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'params' can not be unset\",\n            });\n        }\n        if (tea_util_1.default.isUnset(this._signatureAlgorithm) || !tea_util_1.default.equalString(this._signatureAlgorithm, \"v2\")) {\n            return await this.doRequest(params, request, runtime);\n        }\n        else if (tea_util_1.default.equalString(params.style, \"ROA\") && tea_util_1.default.equalString(params.reqBodyType, \"json\")) {\n            return await this.doROARequest(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);\n        }\n        else if (tea_util_1.default.equalString(params.style, \"ROA\")) {\n            return await this.doROARequestWithForm(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);\n        }\n        else {\n            return await this.doRPCRequest(params.action, params.version, params.protocol, params.method, params.authType, params.bodyType, request, runtime);\n        }\n    }\n    /**\n     * Get user agent\n     * @return user agent\n     */\n    getUserAgent() {\n        let userAgent = tea_util_1.default.getUserAgent(this._userAgent);\n        return userAgent;\n    }\n    /**\n     * Get accesskey id by using credential\n     * @return accesskey id\n     */\n    async getAccessKeyId() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let accessKeyId = await this._credential.getAccessKeyId();\n        return accessKeyId;\n    }\n    /**\n     * Get accesskey secret by using credential\n     * @return accesskey secret\n     */\n    async getAccessKeySecret() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let secret = await this._credential.getAccessKeySecret();\n        return secret;\n    }\n    /**\n     * Get security token by using credential\n     * @return security token\n     */\n    async getSecurityToken() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let token = await this._credential.getSecurityToken();\n        return token;\n    }\n    /**\n     * Get bearer token by credential\n     * @return bearer token\n     */\n    async getBearerToken() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let token = this._credential.getBearerToken();\n        return token;\n    }\n    /**\n     * Get credential type by credential\n     * @return credential type e.g. access_key\n     */\n    async getType() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let authType = this._credential.getType();\n        return authType;\n    }\n    /**\n     * If inputValue is not null, return it or return defaultValue\n     * @param inputValue  users input value\n     * @param defaultValue default value\n     * @return the final result\n     */\n    static defaultAny(inputValue, defaultValue) {\n        if (tea_util_1.default.isUnset(inputValue)) {\n            return defaultValue;\n        }\n        return inputValue;\n    }\n    /**\n     * If the endpointRule and config.endpoint are empty, throw error\n     * @param config config contains the necessary information to create a client\n     */\n    checkConfig(config) {\n        if (tea_util_1.default.empty(this._endpointRule) && tea_util_1.default.empty(config.endpoint)) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'config.endpoint' can not be empty\",\n            });\n        }\n    }\n    /**\n     * set gateway client\n     * @param spi.\n     */\n    setGatewayClient(spi) {\n        this._spi = spi;\n    }\n    /**\n     * set RPC header for debug\n     * @param headers headers for debug, this header can be used only once.\n     */\n    setRpcHeaders(headers) {\n        this._headers = headers;\n    }\n    /**\n     * get RPC header for debug\n     */\n    getRpcHeaders() {\n        let headers = this._headers;\n        this._headers = null;\n        return headers;\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This file is auto-generated, don't edit it\n/**\n * This is for OpenApi Util\n */\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst tea_util_1 = __importDefault(require(\"@alicloud/tea-util\"));\nconst kitx_1 = __importDefault(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst PEM_BEGIN = \"-----BEGIN PRIVATE KEY-----\\n\";\nconst PEM_END = \"\\n-----END PRIVATE KEY-----\";\nfunction replaceRepeatList(target, repeat, prefix) {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    for (var i = 0; i < repeat.length; i++) {\n        var item = repeat[i];\n        let key = prefix + (i + 1);\n        if (typeof item === 'undefined' || item == null) {\n            continue;\n        }\n        if (Array.isArray(item)) {\n            replaceRepeatList(target, item, key);\n        }\n        else if (item instanceof Object) {\n            flatMap(target, item, key);\n        }\n        else {\n            target[key] = item.toString();\n        }\n    }\n}\nfunction flatMap(target, params, prefix = '') {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    params = toMap(params);\n    let keys = Object.keys(params);\n    for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let value = params[key];\n        key = prefix + key;\n        if (typeof value === 'undefined' || value == null) {\n            continue;\n        }\n        if (Array.isArray(value)) {\n            replaceRepeatList(target, value, key);\n        }\n        else if (value instanceof Object) {\n            flatMap(target, value, key);\n        }\n        else {\n            target[key] = value.toString();\n        }\n    }\n    return target;\n}\nfunction filter(value) {\n    return value.replace(/[\\t\\n\\r\\f]/g, ' ');\n}\nfunction getCanonicalizedHeaders(headers) {\n    const prefix = 'x-acs-';\n    const keys = Object.keys(headers);\n    const canonicalizedKeys = [];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key.startsWith(prefix)) {\n            canonicalizedKeys.push(key);\n        }\n    }\n    canonicalizedKeys.sort();\n    var result = '';\n    for (let i = 0; i < canonicalizedKeys.length; i++) {\n        const key = canonicalizedKeys[i];\n        result += `${key}:${filter(headers[key]).trim()}\\n`;\n    }\n    return result;\n}\nfunction getCanonicalizedResource(uriPattern, query) {\n    const keys = !query ? [] : Object.keys(query).sort();\n    if (keys.length === 0) {\n        return uriPattern;\n    }\n    var result = [];\n    for (var i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        result.push(`${key}=${query[key]}`);\n    }\n    return `${uriPattern}?${result.join('&')}`;\n}\nfunction getAuthorizationQueryString(query) {\n    let canonicalQueryArray = [];\n    const keys = !query ? [] : Object.keys(query).sort();\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        let param = key + '=';\n        if (typeof query[key] !== 'undefined' && query[key] !== null) {\n            param = param + encode(query[key]);\n        }\n        canonicalQueryArray.push(param);\n    }\n    return canonicalQueryArray.join('&');\n}\nfunction getAuthorizationHeaders(header) {\n    let canonicalheaders = \"\";\n    let tmp = {};\n    const keys = !header ? [] : Object.keys(header);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const lowerKey = keys[i].toLowerCase();\n        if (lowerKey.startsWith(\"x-acs-\") || lowerKey === \"host\" || lowerKey === \"content-type\") {\n            if (tmp[lowerKey]) {\n                tmp[lowerKey].push((header[key] || \"\").trim());\n            }\n            else {\n                tmp[lowerKey] = [(header[key] || \"\").trim()];\n            }\n        }\n    }\n    var hsKeys = Object.keys(tmp).sort();\n    for (let i = 0; i < hsKeys.length; i++) {\n        const hsKey = hsKeys[i];\n        let listSort = tmp[hsKey].sort();\n        canonicalheaders += `${hsKey}:${listSort.join(\",\")}\\n`;\n    }\n    return { canonicalheaders, hsKeys };\n}\nfunction encode(str) {\n    var result = encodeURIComponent(str);\n    return result.replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nfunction normalize(params) {\n    var list = [];\n    var flated = {};\n    flatMap(flated, params);\n    var keys = Object.keys(flated).sort();\n    for (let i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = flated[key];\n        list.push([encode(key), encode(value)]);\n    }\n    return list;\n}\nfunction canonicalize(normalized) {\n    var fields = [];\n    for (var i = 0; i < normalized.length; i++) {\n        var [key, value] = normalized[i];\n        fields.push(key + '=' + value);\n    }\n    return fields.join('&');\n}\nfunction isModelClass(t) {\n    if (!t) {\n        return false;\n    }\n    return typeof t.types === 'function' && typeof t.names === 'function';\n}\nfunction isObjectOrArray(t) {\n    return Array.isArray(t) || (t instanceof Object && typeof t !== 'function');\n}\nfunction toMap(input) {\n    if (!isObjectOrArray(input)) {\n        return null;\n    }\n    else if (input instanceof $tea.Model) {\n        return $tea.toMap(input);\n    }\n    else if (input && input.toMap && typeof input.toMap === 'function') {\n        //  Model \n        return input.toMap();\n    }\n    else if (Array.isArray(input)) {\n        const result = [];\n        input.forEach((value) => {\n            if (isObjectOrArray(value)) {\n                result.push(toMap(value));\n            }\n            else {\n                result.push(value);\n            }\n        });\n        return result;\n    }\n    else if (input instanceof Object) {\n        const result = {};\n        Object.entries(input).forEach(([key, value]) => {\n            if (isObjectOrArray(value)) {\n                result[key] = toMap(value);\n            }\n            else {\n                result[key] = value;\n            }\n        });\n        return result;\n    }\n}\nclass Client {\n    /**\n     * Convert all params of body other than type of readable into content\n     * @param input source Model\n     * @param output target Model\n     * @return void\n     */\n    static convert(input, output) {\n        if (!output) {\n            return;\n        }\n        let inputModel = Object.assign({}, input);\n        let constructor = output.constructor;\n        let types = constructor.types();\n        // let constructor = <any>output.constructor;\n        for (let key of Object.keys(constructor.names())) {\n            if (inputModel[key] !== null && inputModel[key] !== undefined) {\n                if (isModelClass(types[key])) {\n                    output[key] = new types[key](output[key]);\n                    Client.convert(inputModel[key], output[key]);\n                }\n                else if (types[key] && types[key].type === 'array') {\n                    output[key] = inputModel[key].map(function (d) {\n                        if (isModelClass(types[key].itemType)) {\n                            var item = new types[key].itemType({});\n                            Client.convert(d, item);\n                            return item;\n                        }\n                        return d;\n                    });\n                }\n                else if (types[key] && types[key].type === 'map') {\n                    output[key] = {};\n                    Object.keys(inputModel[key]).map(function (d) {\n                        if (isModelClass(types[key].valueType)) {\n                            var item = new types[key].valueType({});\n                            Client.convert(inputModel[key][d], item);\n                            output[key][d] = item;\n                        }\n                        else {\n                            output[key][d] = inputModel[key][d];\n                        }\n                    });\n                }\n                else {\n                    output[key] = inputModel[key];\n                }\n            }\n        }\n    }\n    /**\n     * Get the string to be signed according to request\n     * @param request  which contains signed messages\n     * @return the signed string\n     */\n    static getStringToSign(request) {\n        const method = request.method;\n        const accept = request.headers['accept'];\n        const contentMD5 = request.headers['content-md5'] || '';\n        const contentType = request.headers['content-type'] || '';\n        const date = request.headers['date'] || '';\n        const header = `${method}\\n${accept}\\n${contentMD5}\\n${contentType}\\n${date}\\n`;\n        const canonicalizedHeaders = getCanonicalizedHeaders(request.headers);\n        const canonicalizedResource = getCanonicalizedResource(request.pathname, request.query);\n        return `${header}${canonicalizedHeaders}${canonicalizedResource}`;\n    }\n    /**\n     * Get signature according to stringToSign, secret\n     * @param stringToSign  the signed string\n     * @param secret accesskey secret\n     * @return the signature\n     */\n    static getROASignature(stringToSign, secret) {\n        const utf8Buff = Buffer.from(stringToSign, 'utf8');\n        return kitx_1.default.sha1(utf8Buff, secret, 'base64');\n    }\n    /**\n     * Parse filter into a form string\n     * @param filter object\n     * @return the string\n     */\n    static toForm(filter) {\n        if (!filter) {\n            return '';\n        }\n        let target = {};\n        flatMap(target, filter);\n        return tea_util_1.default.toFormString(target);\n    }\n    /**\n     * Get timestamp\n     * @return the timestamp string\n     */\n    static getTimestamp() {\n        let date = new Date();\n        let YYYY = date.getUTCFullYear();\n        let MM = kitx_1.default.pad2(date.getUTCMonth() + 1);\n        let DD = kitx_1.default.pad2(date.getUTCDate());\n        let HH = kitx_1.default.pad2(date.getUTCHours());\n        let mm = kitx_1.default.pad2(date.getUTCMinutes());\n        let ss = kitx_1.default.pad2(date.getUTCSeconds());\n        return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}Z`;\n    }\n    /**\n     * Parse filter into a object which's type is map[string]string\n     * @param filter query param\n     * @return the object\n     */\n    static query(filter) {\n        if (!filter) {\n            return {};\n        }\n        let ret = {};\n        flatMap(ret, filter);\n        return ret;\n    }\n    /**\n     * Get signature according to signedParams, method and secret\n     * @param signedParams params which need to be signed\n     * @param method http method e.g. GET\n     * @param secret AccessKeySecret\n     * @return the signature\n     */\n    static getRPCSignature(signedParams, method, secret) {\n        var normalized = normalize(signedParams);\n        var canonicalized = canonicalize(normalized);\n        var stringToSign = `${method}&${encode('/')}&${encode(canonicalized)}`;\n        const key = secret + '&';\n        return kitx_1.default.sha1(stringToSign, key, 'base64');\n    }\n    /**\n     * Parse array into a string with specified style\n     * @param array the array\n     * @param prefix the prefix string\n     * @style specified style e.g. repeatList\n     * @return the string\n     */\n    static arrayToStringWithSpecifiedStyle(array, prefix, style) {\n        if (!array) {\n            return '';\n        }\n        if (style === 'repeatList') {\n            let target = {};\n            replaceRepeatList(target, array, prefix);\n            return querystring_1.default.stringify(target, '&&');\n        }\n        else if (style === 'json') {\n            return JSON.stringify(toMap(array));\n        }\n        else if (style === 'simple') {\n            return array.join(',');\n        }\n        else if (style === 'spaceDelimited') {\n            return array.join(' ');\n        }\n        else if (style === 'pipeDelimited') {\n            return array.join('|');\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Transform input as map.\n     */\n    static parseToMap(input) {\n        return toMap(input);\n    }\n    static getEndpoint(endpoint, serverUse, endpointType) {\n        if (endpointType == \"internal\") {\n            let strs = endpoint.split(\".\");\n            strs[0] += \"-internal\";\n            endpoint = strs.join(\".\");\n        }\n        if (serverUse && endpointType == \"accelerate\") {\n            return \"oss-accelerate.aliyuncs.com\";\n        }\n        return endpoint;\n    }\n    /**\n    * Encode raw with base16\n    * @param raw encoding data\n    * @return encoded string\n    */\n    static hexEncode(raw) {\n        return raw.toString(\"hex\");\n    }\n    /**\n     * Hash the raw data with signatureAlgorithm\n     * @param raw hashing data\n     * @param signatureAlgorithm the autograph method\n     * @return hashed bytes\n    */\n    static hash(raw, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\" || signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            const obj = crypto_1.default.createHash('sha256');\n            obj.update(raw);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm == \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHash('sm3');\n            obj.update(raw);\n            return obj.digest();\n        }\n    }\n    static signatureMethod(secret, source, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\") {\n            const obj = crypto_1.default.createHmac('sha256', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHmac('sm3', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            if (!secret.startsWith(PEM_BEGIN)) {\n                secret = PEM_BEGIN + secret;\n            }\n            if (!secret.endsWith(PEM_END)) {\n                secret = secret + PEM_END;\n            }\n            var signerObject = crypto_1.default.createSign(\"RSA-SHA256\");\n            signerObject.update(source);\n            var signature = signerObject.sign({ key: secret, padding: crypto_1.default.constants.RSA_PKCS1_PADDING });\n            return signature;\n        }\n    }\n    /**\n     * Get the authorization\n     * @param request request params\n     * @param signatureAlgorithm the autograph method\n     * @param payload the hashed request\n     * @param acesskey the acesskey string\n     * @param accessKeySecret the accessKeySecret string\n     * @return authorization string\n     */\n    static getAuthorization(request, signatureAlgorithm, payload, acesskey, accessKeySecret) {\n        const canonicalURI = (request.pathname || \"\").replace(\"+\", \"%20\").replace(\"*\", \"%2A\").replace(\"%7E\", \"~\");\n        const method = request.method;\n        const canonicalQueryString = getAuthorizationQueryString(request.query);\n        const tuple = getAuthorizationHeaders(request.headers);\n        const canonicalheaders = tuple[\"canonicalheaders\"];\n        const signedHeaders = tuple[\"hsKeys\"];\n        const canonicalRequest = method + \"\\n\" + canonicalURI + \"\\n\" + canonicalQueryString + \"\\n\" + canonicalheaders + \"\\n\" +\n            signedHeaders.join(\";\") + \"\\n\" + payload;\n        let raw = Buffer.from(canonicalRequest);\n        const stringToSign = signatureAlgorithm + \"\\n\" + Client.hexEncode(Client.hash(raw, signatureAlgorithm));\n        const signature = Client.hexEncode(Client.signatureMethod(accessKeySecret, stringToSign, signatureAlgorithm));\n        const auth = `${signatureAlgorithm} Credential=${acesskey},SignedHeaders=${signedHeaders.join(';')},Signature=${signature}`;\n        return auth;\n    }\n    static getEncodePath(path) {\n        if (typeof path === 'undefined' || path === null) {\n            return '';\n        }\n        let strs = path.split('/');\n        for (let i = 0; i < strs.length; i++) {\n            strs[i] = encode(strs[i]);\n        }\n        return strs.join('/');\n    }\n    static getEncodeParam(param) {\n        if (typeof param === 'undefined' || param === null) {\n            return '';\n        }\n        return encode(param);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InstanceExecAuthorizationOutput = exports.InstanceExecAuthorizationInputOptions = exports.InstanceExecAuthorizationInput = exports.InputCodeLocation = exports.ImageConfig = exports.HostAlias = exports.HTTPTriggerConfig = exports.HTTPHeader = exports.HTTPGetAction = exports.GetQuotaOutput = exports.GetPerRequestLogsOutput = exports.GetPerRequestLogsInput = exports.GetInstanceLogsOutput = exports.GetInstanceLogsInput = exports.GetApplicationLogsOutput = exports.GetApplicationLogsInput = exports.GRPCAction = exports.ExternalErrorSAEWeb = exports.ExecAction = exports.DescribeWebStaticsQueryOutput = exports.DescribeWebAppStaticsOutput = exports.DescribeInstanceLogsOutput = exports.DNSOption = exports.CustomRuntimeConfig = exports.CustomHostAlias = exports.CustomHealthCheckConfig = exports.CustomDomain = exports.CustomDNS = exports.CreateWebCustomDomainInput = exports.CreateWebApplicationInput = exports.CreateSlsResourceResponse = exports.CreateSlsIndexResponse = exports.CreateSlsIndexRequest = exports.CreateCustomDomainInput = exports.CreateApplicationInput = exports.ContainerResources = exports.Container = exports.CertConfig = exports.BuildPipelineRunLogLine = exports.BuildPipelineRun = exports.BuildPipeline = exports.ArmsConfig = exports.ApplicationWithStatus = exports.ApplicationStatus = exports.Application = exports.AppStackTask = exports.AppStackResource = exports.AppStackInstance = exports.AclEntryConfig = exports.AclConfig = void 0;\nexports.StartupProbe = exports.SourceCodeRepoBranch = exports.SourceCodeRepo = exports.SourceCodeAccount = exports.ScaleConfig = exports.SLSConfig = exports.SLSCollectConfigs = exports.SLSCollectConfig = exports.RoutePolicy = exports.RouteConfig = exports.RevisionConfig = exports.Revision = exports.PublishWebApplicationRevisionInput = exports.PublishApplicationVersionInput = exports.ProbeHandler = exports.Probe = exports.PriceEstimateOutput = exports.PriceEstimateFeature = exports.PolicyItem = exports.PermissionAssistantApi = exports.PathConfig = exports.OSSMountPoint = exports.OSSMountConfig = exports.NASMountConfig = exports.NASConfig = exports.MetricsCollectConfig = exports.MetricInfo = exports.LogEntry = exports.LogConfig = exports.ListWebInstancesOutput = exports.ListWebCustomDomainOutput = exports.ListWebCustomDomainBody = exports.ListWebApplicationsOutput = exports.ListWebApplicationsBody = exports.ListWebApplicationRevisionsOutput = exports.ListWebApplicationRevisionsBody = exports.ListWebApplicationInstancesBody = exports.ListStaticsQueryResponse = exports.ListMetricsOutput = exports.ListInstancesOutput = exports.ListInstancesMetricsOutput = exports.ListCustomDomainOutput = exports.ListApplicationsWithStatusOutput = exports.ListApplicationsOutput = exports.ListApplicationVersionsOutput = exports.LifecycleHook = exports.JaegerConfig = exports.InstanceMetricInfo = exports.InstanceLifecycleConfig = exports.InstanceInfo = void 0;\nexports.AbortAndRollbackChangeOrderResponseBody = exports.AbortAndRollbackChangeOrderRequest = exports.WebWAFConfig = exports.WebVersionStatus = exports.WebTrafficConfig = exports.WebTLSConfig = exports.WebStaticsInfo = exports.WebScalingConfig = exports.WebOSSMountPoint = exports.WebOSSConfig = exports.WebNetworkConfig = exports.WebNASMountPoint = exports.WebNASConfig = exports.WebLogEntry = exports.WebInstanceInfo = exports.WebCustomDomainBody = exports.WebCustomDomain = exports.WebCertConfig = exports.WebApplicationWithStatus = exports.WebApplicationWithInstanceCount = exports.WebApplicationTrafficConfigBody = exports.WebApplicationStatus = exports.WebApplicationScalingConfigBody = exports.WebApplicationRevisionBody = exports.WebApplicationResourceStaticsBody = exports.WebApplicationInstanceLogsBody = exports.WebApplicationBody = exports.WebApplication = exports.WebAclEntryConfig = exports.WebAclConfig = exports.WAFConfig = exports.VersionStatus = exports.Version = exports.VPCConfig = exports.UpdateWebCustomDomainInput = exports.UpdateWebApplicationTrafficConfigInput = exports.UpdateWebApplicationScalingConfigInput = exports.UpdateWebApplicationInput = exports.UpdateCustomDomainInput = exports.UpdateAttributesInput = exports.UpdateApplicationTrafficConfigInput = exports.UpdateApplicationScaleConfigInput = exports.UpdateApplicationInput = exports.TrafficConfig = exports.TracingConfig = exports.TomcatConfig = exports.TLSConfig = exports.TCPSocketAction = exports.Submenu = exports.StaticsInfo = void 0;\nexports.DeleteApplicationScalingRuleResponseBody = exports.DeleteApplicationScalingRuleRequest = exports.DeleteApplicationResponse = exports.DeleteApplicationResponseBody = exports.DeleteApplicationRequest = exports.CreateWebCustomDomainResponse = exports.CreateWebCustomDomainRequest = exports.CreateWebApplicationResponse = exports.CreateWebApplicationRequest = exports.CreateSecretResponse = exports.CreateSecretResponseBody = exports.CreateSecretShrinkRequest = exports.CreateSecretRequest = exports.CreateNamespaceResponse = exports.CreateNamespaceResponseBody = exports.CreateNamespaceRequest = exports.CreateJobResponse = exports.CreateJobResponseBody = exports.CreateJobRequest = exports.CreateIngressResponse = exports.CreateIngressResponseBody = exports.CreateIngressRequest = exports.CreateGreyTagRouteResponse = exports.CreateGreyTagRouteResponseBody = exports.CreateGreyTagRouteRequest = exports.CreateConfigMapResponse = exports.CreateConfigMapResponseBody = exports.CreateConfigMapRequest = exports.CreateApplicationScalingRuleResponse = exports.CreateApplicationScalingRuleResponseBody = exports.CreateApplicationScalingRuleRequest = exports.CreateApplicationResponse = exports.CreateApplicationResponseBody = exports.CreateApplicationRequest = exports.ConfirmPipelineBatchResponse = exports.ConfirmPipelineBatchResponseBody = exports.ConfirmPipelineBatchRequest = exports.BindSlbResponse = exports.BindSlbResponseBody = exports.BindSlbRequest = exports.BatchStopApplicationsResponse = exports.BatchStopApplicationsResponseBody = exports.BatchStopApplicationsRequest = exports.BatchStartApplicationsResponse = exports.BatchStartApplicationsResponseBody = exports.BatchStartApplicationsRequest = exports.AbortChangeOrderResponse = exports.AbortChangeOrderResponseBody = exports.AbortChangeOrderRequest = exports.AbortAndRollbackChangeOrderResponse = void 0;\nexports.DescribeApplicationScalingRulesRequest = exports.DescribeApplicationScalingRuleResponse = exports.DescribeApplicationScalingRuleResponseBody = exports.DescribeApplicationScalingRuleRequest = exports.DescribeApplicationInstancesResponse = exports.DescribeApplicationInstancesResponseBody = exports.DescribeApplicationInstancesRequest = exports.DescribeApplicationImageResponse = exports.DescribeApplicationImageResponseBody = exports.DescribeApplicationImageRequest = exports.DescribeApplicationGroupsResponse = exports.DescribeApplicationGroupsResponseBody = exports.DescribeApplicationGroupsRequest = exports.DescribeApplicationConfigResponse = exports.DescribeApplicationConfigResponseBody = exports.DescribeApplicationConfigRequest = exports.DescribeAppServiceDetailResponse = exports.DescribeAppServiceDetailResponseBody = exports.DescribeAppServiceDetailRequest = exports.DeployApplicationResponse = exports.DeployApplicationResponseBody = exports.DeployApplicationRequest = exports.DeleteWebCustomDomainResponse = exports.DeleteWebCustomDomainRequest = exports.DeleteWebApplicationRevisionResponse = exports.DeleteWebApplicationRevisionRequest = exports.DeleteWebApplicationResponse = exports.DeleteWebApplicationRequest = exports.DeleteSecretResponse = exports.DeleteSecretResponseBody = exports.DeleteSecretRequest = exports.DeleteNamespaceResponse = exports.DeleteNamespaceResponseBody = exports.DeleteNamespaceRequest = exports.DeleteJobResponse = exports.DeleteJobResponseBody = exports.DeleteJobRequest = exports.DeleteIngressResponse = exports.DeleteIngressResponseBody = exports.DeleteIngressRequest = exports.DeleteHistoryJobResponse = exports.DeleteHistoryJobResponseBody = exports.DeleteHistoryJobRequest = exports.DeleteGreyTagRouteResponse = exports.DeleteGreyTagRouteResponseBody = exports.DeleteGreyTagRouteRequest = exports.DeleteConfigMapResponse = exports.DeleteConfigMapResponseBody = exports.DeleteConfigMapRequest = exports.DeleteApplicationScalingRuleResponse = void 0;\nexports.DescribeNamespaceResourcesResponseBody = exports.DescribeNamespaceResourcesRequest = exports.DescribeNamespaceListResponse = exports.DescribeNamespaceListResponseBody = exports.DescribeNamespaceListRequest = exports.DescribeNamespaceResponse = exports.DescribeNamespaceResponseBody = exports.DescribeNamespaceRequest = exports.DescribeJobStatusResponse = exports.DescribeJobStatusResponseBody = exports.DescribeJobStatusRequest = exports.DescribeJobHistoryResponse = exports.DescribeJobHistoryResponseBody = exports.DescribeJobHistoryRequest = exports.DescribeJobResponse = exports.DescribeJobResponseBody = exports.DescribeJobRequest = exports.DescribeInstanceSpecificationsResponse = exports.DescribeInstanceSpecificationsResponseBody = exports.DescribeInstanceLogResponse = exports.DescribeInstanceLogResponseBody = exports.DescribeInstanceLogRequest = exports.DescribeIngressResponse = exports.DescribeIngressResponseBody = exports.DescribeIngressRequest = exports.DescribeGreyTagRouteResponse = exports.DescribeGreyTagRouteResponseBody = exports.DescribeGreyTagRouteRequest = exports.DescribeEdasContainersResponse = exports.DescribeEdasContainersResponseBody = exports.DescribeConfigurationPriceResponse = exports.DescribeConfigurationPriceResponseBody = exports.DescribeConfigurationPriceRequest = exports.DescribeConfigMapResponse = exports.DescribeConfigMapResponseBody = exports.DescribeConfigMapRequest = exports.DescribeComponentsResponse = exports.DescribeComponentsResponseBody = exports.DescribeComponentsRequest = exports.DescribeChangeOrderResponse = exports.DescribeChangeOrderResponseBody = exports.DescribeChangeOrderRequest = exports.DescribeApplicationStatusResponse = exports.DescribeApplicationStatusResponseBody = exports.DescribeApplicationStatusRequest = exports.DescribeApplicationSlbsResponse = exports.DescribeApplicationSlbsResponseBody = exports.DescribeApplicationSlbsRequest = exports.DescribeApplicationScalingRulesResponse = exports.DescribeApplicationScalingRulesResponseBody = void 0;\nexports.GetWarningEventMetricResponse = exports.GetWarningEventMetricResponseBody = exports.GetWarningEventMetricRequest = exports.GetScaleAppMetricResponse = exports.GetScaleAppMetricResponseBody = exports.GetScaleAppMetricRequest = exports.GetChangeOrderMetricResponse = exports.GetChangeOrderMetricResponseBody = exports.GetChangeOrderMetricRequest = exports.GetAvailabilityMetricResponse = exports.GetAvailabilityMetricResponseBody = exports.GetAvailabilityMetricRequest = exports.GetArmsTopNMetricResponse = exports.GetArmsTopNMetricResponseBody = exports.GetArmsTopNMetricRequest = exports.ExecJobResponse = exports.ExecJobResponseBody = exports.ExecJobRequest = exports.EnableApplicationScalingRuleResponse = exports.EnableApplicationScalingRuleResponseBody = exports.EnableApplicationScalingRuleRequest = exports.DisableApplicationScalingRuleResponse = exports.DisableApplicationScalingRuleResponseBody = exports.DisableApplicationScalingRuleRequest = exports.DescribeWebInstanceLogsResponse = exports.DescribeWebInstanceLogsRequest = exports.DescribeWebCustomDomainResponse = exports.DescribeWebCustomDomainRequest = exports.DescribeWebApplicationTrafficConfigResponse = exports.DescribeWebApplicationTrafficConfigRequest = exports.DescribeWebApplicationScalingConfigResponse = exports.DescribeWebApplicationScalingConfigRequest = exports.DescribeWebApplicationRevisionResponse = exports.DescribeWebApplicationRevisionRequest = exports.DescribeWebApplicationResourceStaticsResponse = exports.DescribeWebApplicationResourceStaticsRequest = exports.DescribeWebApplicationResponse = exports.DescribeWebApplicationRequest = exports.DescribeSecretResponse = exports.DescribeSecretResponseBody = exports.DescribeSecretRequest = exports.DescribeRegionsResponse = exports.DescribeRegionsResponseBody = exports.DescribePipelineResponse = exports.DescribePipelineResponseBody = exports.DescribePipelineRequest = exports.DescribeNamespacesResponse = exports.DescribeNamespacesResponseBody = exports.DescribeNamespacesRequest = exports.DescribeNamespaceResourcesResponse = void 0;\nexports.ListWebApplicationRevisionsResponse = exports.ListWebApplicationRevisionsRequest = exports.ListWebApplicationInstancesResponse = exports.ListWebApplicationInstancesShrinkRequest = exports.ListWebApplicationInstancesRequest = exports.ListTagResourcesResponse = exports.ListTagResourcesResponseBody = exports.ListTagResourcesRequest = exports.ListSecretsResponse = exports.ListSecretsResponseBody = exports.ListSecretsRequest = exports.ListPublishedServicesResponse = exports.ListPublishedServicesResponseBody = exports.ListPublishedServicesRequest = exports.ListNamespacedConfigMapsResponse = exports.ListNamespacedConfigMapsResponseBody = exports.ListNamespacedConfigMapsRequest = exports.ListNamespaceChangeOrdersResponse = exports.ListNamespaceChangeOrdersResponseBody = exports.ListNamespaceChangeOrdersRequest = exports.ListLogConfigsResponse = exports.ListLogConfigsResponseBody = exports.ListLogConfigsRequest = exports.ListJobsResponse = exports.ListJobsResponseBody = exports.ListJobsRequest = exports.ListIngressesResponse = exports.ListIngressesResponseBody = exports.ListIngressesRequest = exports.ListGreyTagRouteResponse = exports.ListGreyTagRouteResponseBody = exports.ListGreyTagRouteRequest = exports.ListConsumedServicesResponse = exports.ListConsumedServicesResponseBody = exports.ListConsumedServicesRequest = exports.ListChangeOrdersResponse = exports.ListChangeOrdersResponseBody = exports.ListChangeOrdersRequest = exports.ListApplicationsResponse = exports.ListApplicationsResponseBody = exports.ListApplicationsRequest = exports.ListAppVersionsResponse = exports.ListAppVersionsResponseBody = exports.ListAppVersionsRequest = exports.ListAppServicesPageResponse = exports.ListAppServicesPageResponseBody = exports.ListAppServicesPageRequest = exports.ListAppEventsResponse = exports.ListAppEventsResponseBody = exports.ListAppEventsRequest = void 0;\nexports.UntagResourcesResponseBody = exports.UntagResourcesRequest = exports.UnbindSlbResponse = exports.UnbindSlbResponseBody = exports.UnbindSlbRequest = exports.TagResourcesResponse = exports.TagResourcesResponseBody = exports.TagResourcesRequest = exports.SuspendJobResponse = exports.SuspendJobResponseBody = exports.SuspendJobRequest = exports.StopWebApplicationResponse = exports.StopWebApplicationRequest = exports.StopApplicationResponse = exports.StopApplicationResponseBody = exports.StopApplicationRequest = exports.StartWebApplicationResponse = exports.StartWebApplicationRequest = exports.StartApplicationResponse = exports.StartApplicationResponseBody = exports.StartApplicationRequest = exports.RollbackApplicationResponse = exports.RollbackApplicationResponseBody = exports.RollbackApplicationRequest = exports.RestartInstancesResponse = exports.RestartInstancesResponseBody = exports.RestartInstancesRequest = exports.RestartApplicationResponse = exports.RestartApplicationResponseBody = exports.RestartApplicationRequest = exports.RescaleApplicationVerticallyResponse = exports.RescaleApplicationVerticallyResponseBody = exports.RescaleApplicationVerticallyRequest = exports.RescaleApplicationResponse = exports.RescaleApplicationResponseBody = exports.RescaleApplicationRequest = exports.ReduceApplicationCapacityByInstanceIdsResponse = exports.ReduceApplicationCapacityByInstanceIdsResponseBody = exports.ReduceApplicationCapacityByInstanceIdsRequest = exports.QueryResourceStaticsResponse = exports.QueryResourceStaticsResponseBody = exports.QueryResourceStaticsRequest = exports.PublishWebApplicationRevisionResponse = exports.PublishWebApplicationRevisionRequest = exports.OpenSaeServiceResponse = exports.OpenSaeServiceResponseBody = exports.ListWebCustomDomainsResponse = exports.ListWebCustomDomainsRequest = exports.ListWebApplicationsResponse = exports.ListWebApplicationsRequest = void 0;\nexports.BuildPipelineImageConfig = exports.BuildPipelineDeployConfig = exports.BuildPipelineCodeConfig = exports.BuildPipelineBuildConfig = exports.AppStackTaskSteps = exports.AppStackInstanceParameters = exports.AppStackInstanceEndpoints = exports.UpdateWebCustomDomainResponse = exports.UpdateWebCustomDomainRequest = exports.UpdateWebApplicationTrafficConfigResponse = exports.UpdateWebApplicationTrafficConfigRequest = exports.UpdateWebApplicationScalingConfigResponse = exports.UpdateWebApplicationScalingConfigRequest = exports.UpdateWebApplicationResponse = exports.UpdateWebApplicationRequest = exports.UpdateSecretResponse = exports.UpdateSecretResponseBody = exports.UpdateSecretShrinkRequest = exports.UpdateSecretRequest = exports.UpdateNamespaceVpcResponse = exports.UpdateNamespaceVpcResponseBody = exports.UpdateNamespaceVpcRequest = exports.UpdateNamespaceResponse = exports.UpdateNamespaceResponseBody = exports.UpdateNamespaceRequest = exports.UpdateJobResponse = exports.UpdateJobResponseBody = exports.UpdateJobRequest = exports.UpdateIngressResponse = exports.UpdateIngressResponseBody = exports.UpdateIngressRequest = exports.UpdateGreyTagRouteResponse = exports.UpdateGreyTagRouteResponseBody = exports.UpdateGreyTagRouteRequest = exports.UpdateConfigMapResponse = exports.UpdateConfigMapResponseBody = exports.UpdateConfigMapRequest = exports.UpdateApplicationVswitchesResponse = exports.UpdateApplicationVswitchesResponseBody = exports.UpdateApplicationVswitchesRequest = exports.UpdateApplicationScalingRuleResponse = exports.UpdateApplicationScalingRuleResponseBody = exports.UpdateApplicationScalingRuleRequest = exports.UpdateApplicationDescriptionResponse = exports.UpdateApplicationDescriptionResponseBody = exports.UpdateApplicationDescriptionRequest = exports.UpdateAppSecurityGroupResponse = exports.UpdateAppSecurityGroupResponseBody = exports.UpdateAppSecurityGroupRequest = exports.UntagResourcesResponse = void 0;\nexports.DescribeApplicationConfigResponseBodyDataConfigMapMountDesc = exports.DescribeAppServiceDetailResponseBodyData = exports.DescribeAppServiceDetailResponseBodyDataMethods = exports.DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions = exports.DeployApplicationResponseBodyData = exports.DeleteSecretResponseBodyData = exports.DeleteIngressResponseBodyData = exports.DeleteGreyTagRouteResponseBodyData = exports.DeleteConfigMapResponseBodyData = exports.DeleteApplicationResponseBodyData = exports.CreateSecretResponseBodyData = exports.CreateSecretRequestSecretData = exports.CreateNamespaceResponseBodyData = exports.CreateJobResponseBodyData = exports.CreateIngressResponseBodyData = exports.CreateGreyTagRouteResponseBodyData = exports.CreateConfigMapResponseBodyData = exports.CreateApplicationScalingRuleResponseBodyData = exports.CreateApplicationScalingRuleResponseBodyDataTimer = exports.CreateApplicationScalingRuleResponseBodyDataTimerSchedules = exports.CreateApplicationScalingRuleResponseBodyDataMetric = exports.CreateApplicationScalingRuleResponseBodyDataMetricMetrics = exports.CreateApplicationResponseBodyData = exports.ConfirmPipelineBatchResponseBodyData = exports.BindSlbResponseBodyData = exports.BatchStopApplicationsResponseBodyData = exports.BatchStartApplicationsResponseBodyData = exports.AbortChangeOrderResponseBodyData = exports.AbortAndRollbackChangeOrderResponseBodyData = exports.SubmenuItems = exports.SourceCodeAccountOrganizations = exports.SLSConfigCollectConfigs = exports.ProbeProbeHandler = exports.ProbeProbeHandlerTcpSocket = exports.ProbeProbeHandlerHttpGet = exports.ProbeProbeHandlerHttpGetHttpHeaders = exports.PriceEstimateOutputItems = exports.PriceEstimateOutputItemsSteps = exports.PriceEstimateOutputApps = exports.PriceEstimateOutputAppsUsages = exports.BuildPipelineRunTriggerConfig = exports.BuildPipelineRunSteps = exports.BuildPipelineRunPackageConfig = exports.BuildPipelineRunImageConfig = exports.BuildPipelineRunDeployConfig = exports.BuildPipelineRunCodeConfig = exports.BuildPipelineRunBuildConfig = exports.BuildPipelineRunBuildConfigTrigger = exports.BuildPipelineTriggerConfig = exports.BuildPipelinePackageConfig = void 0;\nexports.DescribeConfigurationPriceResponseBodyDataTrafficPrice = exports.DescribeConfigurationPriceResponseBodyDataTrafficPriceRules = exports.DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder = exports.DescribeConfigurationPriceResponseBodyDataRules = exports.DescribeConfigurationPriceResponseBodyDataRequestPrice = exports.DescribeConfigurationPriceResponseBodyDataRequestPriceRules = exports.DescribeConfigurationPriceResponseBodyDataRequestPriceOrder = exports.DescribeConfigurationPriceResponseBodyDataOrder = exports.DescribeConfigurationPriceResponseBodyDataCpuMemPrice = exports.DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules = exports.DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder = exports.DescribeConfigurationPriceResponseBodyDataBagUsage = exports.DescribeConfigMapResponseBodyData = exports.DescribeConfigMapResponseBodyDataRelateApps = exports.DescribeComponentsResponseBodyData = exports.DescribeChangeOrderResponseBodyData = exports.DescribeChangeOrderResponseBodyDataPipelines = exports.DescribeApplicationStatusResponseBodyData = exports.DescribeApplicationSlbsResponseBodyData = exports.DescribeApplicationSlbsResponseBodyDataIntranet = exports.DescribeApplicationSlbsResponseBodyDataInternet = exports.DescribeApplicationScalingRulesResponseBodyData = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics = exports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics = exports.DescribeApplicationScalingRuleResponseBodyData = exports.DescribeApplicationScalingRuleResponseBodyDataTimer = exports.DescribeApplicationScalingRuleResponseBodyDataTimerSchedules = exports.DescribeApplicationScalingRuleResponseBodyDataMetric = exports.DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules = exports.DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules = exports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus = exports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics = exports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics = exports.DescribeApplicationScalingRuleResponseBodyDataMetricMetrics = exports.DescribeApplicationInstancesResponseBodyData = exports.DescribeApplicationInstancesResponseBodyDataInstances = exports.DescribeApplicationImageResponseBodyData = exports.DescribeApplicationGroupsResponseBodyData = exports.DescribeApplicationConfigResponseBodyData = exports.DescribeApplicationConfigResponseBodyDataTags = exports.DescribeApplicationConfigResponseBodyDataOssMountDescs = exports.DescribeApplicationConfigResponseBodyDataMountDesc = void 0;\nexports.ListApplicationsResponseBodyData = exports.ListApplicationsResponseBodyDataApplications = exports.ListApplicationsResponseBodyDataApplicationsTags = exports.ListApplicationsResponseBodyDataApplicationsChildren = exports.ListApplicationsResponseBodyDataApplicationsChildrenTags = exports.ListAppVersionsResponseBodyData = exports.ListAppServicesPageResponseBodyData = exports.ListAppServicesPageResponseBodyDataResult = exports.ListAppEventsResponseBodyData = exports.ListAppEventsResponseBodyDataAppEventEntity = exports.GetWarningEventMetricResponseBodyData = exports.GetScaleAppMetricResponseBodyData = exports.GetChangeOrderMetricResponseBodyData = exports.GetAvailabilityMetricResponseBodyData = exports.GetArmsTopNMetricResponseBodyData = exports.ExecJobResponseBodyData = exports.DescribeSecretResponseBodyData = exports.DescribeSecretResponseBodyDataRelateApps = exports.DescribeRegionsResponseBodyRegions = exports.DescribeRegionsResponseBodyRegionsRegion = exports.DescribeRegionsResponseBodyRegionsRegionRecommendZones = exports.DescribePipelineResponseBodyData = exports.DescribePipelineResponseBodyDataStageList = exports.DescribePipelineResponseBodyDataStageListTaskList = exports.DescribeNamespacesResponseBodyData = exports.DescribeNamespacesResponseBodyDataNamespaces = exports.DescribeNamespaceResourcesResponseBodyData = exports.DescribeNamespaceListResponseBodyData = exports.DescribeNamespaceResponseBodyData = exports.DescribeJobStatusResponseBodyData = exports.DescribeJobHistoryResponseBodyData = exports.DescribeJobHistoryResponseBodyDataJobs = exports.DescribeJobResponseBodyData = exports.DescribeJobResponseBodyDataTags = exports.DescribeJobResponseBodyDataOssMountDescs = exports.DescribeJobResponseBodyDataMountDesc = exports.DescribeJobResponseBodyDataConfigMapMountDesc = exports.DescribeInstanceSpecificationsResponseBodyData = exports.DescribeIngressResponseBodyData = exports.DescribeIngressResponseBodyDataRules = exports.DescribeIngressResponseBodyDataDefaultRule = exports.DescribeGreyTagRouteResponseBodyData = exports.DescribeGreyTagRouteResponseBodyDataScRules = exports.DescribeGreyTagRouteResponseBodyDataScRulesItems = exports.DescribeGreyTagRouteResponseBodyDataDubboRules = exports.DescribeGreyTagRouteResponseBodyDataDubboRulesItems = exports.DescribeGreyTagRouteResponseBodyDataAlbRules = exports.DescribeGreyTagRouteResponseBodyDataAlbRulesItems = exports.DescribeEdasContainersResponseBodyData = exports.DescribeConfigurationPriceResponseBodyData = void 0;\nexports.UpdateJobResponseBodyData = exports.UpdateIngressResponseBodyData = exports.UpdateGreyTagRouteResponseBodyData = exports.UpdateConfigMapResponseBodyData = exports.UpdateApplicationScalingRuleResponseBodyData = exports.UpdateApplicationScalingRuleResponseBodyDataTimer = exports.UpdateApplicationScalingRuleResponseBodyDataTimerSchedules = exports.UpdateApplicationScalingRuleResponseBodyDataMetric = exports.UpdateApplicationScalingRuleResponseBodyDataMetricMetrics = exports.UnbindSlbResponseBodyData = exports.StopApplicationResponseBodyData = exports.StartApplicationResponseBodyData = exports.RollbackApplicationResponseBodyData = exports.RestartInstancesResponseBodyData = exports.RestartApplicationResponseBodyData = exports.RescaleApplicationVerticallyResponseBodyData = exports.RescaleApplicationResponseBodyData = exports.ReduceApplicationCapacityByInstanceIdsResponseBodyData = exports.QueryResourceStaticsResponseBodyData = exports.QueryResourceStaticsResponseBodyDataSummary = exports.QueryResourceStaticsResponseBodyDataRealTimeRes = exports.ListTagResourcesResponseBodyData = exports.ListTagResourcesResponseBodyDataTagResources = exports.ListSecretsResponseBodyData = exports.ListSecretsResponseBodyDataSecrets = exports.ListSecretsResponseBodyDataSecretsRelateApps = exports.ListPublishedServicesResponseBodyData = exports.ListNamespacedConfigMapsResponseBodyData = exports.ListNamespacedConfigMapsResponseBodyDataConfigMaps = exports.ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps = exports.ListNamespaceChangeOrdersResponseBodyData = exports.ListNamespaceChangeOrdersResponseBodyDataChangeOrderList = exports.ListLogConfigsResponseBodyData = exports.ListLogConfigsResponseBodyDataLogConfigs = exports.ListJobsResponseBodyData = exports.ListJobsResponseBodyDataApplications = exports.ListJobsResponseBodyDataApplicationsTags = exports.ListIngressesResponseBodyData = exports.ListIngressesResponseBodyDataIngressList = exports.ListGreyTagRouteResponseBodyData = exports.ListGreyTagRouteResponseBodyDataResult = exports.ListGreyTagRouteResponseBodyDataResultScRules = exports.ListGreyTagRouteResponseBodyDataResultScRulesItems = exports.ListGreyTagRouteResponseBodyDataResultDubboRules = exports.ListGreyTagRouteResponseBodyDataResultDubboRulesItems = exports.ListGreyTagRouteResponseBodyDataResultAlbRules = exports.ListGreyTagRouteResponseBodyDataResultAlbRulesItems = exports.ListConsumedServicesResponseBodyData = exports.ListChangeOrdersResponseBodyData = exports.ListChangeOrdersResponseBodyDataChangeOrderList = void 0;\nexports.UpdateSecretResponseBodyData = exports.UpdateSecretRequestSecretData = exports.UpdateNamespaceResponseBodyData = void 0;\n// This file is auto-generated, don't edit it\n/**\n */\nconst tea_util_1 = __importStar(require(\"@alicloud/tea-util\")), $Util = tea_util_1;\nconst openapi_client_1 = __importStar(require(\"@alicloud/openapi-client\")), $OpenApi = openapi_client_1;\nconst openapi_util_1 = __importDefault(require(\"@alicloud/openapi-util\"));\nconst endpoint_util_1 = __importDefault(require(\"@alicloud/endpoint-util\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass AclConfig extends $tea.Model {\n    static names() {\n        return {\n            aclEntries: 'aclEntries',\n        };\n    }\n    static types() {\n        return {\n            aclEntries: { 'type': 'array', 'itemType': AclEntryConfig },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AclConfig = AclConfig;\nclass AclEntryConfig extends $tea.Model {\n    static names() {\n        return {\n            entry: 'entry',\n        };\n    }\n    static types() {\n        return {\n            entry: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AclEntryConfig = AclEntryConfig;\nclass AppStackInstance extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            endpoints: 'Endpoints',\n            instanceId: 'InstanceId',\n            instanceName: 'InstanceName',\n            parameters: 'Parameters',\n            stackId: 'StackId',\n            status: 'Status',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'number',\n            endpoints: { 'type': 'array', 'itemType': AppStackInstanceEndpoints },\n            instanceId: 'string',\n            instanceName: 'string',\n            parameters: { 'type': 'array', 'itemType': AppStackInstanceParameters },\n            stackId: 'string',\n            status: 'string',\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackInstance = AppStackInstance;\nclass AppStackResource extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            instanceId: 'InstanceId',\n            productCode: 'ProductCode',\n            resourceId: 'ResourceId',\n            resourceName: 'ResourceName',\n            resourceType: 'ResourceType',\n            stackId: 'StackId',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'number',\n            instanceId: 'string',\n            productCode: 'string',\n            resourceId: 'string',\n            resourceName: 'string',\n            resourceType: 'string',\n            stackId: 'string',\n            status: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackResource = AppStackResource;\nclass AppStackTask extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            endTime: 'EndTime',\n            instanceId: 'InstanceId',\n            stackId: 'StackId',\n            startTime: 'StartTime',\n            status: 'Status',\n            steps: 'Steps',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'number',\n            endTime: 'number',\n            instanceId: 'string',\n            stackId: 'string',\n            startTime: 'number',\n            status: 'string',\n            steps: { 'type': 'array', 'itemType': AppStackTaskSteps },\n            taskId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackTask = AppStackTask;\nclass Application extends $tea.Model {\n    static names() {\n        return {\n            requestId: 'RequestId',\n            applicationId: 'applicationId',\n            applicationName: 'applicationName',\n            args: 'args',\n            caPort: 'caPort',\n            codeChecksum: 'codeChecksum',\n            codeSize: 'codeSize',\n            command: 'command',\n            cpu: 'cpu',\n            createdTime: 'createdTime',\n            customDNS: 'customDNS',\n            customDomainName: 'customDomainName',\n            customHealthCheckConfig: 'customHealthCheckConfig',\n            customHostAlias: 'customHostAlias',\n            customRuntimeConfig: 'customRuntimeConfig',\n            description: 'description',\n            diskSize: 'diskSize',\n            enableAppMetric: 'enableAppMetric',\n            enableArmsAdvanced: 'enableArmsAdvanced',\n            environmentVariables: 'environmentVariables',\n            gpuMemorySize: 'gpuMemorySize',\n            handler: 'handler',\n            httpTriggerConfig: 'httpTriggerConfig',\n            imageConfig: 'imageConfig',\n            initializationTimeout: 'initializationTimeout',\n            initializer: 'initializer',\n            instanceConcurrency: 'instanceConcurrency',\n            instanceLifecycleConfig: 'instanceLifecycleConfig',\n            instanceSoftConcurrency: 'instanceSoftConcurrency',\n            instanceType: 'instanceType',\n            internetAccess: 'internetAccess',\n            lastModifiedTime: 'lastModifiedTime',\n            layers: 'layers',\n            layersArnV2: 'layersArnV2',\n            livenessProbe: 'livenessProbe',\n            logConfig: 'logConfig',\n            memorySize: 'memorySize',\n            namespace: 'namespace',\n            namespaceID: 'namespaceID',\n            namespaceName: 'namespaceName',\n            nasConfig: 'nasConfig',\n            ossMountConfig: 'ossMountConfig',\n            runtime: 'runtime',\n            scaleConfig: 'scaleConfig',\n            slsConfig: 'slsConfig',\n            startupProbe: 'startupProbe',\n            timeout: 'timeout',\n            tracingConfig: 'tracingConfig',\n            urlInternet: 'urlInternet',\n            urlIntranet: 'urlIntranet',\n            version: 'version',\n            vpcConfig: 'vpcConfig',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            applicationId: 'string',\n            applicationName: 'string',\n            args: 'string',\n            caPort: 'number',\n            codeChecksum: 'string',\n            codeSize: 'number',\n            command: 'string',\n            cpu: 'number',\n            createdTime: 'string',\n            customDNS: CustomDNS,\n            customDomainName: 'string',\n            customHealthCheckConfig: CustomHealthCheckConfig,\n            customHostAlias: CustomHostAlias,\n            customRuntimeConfig: CustomRuntimeConfig,\n            description: 'string',\n            diskSize: 'number',\n            enableAppMetric: 'boolean',\n            enableArmsAdvanced: 'boolean',\n            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            gpuMemorySize: 'number',\n            handler: 'string',\n            httpTriggerConfig: HTTPTriggerConfig,\n            imageConfig: ImageConfig,\n            initializationTimeout: 'number',\n            initializer: 'string',\n            instanceConcurrency: 'number',\n            instanceLifecycleConfig: InstanceLifecycleConfig,\n            instanceSoftConcurrency: 'number',\n            instanceType: 'string',\n            internetAccess: 'boolean',\n            lastModifiedTime: 'string',\n            layers: { 'type': 'array', 'itemType': 'string' },\n            layersArnV2: { 'type': 'array', 'itemType': 'string' },\n            livenessProbe: Probe,\n            logConfig: LogConfig,\n            memorySize: 'number',\n            namespace: 'string',\n            namespaceID: 'string',\n            namespaceName: 'string',\n            nasConfig: NASConfig,\n            ossMountConfig: OSSMountConfig,\n            runtime: 'string',\n            scaleConfig: ScaleConfig,\n            slsConfig: SLSConfig,\n            startupProbe: Probe,\n            timeout: 'number',\n            tracingConfig: TracingConfig,\n            urlInternet: 'string',\n            urlIntranet: 'string',\n            version: Version,\n            vpcConfig: VPCConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Application = Application;\nclass ApplicationStatus extends $tea.Model {\n    static names() {\n        return {\n            instanceCount: 'instanceCount',\n            scaleConfig: 'scaleConfig',\n        };\n    }\n    static types() {\n        return {\n            instanceCount: 'number',\n            scaleConfig: ScaleConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ApplicationStatus = ApplicationStatus;\nclass ApplicationWithStatus extends $tea.Model {\n    static names() {\n        return {\n            application: 'application',\n            status: 'status',\n        };\n    }\n    static types() {\n        return {\n            application: Application,\n            status: ApplicationStatus,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ApplicationWithStatus = ApplicationWithStatus;\nclass ArmsConfig extends $tea.Model {\n    static names() {\n        return {\n            agentVersion: 'agentVersion',\n            appId: 'appId',\n            licenseKey: 'licenseKey',\n        };\n    }\n    static types() {\n        return {\n            agentVersion: 'string',\n            appId: 'string',\n            licenseKey: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ArmsConfig = ArmsConfig;\nclass BuildPipeline extends $tea.Model {\n    static names() {\n        return {\n            applicationId: 'ApplicationId',\n            applicationName: 'ApplicationName',\n            buildConfig: 'BuildConfig',\n            codeConfig: 'CodeConfig',\n            deployConfig: 'DeployConfig',\n            enabled: 'Enabled',\n            imageConfig: 'ImageConfig',\n            packageConfig: 'PackageConfig',\n            triggerConfig: 'TriggerConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationId: 'string',\n            applicationName: 'string',\n            buildConfig: BuildPipelineBuildConfig,\n            codeConfig: BuildPipelineCodeConfig,\n            deployConfig: BuildPipelineDeployConfig,\n            enabled: 'boolean',\n            imageConfig: BuildPipelineImageConfig,\n            packageConfig: BuildPipelinePackageConfig,\n            triggerConfig: BuildPipelineTriggerConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipeline = BuildPipeline;\nclass BuildPipelineRun extends $tea.Model {\n    static names() {\n        return {\n            buildConfig: 'BuildConfig',\n            buildDuration: 'BuildDuration',\n            codeConfig: 'CodeConfig',\n            createTime: 'CreateTime',\n            deployConfig: 'DeployConfig',\n            deployDuration: 'DeployDuration',\n            endTime: 'EndTime',\n            imageConfig: 'ImageConfig',\n            packageConfig: 'PackageConfig',\n            pipelineId: 'PipelineId',\n            pipelineRunId: 'PipelineRunId',\n            startTime: 'StartTime',\n            status: 'Status',\n            steps: 'Steps',\n            triggerConfig: 'TriggerConfig',\n            versionId: 'VersionId',\n            waitDuration: 'WaitDuration',\n        };\n    }\n    static types() {\n        return {\n            buildConfig: BuildPipelineRunBuildConfig,\n            buildDuration: 'number',\n            codeConfig: BuildPipelineRunCodeConfig,\n            createTime: 'number',\n            deployConfig: BuildPipelineRunDeployConfig,\n            deployDuration: 'number',\n            endTime: 'number',\n            imageConfig: BuildPipelineRunImageConfig,\n            packageConfig: BuildPipelineRunPackageConfig,\n            pipelineId: 'string',\n            pipelineRunId: 'string',\n            startTime: 'number',\n            status: 'string',\n            steps: { 'type': 'array', 'itemType': BuildPipelineRunSteps },\n            triggerConfig: BuildPipelineRunTriggerConfig,\n            versionId: 'string',\n            waitDuration: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRun = BuildPipelineRun;\nclass BuildPipelineRunLogLine extends $tea.Model {\n    static names() {\n        return {\n            content: 'Content',\n            offset: 'Offset',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            offset: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunLogLine = BuildPipelineRunLogLine;\nclass CertConfig extends $tea.Model {\n    static names() {\n        return {\n            certName: 'certName',\n            certificate: 'certificate',\n            privateKey: 'privateKey',\n        };\n    }\n    static types() {\n        return {\n            certName: 'string',\n            certificate: 'string',\n            privateKey: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CertConfig = CertConfig;\nclass Container extends $tea.Model {\n    static names() {\n        return {\n            args: 'Args',\n            command: 'Command',\n            environmentVariables: 'EnvironmentVariables',\n            image: 'Image',\n            metricsCollectConfig: 'MetricsCollectConfig',\n            port: 'Port',\n            requestConcurrency: 'RequestConcurrency',\n            requestTimeout: 'RequestTimeout',\n            resources: 'Resources',\n            SLSCollectConfigs: 'SLSCollectConfigs',\n            startupProbe: 'StartupProbe',\n            webNASConfig: 'WebNASConfig',\n            webOSSConfig: 'WebOSSConfig',\n        };\n    }\n    static types() {\n        return {\n            args: 'string',\n            command: 'string',\n            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            image: 'string',\n            metricsCollectConfig: MetricsCollectConfig,\n            port: 'number',\n            requestConcurrency: 'number',\n            requestTimeout: 'number',\n            resources: ContainerResources,\n            SLSCollectConfigs: SLSCollectConfigs,\n            startupProbe: StartupProbe,\n            webNASConfig: WebNASConfig,\n            webOSSConfig: WebOSSConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Container = Container;\nclass ContainerResources extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            memory: 'Memory',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            memory: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ContainerResources = ContainerResources;\nclass CreateApplicationInput extends $tea.Model {\n    static names() {\n        return {\n            applicationName: 'applicationName',\n            args: 'args',\n            caPort: 'caPort',\n            code: 'code',\n            command: 'command',\n            cpu: 'cpu',\n            customDNS: 'customDNS',\n            customHealthCheckConfig: 'customHealthCheckConfig',\n            customHostAlias: 'customHostAlias',\n            customRuntimeConfig: 'customRuntimeConfig',\n            description: 'description',\n            diskSize: 'diskSize',\n            environmentVariables: 'environmentVariables',\n            gpuMemorySize: 'gpuMemorySize',\n            handler: 'handler',\n            httpTriggerConfig: 'httpTriggerConfig',\n            imageConfig: 'imageConfig',\n            initializationTimeout: 'initializationTimeout',\n            initializer: 'initializer',\n            instanceConcurrency: 'instanceConcurrency',\n            instanceLifecycleConfig: 'instanceLifecycleConfig',\n            instanceSoftConcurrency: 'instanceSoftConcurrency',\n            instanceType: 'instanceType',\n            internetAccess: 'internetAccess',\n            layers: 'layers',\n            livenessProbe: 'livenessProbe',\n            logConfig: 'logConfig',\n            memorySize: 'memorySize',\n            namespaceID: 'namespaceID',\n            nasConfig: 'nasConfig',\n            ossMountConfig: 'ossMountConfig',\n            runtime: 'runtime',\n            scaleConfig: 'scaleConfig',\n            slsConfig: 'slsConfig',\n            startupProbe: 'startupProbe',\n            timeout: 'timeout',\n            tracingConfig: 'tracingConfig',\n            vpcConfig: 'vpcConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationName: 'string',\n            args: 'string',\n            caPort: 'number',\n            code: InputCodeLocation,\n            command: 'string',\n            cpu: 'number',\n            customDNS: CustomDNS,\n            customHealthCheckConfig: CustomHealthCheckConfig,\n            customHostAlias: CustomHostAlias,\n            customRuntimeConfig: CustomRuntimeConfig,\n            description: 'string',\n            diskSize: 'number',\n            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            gpuMemorySize: 'number',\n            handler: 'string',\n            httpTriggerConfig: HTTPTriggerConfig,\n            imageConfig: ImageConfig,\n            initializationTimeout: 'number',\n            initializer: 'string',\n            instanceConcurrency: 'number',\n            instanceLifecycleConfig: InstanceLifecycleConfig,\n            instanceSoftConcurrency: 'number',\n            instanceType: 'string',\n            internetAccess: 'boolean',\n            layers: { 'type': 'array', 'itemType': 'string' },\n            livenessProbe: Probe,\n            logConfig: LogConfig,\n            memorySize: 'number',\n            namespaceID: 'string',\n            nasConfig: NASConfig,\n            ossMountConfig: OSSMountConfig,\n            runtime: 'string',\n            scaleConfig: ScaleConfig,\n            slsConfig: SLSConfig,\n            startupProbe: Probe,\n            timeout: 'number',\n            tracingConfig: TracingConfig,\n            vpcConfig: VPCConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationInput = CreateApplicationInput;\nclass CreateCustomDomainInput extends $tea.Model {\n    static names() {\n        return {\n            applicationName: 'applicationName',\n            certConfig: 'certConfig',\n            domainName: 'domainName',\n            keepFullPath: 'keepFullPath',\n            namespaceID: 'namespaceID',\n            protocol: 'protocol',\n            tlsConfig: 'tlsConfig',\n            wafConfig: 'wafConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationName: 'string',\n            certConfig: CertConfig,\n            domainName: 'string',\n            keepFullPath: 'boolean',\n            namespaceID: 'string',\n            protocol: 'string',\n            tlsConfig: TLSConfig,\n            wafConfig: WAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateCustomDomainInput = CreateCustomDomainInput;\nclass CreateSlsIndexRequest extends $tea.Model {\n    static names() {\n        return {\n            logstore: 'logstore',\n            project: 'project',\n        };\n    }\n    static types() {\n        return {\n            logstore: 'string',\n            project: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSlsIndexRequest = CreateSlsIndexRequest;\nclass CreateSlsIndexResponse extends $tea.Model {\n    static names() {\n        return {\n            requestId: 'RequestId',\n            logStore: 'logStore',\n            project: 'project',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            logStore: 'string',\n            project: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSlsIndexResponse = CreateSlsIndexResponse;\nclass CreateSlsResourceResponse extends $tea.Model {\n    static names() {\n        return {\n            logStore: 'logStore',\n            project: 'project',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            logStore: 'string',\n            project: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSlsResourceResponse = CreateSlsResourceResponse;\nclass CreateWebApplicationInput extends $tea.Model {\n    static names() {\n        return {\n            applicationName: 'ApplicationName',\n            description: 'Description',\n            revisionConfig: 'RevisionConfig',\n            webNetworkConfig: 'WebNetworkConfig',\n            webScalingConfig: 'WebScalingConfig',\n            webTrafficConfig: 'WebTrafficConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationName: 'string',\n            description: 'string',\n            revisionConfig: RevisionConfig,\n            webNetworkConfig: WebNetworkConfig,\n            webScalingConfig: WebScalingConfig,\n            webTrafficConfig: WebTrafficConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebApplicationInput = CreateWebApplicationInput;\nclass CreateWebCustomDomainInput extends $tea.Model {\n    static names() {\n        return {\n            defaultForwardingAppName: 'DefaultForwardingAppName',\n            domainName: 'DomainName',\n            protocol: 'Protocol',\n            webCertConfig: 'WebCertConfig',\n            webTLSConfig: 'WebTLSConfig',\n            webWAFConfig: 'WebWAFConfig',\n        };\n    }\n    static types() {\n        return {\n            defaultForwardingAppName: 'string',\n            domainName: 'string',\n            protocol: 'string',\n            webCertConfig: WebCertConfig,\n            webTLSConfig: WebTLSConfig,\n            webWAFConfig: WebWAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebCustomDomainInput = CreateWebCustomDomainInput;\nclass CustomDNS extends $tea.Model {\n    static names() {\n        return {\n            dnsOptions: 'dnsOptions',\n            nameServers: 'nameServers',\n            searches: 'searches',\n        };\n    }\n    static types() {\n        return {\n            dnsOptions: { 'type': 'array', 'itemType': DNSOption },\n            nameServers: { 'type': 'array', 'itemType': 'string' },\n            searches: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CustomDNS = CustomDNS;\nclass CustomDomain extends $tea.Model {\n    static names() {\n        return {\n            accountId: 'accountId',\n            apiVersion: 'apiVersion',\n            certConfig: 'certConfig',\n            createdTime: 'createdTime',\n            domainName: 'domainName',\n            keepFullPath: 'keepFullPath',\n            lastModifiedTime: 'lastModifiedTime',\n            namespaceID: 'namespaceID',\n            protocol: 'protocol',\n            requestId: 'requestId',\n            routeConfig: 'routeConfig',\n            subdomainCount: 'subdomainCount',\n            tlsConfig: 'tlsConfig',\n            wafConfig: 'wafConfig',\n        };\n    }\n    static types() {\n        return {\n            accountId: 'string',\n            apiVersion: 'string',\n            certConfig: CertConfig,\n            createdTime: 'string',\n            domainName: 'string',\n            keepFullPath: 'boolean',\n            lastModifiedTime: 'string',\n            namespaceID: 'string',\n            protocol: 'string',\n            requestId: 'string',\n            routeConfig: RouteConfig,\n            subdomainCount: 'string',\n            tlsConfig: TLSConfig,\n            wafConfig: WAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CustomDomain = CustomDomain;\nclass CustomHealthCheckConfig extends $tea.Model {\n    static names() {\n        return {\n            failureThreshold: 'failureThreshold',\n            httpGetUrl: 'httpGetUrl',\n            initialDelaySeconds: 'initialDelaySeconds',\n            periodSeconds: 'periodSeconds',\n            successThreshold: 'successThreshold',\n            timeoutSeconds: 'timeoutSeconds',\n        };\n    }\n    static types() {\n        return {\n            failureThreshold: 'number',\n            httpGetUrl: 'string',\n            initialDelaySeconds: 'number',\n            periodSeconds: 'number',\n            successThreshold: 'number',\n            timeoutSeconds: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CustomHealthCheckConfig = CustomHealthCheckConfig;\nclass CustomHostAlias extends $tea.Model {\n    static names() {\n        return {\n            hostAliases: 'hostAliases',\n        };\n    }\n    static types() {\n        return {\n            hostAliases: { 'type': 'array', 'itemType': HostAlias },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CustomHostAlias = CustomHostAlias;\nclass CustomRuntimeConfig extends $tea.Model {\n    static names() {\n        return {\n            args: 'args',\n            command: 'command',\n        };\n    }\n    static types() {\n        return {\n            args: { 'type': 'array', 'itemType': 'string' },\n            command: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CustomRuntimeConfig = CustomRuntimeConfig;\nclass DNSOption extends $tea.Model {\n    static names() {\n        return {\n            name: 'name',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DNSOption = DNSOption;\nclass DescribeInstanceLogsOutput extends $tea.Model {\n    static names() {\n        return {\n            webLogEntrys: 'WebLogEntrys',\n        };\n    }\n    static types() {\n        return {\n            webLogEntrys: { 'type': 'array', 'itemType': WebLogEntry },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceLogsOutput = DescribeInstanceLogsOutput;\nclass DescribeWebAppStaticsOutput extends $tea.Model {\n    static names() {\n        return {\n            length: 'Length',\n            webAppStatics: 'WebAppStatics',\n        };\n    }\n    static types() {\n        return {\n            length: 'number',\n            webAppStatics: { 'type': 'array', 'itemType': WebStaticsInfo },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebAppStaticsOutput = DescribeWebAppStaticsOutput;\nclass DescribeWebStaticsQueryOutput extends $tea.Model {\n    static names() {\n        return {\n            length: 'Length',\n            webStatics: 'WebStatics',\n        };\n    }\n    static types() {\n        return {\n            length: 'number',\n            webStatics: { 'type': 'array', 'itemType': WebStaticsInfo },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebStaticsQueryOutput = DescribeWebStaticsQueryOutput;\nclass ExecAction extends $tea.Model {\n    static names() {\n        return {\n            command: 'command',\n        };\n    }\n    static types() {\n        return {\n            command: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExecAction = ExecAction;\nclass ExternalErrorSAEWeb extends $tea.Model {\n    static names() {\n        return {\n            code: 'code',\n            errorCode: 'errorCode',\n            message: 'message',\n            requestId: 'requestId',\n            success: 'success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExternalErrorSAEWeb = ExternalErrorSAEWeb;\nclass GRPCAction extends $tea.Model {\n    static names() {\n        return {\n            port: 'port',\n            service: 'service',\n        };\n    }\n    static types() {\n        return {\n            port: 'number',\n            service: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GRPCAction = GRPCAction;\nclass GetApplicationLogsInput extends $tea.Model {\n    static names() {\n        return {\n            backwardLine: 'backwardLine',\n            endTime: 'endTime',\n            forwardLine: 'forwardLine',\n            instanceID: 'instanceID',\n            isTail: 'isTail',\n            match: 'match',\n            message: 'message',\n            offset: 'offset',\n            packID: 'packID',\n            packMeta: 'packMeta',\n            startTime: 'startTime',\n            timestamp: 'timestamp',\n            versionID: 'versionID',\n        };\n    }\n    static types() {\n        return {\n            backwardLine: 'number',\n            endTime: 'number',\n            forwardLine: 'number',\n            instanceID: 'string',\n            isTail: 'boolean',\n            match: 'string',\n            message: 'string',\n            offset: 'number',\n            packID: 'string',\n            packMeta: 'string',\n            startTime: 'number',\n            timestamp: 'string',\n            versionID: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetApplicationLogsInput = GetApplicationLogsInput;\nclass GetApplicationLogsOutput extends $tea.Model {\n    static names() {\n        return {\n            logEntrys: 'logEntrys',\n            nextOffset: 'nextOffset',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            logEntrys: { 'type': 'array', 'itemType': LogEntry },\n            nextOffset: 'number',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetApplicationLogsOutput = GetApplicationLogsOutput;\nclass GetInstanceLogsInput extends $tea.Model {\n    static names() {\n        return {\n            backwardLine: 'backwardLine',\n            endTime: 'endTime',\n            forwardLine: 'forwardLine',\n            isTail: 'isTail',\n            match: 'match',\n            message: 'message',\n            offset: 'offset',\n            packID: 'packID',\n            packMeta: 'packMeta',\n            startTime: 'startTime',\n            timestamp: 'timestamp',\n            versionID: 'versionID',\n        };\n    }\n    static types() {\n        return {\n            backwardLine: 'number',\n            endTime: 'number',\n            forwardLine: 'number',\n            isTail: 'boolean',\n            match: 'string',\n            message: 'string',\n            offset: 'number',\n            packID: 'string',\n            packMeta: 'string',\n            startTime: 'number',\n            timestamp: 'string',\n            versionID: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetInstanceLogsInput = GetInstanceLogsInput;\nclass GetInstanceLogsOutput extends $tea.Model {\n    static names() {\n        return {\n            data: 'data',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            data: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetInstanceLogsOutput = GetInstanceLogsOutput;\nclass GetPerRequestLogsInput extends $tea.Model {\n    static names() {\n        return {\n            endTime: 'endTime',\n            errorType: 'errorType',\n            forwardLine: 'forwardLine',\n            instanceID: 'instanceID',\n            isColdStart: 'isColdStart',\n            requestID: 'requestID',\n            startTime: 'startTime',\n            timestamp: 'timestamp',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'number',\n            errorType: 'string',\n            forwardLine: 'number',\n            instanceID: 'string',\n            isColdStart: 'boolean',\n            requestID: 'string',\n            startTime: 'number',\n            timestamp: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetPerRequestLogsInput = GetPerRequestLogsInput;\nclass GetPerRequestLogsOutput extends $tea.Model {\n    static names() {\n        return {\n            data: 'data',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            data: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetPerRequestLogsOutput = GetPerRequestLogsOutput;\nclass GetQuotaOutput extends $tea.Model {\n    static names() {\n        return {\n            requestId: 'RequestId',\n            instanceLimit: 'instanceLimit',\n            instanceUsed: 'instanceUsed',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            instanceLimit: 'number',\n            instanceUsed: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetQuotaOutput = GetQuotaOutput;\nclass HTTPGetAction extends $tea.Model {\n    static names() {\n        return {\n            host: 'Host',\n            httpHeaders: 'HttpHeaders',\n            path: 'Path',\n            port: 'Port',\n            scheme: 'Scheme',\n        };\n    }\n    static types() {\n        return {\n            host: 'string',\n            httpHeaders: { 'type': 'array', 'itemType': HTTPHeader },\n            path: 'string',\n            port: 'number',\n            scheme: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.HTTPGetAction = HTTPGetAction;\nclass HTTPHeader extends $tea.Model {\n    static names() {\n        return {\n            name: 'name',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.HTTPHeader = HTTPHeader;\nclass HTTPTriggerConfig extends $tea.Model {\n    static names() {\n        return {\n            aclConfig: 'aclConfig',\n            authConfig: 'authConfig',\n            authType: 'authType',\n            disableURLInternet: 'disableURLInternet',\n            safeMode: 'safeMode',\n        };\n    }\n    static types() {\n        return {\n            aclConfig: AclConfig,\n            authConfig: 'any',\n            authType: 'string',\n            disableURLInternet: 'boolean',\n            safeMode: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.HTTPTriggerConfig = HTTPTriggerConfig;\nclass HostAlias extends $tea.Model {\n    static names() {\n        return {\n            hostnames: 'hostnames',\n            ip: 'ip',\n        };\n    }\n    static types() {\n        return {\n            hostnames: { 'type': 'array', 'itemType': 'string' },\n            ip: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.HostAlias = HostAlias;\nclass ImageConfig extends $tea.Model {\n    static names() {\n        return {\n            accelerationType: 'accelerationType',\n            image: 'image',\n            instanceID: 'instanceID',\n        };\n    }\n    static types() {\n        return {\n            accelerationType: 'string',\n            image: 'string',\n            instanceID: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ImageConfig = ImageConfig;\nclass InputCodeLocation extends $tea.Model {\n    static names() {\n        return {\n            ossBucketName: 'ossBucketName',\n            ossObjectName: 'ossObjectName',\n            zipFile: 'zipFile',\n        };\n    }\n    static types() {\n        return {\n            ossBucketName: 'string',\n            ossObjectName: 'string',\n            zipFile: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InputCodeLocation = InputCodeLocation;\nclass InstanceExecAuthorizationInput extends $tea.Model {\n    static names() {\n        return {\n            options: 'options',\n        };\n    }\n    static types() {\n        return {\n            options: InstanceExecAuthorizationInputOptions,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceExecAuthorizationInput = InstanceExecAuthorizationInput;\nclass InstanceExecAuthorizationInputOptions extends $tea.Model {\n    static names() {\n        return {\n            command: 'command',\n            stderr: 'stderr',\n            stdin: 'stdin',\n            stdout: 'stdout',\n            tty: 'tty',\n        };\n    }\n    static types() {\n        return {\n            command: { 'type': 'array', 'itemType': 'string' },\n            stderr: 'boolean',\n            stdin: 'boolean',\n            stdout: 'boolean',\n            tty: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceExecAuthorizationInputOptions = InstanceExecAuthorizationInputOptions;\nclass InstanceExecAuthorizationOutput extends $tea.Model {\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accountId: 'accountId',\n            authorization: 'authorization',\n            date: 'date',\n            endpoint: 'endpoint',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accountId: 'string',\n            authorization: 'string',\n            date: 'string',\n            endpoint: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceExecAuthorizationOutput = InstanceExecAuthorizationOutput;\nclass InstanceInfo extends $tea.Model {\n    static names() {\n        return {\n            imageUrl: 'imageUrl',\n            instanceId: 'instanceId',\n            status: 'status',\n            versionId: 'versionId',\n        };\n    }\n    static types() {\n        return {\n            imageUrl: 'string',\n            instanceId: 'string',\n            status: 'string',\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceInfo = InstanceInfo;\nclass InstanceLifecycleConfig extends $tea.Model {\n    static names() {\n        return {\n            preFreeze: 'preFreeze',\n            preStop: 'preStop',\n        };\n    }\n    static types() {\n        return {\n            preFreeze: LifecycleHook,\n            preStop: LifecycleHook,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceLifecycleConfig = InstanceLifecycleConfig;\nclass InstanceMetricInfo extends $tea.Model {\n    static names() {\n        return {\n            applicationID: 'applicationID',\n            cpuPercent: 'cpuPercent',\n            cpuQuotaPercent: 'cpuQuotaPercent',\n            instanceID: 'instanceID',\n            memoryLimitMB: 'memoryLimitMB',\n            memoryUsageMB: 'memoryUsageMB',\n            timestamp: 'timestamp',\n        };\n    }\n    static types() {\n        return {\n            applicationID: 'string',\n            cpuPercent: 'number',\n            cpuQuotaPercent: 'number',\n            instanceID: 'string',\n            memoryLimitMB: 'number',\n            memoryUsageMB: 'number',\n            timestamp: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.InstanceMetricInfo = InstanceMetricInfo;\nclass JaegerConfig extends $tea.Model {\n    static names() {\n        return {\n            endpoint: 'endpoint',\n        };\n    }\n    static types() {\n        return {\n            endpoint: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.JaegerConfig = JaegerConfig;\nclass LifecycleHook extends $tea.Model {\n    static names() {\n        return {\n            handler: 'handler',\n            timeout: 'timeout',\n        };\n    }\n    static types() {\n        return {\n            handler: 'string',\n            timeout: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.LifecycleHook = LifecycleHook;\nclass ListApplicationVersionsOutput extends $tea.Model {\n    static names() {\n        return {\n            direction: 'direction',\n            nextToken: 'nextToken',\n            requestId: 'requestId',\n            versions: 'versions',\n        };\n    }\n    static types() {\n        return {\n            direction: 'string',\n            nextToken: 'string',\n            requestId: 'string',\n            versions: { 'type': 'array', 'itemType': Version },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationVersionsOutput = ListApplicationVersionsOutput;\nclass ListApplicationsOutput extends $tea.Model {\n    static names() {\n        return {\n            applications: 'applications',\n            nextToken: 'nextToken',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            applications: { 'type': 'array', 'itemType': Application },\n            nextToken: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsOutput = ListApplicationsOutput;\nclass ListApplicationsWithStatusOutput extends $tea.Model {\n    static names() {\n        return {\n            applications: 'applications',\n            nextToken: 'nextToken',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            applications: { 'type': 'array', 'itemType': ApplicationWithStatus },\n            nextToken: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsWithStatusOutput = ListApplicationsWithStatusOutput;\nclass ListCustomDomainOutput extends $tea.Model {\n    static names() {\n        return {\n            customDomains: 'customDomains',\n            nextToken: 'nextToken',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            customDomains: { 'type': 'array', 'itemType': CustomDomain },\n            nextToken: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListCustomDomainOutput = ListCustomDomainOutput;\nclass ListInstancesMetricsOutput extends $tea.Model {\n    static names() {\n        return {\n            requestId: 'RequestId',\n            metricsList: 'metricsList',\n            pageNumber: 'pageNumber',\n            pageSize: 'pageSize',\n            totalCount: 'totalCount',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            metricsList: { 'type': 'array', 'itemType': InstanceMetricInfo },\n            pageNumber: 'number',\n            pageSize: 'number',\n            totalCount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListInstancesMetricsOutput = ListInstancesMetricsOutput;\nclass ListInstancesOutput extends $tea.Model {\n    static names() {\n        return {\n            currentError: 'currentError',\n            instances: 'instances',\n            requestId: 'requestId',\n            versionStatus: 'versionStatus',\n        };\n    }\n    static types() {\n        return {\n            currentError: 'string',\n            instances: { 'type': 'array', 'itemType': InstanceInfo },\n            requestId: 'string',\n            versionStatus: { 'type': 'map', 'keyType': 'string', 'valueType': VersionStatus },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListInstancesOutput = ListInstancesOutput;\nclass ListMetricsOutput extends $tea.Model {\n    static names() {\n        return {\n            requestId: 'RequestId',\n            metrics: 'metrics',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            metrics: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': MetricInfo } },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListMetricsOutput = ListMetricsOutput;\nclass ListStaticsQueryResponse extends $tea.Model {\n    static names() {\n        return {\n            length: 'length',\n            sort: 'sort',\n            statics: 'statics',\n        };\n    }\n    static types() {\n        return {\n            length: 'number',\n            sort: 'string',\n            statics: { 'type': 'array', 'itemType': StaticsInfo },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListStaticsQueryResponse = ListStaticsQueryResponse;\nclass ListWebApplicationInstancesBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: ListWebInstancesOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationInstancesBody = ListWebApplicationInstancesBody;\nclass ListWebApplicationRevisionsBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: ListWebApplicationRevisionsOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationRevisionsBody = ListWebApplicationRevisionsBody;\nclass ListWebApplicationRevisionsOutput extends $tea.Model {\n    static names() {\n        return {\n            nextToken: 'NextToken',\n            revisions: 'Revisions',\n        };\n    }\n    static types() {\n        return {\n            nextToken: 'string',\n            revisions: { 'type': 'array', 'itemType': Revision },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationRevisionsOutput = ListWebApplicationRevisionsOutput;\nclass ListWebApplicationsBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: ListWebApplicationsOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationsBody = ListWebApplicationsBody;\nclass ListWebApplicationsOutput extends $tea.Model {\n    static names() {\n        return {\n            nextToken: 'NextToken',\n            webApplicationWithInstanceCount: 'WebApplicationWithInstanceCount',\n        };\n    }\n    static types() {\n        return {\n            nextToken: 'string',\n            webApplicationWithInstanceCount: { 'type': 'array', 'itemType': WebApplicationWithInstanceCount },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationsOutput = ListWebApplicationsOutput;\nclass ListWebCustomDomainBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: ListWebCustomDomainOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebCustomDomainBody = ListWebCustomDomainBody;\nclass ListWebCustomDomainOutput extends $tea.Model {\n    static names() {\n        return {\n            nextToken: 'NextToken',\n            webCustomDomains: 'WebCustomDomains',\n        };\n    }\n    static types() {\n        return {\n            nextToken: 'string',\n            webCustomDomains: { 'type': 'array', 'itemType': WebCustomDomain },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebCustomDomainOutput = ListWebCustomDomainOutput;\nclass ListWebInstancesOutput extends $tea.Model {\n    static names() {\n        return {\n            currentError: 'CurrentError',\n            webInstances: 'WebInstances',\n            webVersionStatus: 'WebVersionStatus',\n        };\n    }\n    static types() {\n        return {\n            currentError: 'string',\n            webInstances: { 'type': 'array', 'itemType': WebInstanceInfo },\n            webVersionStatus: { 'type': 'map', 'keyType': 'string', 'valueType': WebVersionStatus },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebInstancesOutput = ListWebInstancesOutput;\nclass LogConfig extends $tea.Model {\n    static names() {\n        return {\n            enableInstanceMetrics: 'enableInstanceMetrics',\n            enableRequestMetrics: 'enableRequestMetrics',\n            logBeginRule: 'logBeginRule',\n            logstore: 'logstore',\n            project: 'project',\n            pushToUserSLS: 'pushToUserSLS',\n        };\n    }\n    static types() {\n        return {\n            enableInstanceMetrics: 'boolean',\n            enableRequestMetrics: 'boolean',\n            logBeginRule: 'string',\n            logstore: 'string',\n            project: 'string',\n            pushToUserSLS: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.LogConfig = LogConfig;\nclass LogEntry extends $tea.Model {\n    static names() {\n        return {\n            instanceID: 'instanceID',\n            message: 'message',\n            offset: 'offset',\n            packID: 'packID',\n            packMeta: 'packMeta',\n            qualifier: 'qualifier',\n            timestamp: 'timestamp',\n            versionID: 'versionID',\n        };\n    }\n    static types() {\n        return {\n            instanceID: 'string',\n            message: 'string',\n            offset: 'number',\n            packID: 'string',\n            packMeta: 'string',\n            qualifier: 'string',\n            timestamp: 'number',\n            versionID: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.LogEntry = LogEntry;\nclass MetricInfo extends $tea.Model {\n    static names() {\n        return {\n            average: 'Average',\n            count: 'Count',\n            maximum: 'Maximum',\n            minimum: 'Minimum',\n            sum: 'Sum',\n            timestamp: 'timestamp',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            average: 'number',\n            count: 'number',\n            maximum: 'number',\n            minimum: 'number',\n            sum: 'number',\n            timestamp: 'number',\n            value: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.MetricInfo = MetricInfo;\nclass MetricsCollectConfig extends $tea.Model {\n    static names() {\n        return {\n            enablePushToUserSLS: 'EnablePushToUserSLS',\n            logstoreName: 'LogstoreName',\n            projectName: 'ProjectName',\n        };\n    }\n    static types() {\n        return {\n            enablePushToUserSLS: 'boolean',\n            logstoreName: 'string',\n            projectName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.MetricsCollectConfig = MetricsCollectConfig;\nclass NASConfig extends $tea.Model {\n    static names() {\n        return {\n            mountPoints: 'mountPoints',\n        };\n    }\n    static types() {\n        return {\n            mountPoints: { 'type': 'array', 'itemType': NASMountConfig },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.NASConfig = NASConfig;\nclass NASMountConfig extends $tea.Model {\n    static names() {\n        return {\n            enableTLS: 'enableTLS',\n            mountDir: 'mountDir',\n            serverAddr: 'serverAddr',\n        };\n    }\n    static types() {\n        return {\n            enableTLS: 'boolean',\n            mountDir: 'string',\n            serverAddr: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.NASMountConfig = NASMountConfig;\nclass OSSMountConfig extends $tea.Model {\n    static names() {\n        return {\n            mountPoints: 'mountPoints',\n        };\n    }\n    static types() {\n        return {\n            mountPoints: { 'type': 'array', 'itemType': OSSMountPoint },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.OSSMountConfig = OSSMountConfig;\nclass OSSMountPoint extends $tea.Model {\n    static names() {\n        return {\n            bucketName: 'bucketName',\n            bucketPath: 'bucketPath',\n            mountDir: 'mountDir',\n            readOnly: 'readOnly',\n        };\n    }\n    static types() {\n        return {\n            bucketName: 'string',\n            bucketPath: 'string',\n            mountDir: 'string',\n            readOnly: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.OSSMountPoint = OSSMountPoint;\nclass PathConfig extends $tea.Model {\n    static names() {\n        return {\n            applicationName: 'applicationName',\n            path: 'path',\n        };\n    }\n    static types() {\n        return {\n            applicationName: 'string',\n            path: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PathConfig = PathConfig;\nclass PermissionAssistantApi extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'createTime',\n            id: 'id',\n            name: 'name',\n            resourceType: 'resourceType',\n            updateTime: 'updateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'string',\n            id: 'number',\n            name: 'string',\n            resourceType: 'string',\n            updateTime: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PermissionAssistantApi = PermissionAssistantApi;\nclass PolicyItem extends $tea.Model {\n    static names() {\n        return {\n            key: 'key',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PolicyItem = PolicyItem;\nclass PriceEstimateFeature extends $tea.Model {\n    static names() {\n        return {\n            appType: 'AppType',\n            cpuCore: 'CpuCore',\n            cpuStrategy: 'CpuStrategy',\n            envType: 'EnvType',\n            highLoadInstanceCount: 'HighLoadInstanceCount',\n            highLoadQps: 'HighLoadQps',\n            highLoadSeconds: 'HighLoadSeconds',\n            instanceQps: 'InstanceQps',\n            internetOutboundGiB: 'InternetOutboundGiB',\n            lowLoadInstanceCount: 'LowLoadInstanceCount',\n            lowLoadQps: 'LowLoadQps',\n            lowLoadSeconds: 'LowLoadSeconds',\n            maxInstanceCount: 'MaxInstanceCount',\n            memoryGiB: 'MemoryGiB',\n            minInstanceCount: 'MinInstanceCount',\n            noneLoadInstanceCount: 'NoneLoadInstanceCount',\n            noneLoadSeconds: 'NoneLoadSeconds',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            appType: 'string',\n            cpuCore: 'number',\n            cpuStrategy: 'string',\n            envType: 'string',\n            highLoadInstanceCount: 'number',\n            highLoadQps: 'number',\n            highLoadSeconds: 'number',\n            instanceQps: 'number',\n            internetOutboundGiB: 'number',\n            lowLoadInstanceCount: 'number',\n            lowLoadQps: 'number',\n            lowLoadSeconds: 'number',\n            maxInstanceCount: 'number',\n            memoryGiB: 'number',\n            minInstanceCount: 'number',\n            noneLoadInstanceCount: 'number',\n            noneLoadSeconds: 'number',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateFeature = PriceEstimateFeature;\nclass PriceEstimateOutput extends $tea.Model {\n    static names() {\n        return {\n            apps: 'Apps',\n            items: 'Items',\n            totalPrice: 'TotalPrice',\n        };\n    }\n    static types() {\n        return {\n            apps: { 'type': 'array', 'itemType': PriceEstimateOutputApps },\n            items: { 'type': 'array', 'itemType': PriceEstimateOutputItems },\n            totalPrice: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateOutput = PriceEstimateOutput;\nclass Probe extends $tea.Model {\n    static names() {\n        return {\n            failureThreshold: 'failureThreshold',\n            initialDelaySeconds: 'initialDelaySeconds',\n            periodSeconds: 'periodSeconds',\n            probeHandler: 'probeHandler',\n            timeoutSeconds: 'timeoutSeconds',\n        };\n    }\n    static types() {\n        return {\n            failureThreshold: 'number',\n            initialDelaySeconds: 'number',\n            periodSeconds: 'number',\n            probeHandler: ProbeProbeHandler,\n            timeoutSeconds: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Probe = Probe;\nclass ProbeHandler extends $tea.Model {\n    static names() {\n        return {\n            httpGet: 'HttpGet',\n            tcpSocket: 'TcpSocket',\n        };\n    }\n    static types() {\n        return {\n            httpGet: HTTPGetAction,\n            tcpSocket: TCPSocketAction,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ProbeHandler = ProbeHandler;\nclass PublishApplicationVersionInput extends $tea.Model {\n    static names() {\n        return {\n            description: 'description',\n        };\n    }\n    static types() {\n        return {\n            description: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PublishApplicationVersionInput = PublishApplicationVersionInput;\nclass PublishWebApplicationRevisionInput extends $tea.Model {\n    static names() {\n        return {\n            containers: 'Containers',\n            description: 'Description',\n            enableArmsMetrics: 'EnableArmsMetrics',\n            takeEffect: 'TakeEffect',\n        };\n    }\n    static types() {\n        return {\n            containers: { 'type': 'array', 'itemType': Container },\n            description: 'string',\n            enableArmsMetrics: 'boolean',\n            takeEffect: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PublishWebApplicationRevisionInput = PublishWebApplicationRevisionInput;\nclass Revision extends $tea.Model {\n    static names() {\n        return {\n            createdTime: 'CreatedTime',\n            description: 'Description',\n            revisionConfig: 'RevisionConfig',\n            revisionId: 'RevisionId',\n            weight: 'Weight',\n        };\n    }\n    static types() {\n        return {\n            createdTime: 'string',\n            description: 'string',\n            revisionConfig: RevisionConfig,\n            revisionId: 'string',\n            weight: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Revision = Revision;\nclass RevisionConfig extends $tea.Model {\n    static names() {\n        return {\n            containers: 'Containers',\n            enableArmsMetrics: 'EnableArmsMetrics',\n            webNetworkConfig: 'WebNetworkConfig',\n        };\n    }\n    static types() {\n        return {\n            containers: { 'type': 'array', 'itemType': Container },\n            enableArmsMetrics: 'boolean',\n            webNetworkConfig: WebNetworkConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RevisionConfig = RevisionConfig;\nclass RouteConfig extends $tea.Model {\n    static names() {\n        return {\n            routes: 'routes',\n        };\n    }\n    static types() {\n        return {\n            routes: { 'type': 'array', 'itemType': PathConfig },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RouteConfig = RouteConfig;\nclass RoutePolicy extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            policyItems: 'policyItems',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            policyItems: { 'type': 'array', 'itemType': PolicyItem },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RoutePolicy = RoutePolicy;\nclass SLSCollectConfig extends $tea.Model {\n    static names() {\n        return {\n            logPath: 'LogPath',\n            logType: 'LogType',\n            logstoreName: 'LogstoreName',\n            logtailName: 'LogtailName',\n            machineGroup: 'MachineGroup',\n            projectName: 'ProjectName',\n        };\n    }\n    static types() {\n        return {\n            logPath: 'string',\n            logType: 'string',\n            logstoreName: 'string',\n            logtailName: 'string',\n            machineGroup: 'string',\n            projectName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SLSCollectConfig = SLSCollectConfig;\nclass SLSCollectConfigs extends $tea.Model {\n    static names() {\n        return {\n            collectConfigs: 'CollectConfigs',\n        };\n    }\n    static types() {\n        return {\n            collectConfigs: { 'type': 'array', 'itemType': SLSCollectConfig },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SLSCollectConfigs = SLSCollectConfigs;\nclass SLSConfig extends $tea.Model {\n    static names() {\n        return {\n            collectConfigs: 'collectConfigs',\n        };\n    }\n    static types() {\n        return {\n            collectConfigs: { 'type': 'array', 'itemType': SLSConfigCollectConfigs },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SLSConfig = SLSConfig;\nclass ScaleConfig extends $tea.Model {\n    static names() {\n        return {\n            alwaysAllocateCPU: 'alwaysAllocateCPU',\n            maximumInstanceCount: 'maximumInstanceCount',\n            minimumInstanceCount: 'minimumInstanceCount',\n            requestId: 'requestId',\n        };\n    }\n    static types() {\n        return {\n            alwaysAllocateCPU: 'boolean',\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ScaleConfig = ScaleConfig;\nclass SourceCodeAccount extends $tea.Model {\n    static names() {\n        return {\n            avatarUrl: 'AvatarUrl',\n            id: 'Id',\n            name: 'Name',\n            organizations: 'Organizations',\n        };\n    }\n    static types() {\n        return {\n            avatarUrl: 'string',\n            id: 'string',\n            name: 'string',\n            organizations: { 'type': 'array', 'itemType': SourceCodeAccountOrganizations },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SourceCodeAccount = SourceCodeAccount;\nclass SourceCodeRepo extends $tea.Model {\n    static names() {\n        return {\n            fullName: 'FullName',\n            id: 'Id',\n            name: 'Name',\n        };\n    }\n    static types() {\n        return {\n            fullName: 'string',\n            id: 'string',\n            name: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SourceCodeRepo = SourceCodeRepo;\nclass SourceCodeRepoBranch extends $tea.Model {\n    static names() {\n        return {\n            commitId: 'CommitId',\n            name: 'Name',\n        };\n    }\n    static types() {\n        return {\n            commitId: 'string',\n            name: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SourceCodeRepoBranch = SourceCodeRepoBranch;\nclass StartupProbe extends $tea.Model {\n    static names() {\n        return {\n            failureThreshold: 'FailureThreshold',\n            initialDelaySeconds: 'InitialDelaySeconds',\n            periodSeconds: 'PeriodSeconds',\n            probeHandler: 'ProbeHandler',\n            timeoutSeconds: 'TimeoutSeconds',\n        };\n    }\n    static types() {\n        return {\n            failureThreshold: 'number',\n            initialDelaySeconds: 'number',\n            periodSeconds: 'number',\n            probeHandler: ProbeHandler,\n            timeoutSeconds: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartupProbe = StartupProbe;\nclass StaticsInfo extends $tea.Model {\n    static names() {\n        return {\n            activeCPUUsage: 'activeCPUUsage',\n            cost: 'cost',\n            diskUsage: 'diskUsage',\n            functionName: 'functionName',\n            gpuUsage: 'gpuUsage',\n            idleCPUUsage: 'idleCPUUsage',\n            instanceTrafficOut: 'instanceTrafficOut',\n            invocations: 'invocations',\n            invokeCDNOut: 'invokeCDNOut',\n            invokeInternetOut: 'invokeInternetOut',\n            memoryUsage: 'memoryUsage',\n            region: 'region',\n            serviceName: 'serviceName',\n        };\n    }\n    static types() {\n        return {\n            activeCPUUsage: 'number',\n            cost: 'number',\n            diskUsage: 'number',\n            functionName: 'string',\n            gpuUsage: 'number',\n            idleCPUUsage: 'number',\n            instanceTrafficOut: 'number',\n            invocations: 'number',\n            invokeCDNOut: 'number',\n            invokeInternetOut: 'number',\n            memoryUsage: 'number',\n            region: 'string',\n            serviceName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StaticsInfo = StaticsInfo;\nclass Submenu extends $tea.Model {\n    static names() {\n        return {\n            items: 'Items',\n            submenuDesc: 'SubmenuDesc',\n            submenuType: 'SubmenuType',\n            submenus: 'Submenus',\n        };\n    }\n    static types() {\n        return {\n            items: { 'type': 'array', 'itemType': SubmenuItems },\n            submenuDesc: 'string',\n            submenuType: 'string',\n            submenus: { 'type': 'array', 'itemType': Submenu },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Submenu = Submenu;\nclass TCPSocketAction extends $tea.Model {\n    static names() {\n        return {\n            host: 'Host',\n            port: 'Port',\n        };\n    }\n    static types() {\n        return {\n            host: 'string',\n            port: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TCPSocketAction = TCPSocketAction;\nclass TLSConfig extends $tea.Model {\n    static names() {\n        return {\n            cipherSuites: 'cipherSuites',\n            maxVersion: 'maxVersion',\n            minVersion: 'minVersion',\n        };\n    }\n    static types() {\n        return {\n            cipherSuites: { 'type': 'array', 'itemType': 'string' },\n            maxVersion: 'string',\n            minVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TLSConfig = TLSConfig;\nclass TomcatConfig extends $tea.Model {\n    static names() {\n        return {\n            contextPath: 'ContextPath',\n            maxThreads: 'MaxThreads',\n            port: 'Port',\n            uriEncoding: 'UriEncoding',\n            useBodyEncodingForUri: 'UseBodyEncodingForUri',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            contextPath: 'string',\n            maxThreads: 'number',\n            port: 'number',\n            uriEncoding: 'string',\n            useBodyEncodingForUri: 'boolean',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TomcatConfig = TomcatConfig;\nclass TracingConfig extends $tea.Model {\n    static names() {\n        return {\n            jaegerConfig: 'jaegerConfig',\n            params: 'params',\n            type: 'type',\n        };\n    }\n    static types() {\n        return {\n            jaegerConfig: JaegerConfig,\n            params: 'any',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TracingConfig = TracingConfig;\nclass TrafficConfig extends $tea.Model {\n    static names() {\n        return {\n            additionalVersionWeight: 'additionalVersionWeight',\n            createdTime: 'createdTime',\n            lastModifiedTime: 'lastModifiedTime',\n            requestId: 'requestId',\n            resolvePolicy: 'resolvePolicy',\n            routePolicy: 'routePolicy',\n            versionId: 'versionId',\n        };\n    }\n    static types() {\n        return {\n            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },\n            createdTime: 'string',\n            lastModifiedTime: 'string',\n            requestId: 'string',\n            resolvePolicy: 'string',\n            routePolicy: RoutePolicy,\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TrafficConfig = TrafficConfig;\nclass UpdateApplicationInput extends $tea.Model {\n    static names() {\n        return {\n            args: 'args',\n            caPort: 'caPort',\n            code: 'code',\n            command: 'command',\n            cpu: 'cpu',\n            customDNS: 'customDNS',\n            customHealthCheckConfig: 'customHealthCheckConfig',\n            customHostAlias: 'customHostAlias',\n            customRuntimeConfig: 'customRuntimeConfig',\n            description: 'description',\n            diskSize: 'diskSize',\n            effectiveImmediately: 'effectiveImmediately',\n            enableAppMetric: 'enableAppMetric',\n            environmentVariables: 'environmentVariables',\n            gpuMemorySize: 'gpuMemorySize',\n            handler: 'handler',\n            httpTriggerConfig: 'httpTriggerConfig',\n            imageConfig: 'imageConfig',\n            initializationTimeout: 'initializationTimeout',\n            initializer: 'initializer',\n            instanceConcurrency: 'instanceConcurrency',\n            instanceLifecycleConfig: 'instanceLifecycleConfig',\n            instanceSoftConcurrency: 'instanceSoftConcurrency',\n            instanceType: 'instanceType',\n            internetAccess: 'internetAccess',\n            layers: 'layers',\n            livenessProbe: 'livenessProbe',\n            logConfig: 'logConfig',\n            memorySize: 'memorySize',\n            nasConfig: 'nasConfig',\n            ossMountConfig: 'ossMountConfig',\n            runtime: 'runtime',\n            scaleConfig: 'scaleConfig',\n            slsConfig: 'slsConfig',\n            startupProbe: 'startupProbe',\n            timeout: 'timeout',\n            tracingConfig: 'tracingConfig',\n            vpcConfig: 'vpcConfig',\n        };\n    }\n    static types() {\n        return {\n            args: 'string',\n            caPort: 'number',\n            code: InputCodeLocation,\n            command: 'string',\n            cpu: 'number',\n            customDNS: CustomDNS,\n            customHealthCheckConfig: CustomHealthCheckConfig,\n            customHostAlias: CustomHostAlias,\n            customRuntimeConfig: CustomRuntimeConfig,\n            description: 'string',\n            diskSize: 'number',\n            effectiveImmediately: 'boolean',\n            enableAppMetric: 'boolean',\n            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            gpuMemorySize: 'number',\n            handler: 'string',\n            httpTriggerConfig: HTTPTriggerConfig,\n            imageConfig: ImageConfig,\n            initializationTimeout: 'number',\n            initializer: 'string',\n            instanceConcurrency: 'number',\n            instanceLifecycleConfig: InstanceLifecycleConfig,\n            instanceSoftConcurrency: 'number',\n            instanceType: 'string',\n            internetAccess: 'boolean',\n            layers: { 'type': 'array', 'itemType': 'string' },\n            livenessProbe: Probe,\n            logConfig: LogConfig,\n            memorySize: 'number',\n            nasConfig: NASConfig,\n            ossMountConfig: OSSMountConfig,\n            runtime: 'string',\n            scaleConfig: ScaleConfig,\n            slsConfig: SLSConfig,\n            startupProbe: Probe,\n            timeout: 'number',\n            tracingConfig: TracingConfig,\n            vpcConfig: VPCConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationInput = UpdateApplicationInput;\nclass UpdateApplicationScaleConfigInput extends $tea.Model {\n    static names() {\n        return {\n            alwaysAllocateCPU: 'alwaysAllocateCPU',\n            maximumInstanceCount: 'maximumInstanceCount',\n            minimumInstanceCount: 'minimumInstanceCount',\n        };\n    }\n    static types() {\n        return {\n            alwaysAllocateCPU: 'boolean',\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScaleConfigInput = UpdateApplicationScaleConfigInput;\nclass UpdateApplicationTrafficConfigInput extends $tea.Model {\n    static names() {\n        return {\n            additionalVersionWeight: 'additionalVersionWeight',\n            resolvePolicy: 'resolvePolicy',\n            routePolicy: 'routePolicy',\n            versionId: 'versionId',\n        };\n    }\n    static types() {\n        return {\n            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },\n            resolvePolicy: 'string',\n            routePolicy: RoutePolicy,\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationTrafficConfigInput = UpdateApplicationTrafficConfigInput;\nclass UpdateAttributesInput extends $tea.Model {\n    static names() {\n        return {\n            description: 'description',\n            httpTriggerConfig: 'httpTriggerConfig',\n            versionID: 'versionID',\n        };\n    }\n    static types() {\n        return {\n            description: 'string',\n            httpTriggerConfig: HTTPTriggerConfig,\n            versionID: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateAttributesInput = UpdateAttributesInput;\nclass UpdateCustomDomainInput extends $tea.Model {\n    static names() {\n        return {\n            applicationID: 'applicationID',\n            applicationName: 'applicationName',\n            certConfig: 'certConfig',\n            keepFullPath: 'keepFullPath',\n            namespaceID: 'namespaceID',\n            protocol: 'protocol',\n            tlsConfig: 'tlsConfig',\n            wafConfig: 'wafConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationID: 'string',\n            applicationName: 'string',\n            certConfig: CertConfig,\n            keepFullPath: 'boolean',\n            namespaceID: 'string',\n            protocol: 'string',\n            tlsConfig: TLSConfig,\n            wafConfig: WAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateCustomDomainInput = UpdateCustomDomainInput;\nclass UpdateWebApplicationInput extends $tea.Model {\n    static names() {\n        return {\n            description: 'Description',\n            webNetworkConfig: 'WebNetworkConfig',\n        };\n    }\n    static types() {\n        return {\n            description: 'string',\n            webNetworkConfig: WebNetworkConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationInput = UpdateWebApplicationInput;\nclass UpdateWebApplicationScalingConfigInput extends $tea.Model {\n    static names() {\n        return {\n            maximumInstanceCount: 'MaximumInstanceCount',\n            minimumInstanceCount: 'MinimumInstanceCount',\n        };\n    }\n    static types() {\n        return {\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationScalingConfigInput = UpdateWebApplicationScalingConfigInput;\nclass UpdateWebApplicationTrafficConfigInput extends $tea.Model {\n    static names() {\n        return {\n            authType: 'AuthType',\n            disableURLInternet: 'DisableURLInternet',\n            revisionsTrafficWeight: 'RevisionsTrafficWeight',\n            webAclConfig: 'WebAclConfig',\n        };\n    }\n    static types() {\n        return {\n            authType: 'string',\n            disableURLInternet: 'boolean',\n            revisionsTrafficWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },\n            webAclConfig: WebAclConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationTrafficConfigInput = UpdateWebApplicationTrafficConfigInput;\nclass UpdateWebCustomDomainInput extends $tea.Model {\n    static names() {\n        return {\n            defaultForwardingAppName: 'DefaultForwardingAppName',\n            protocol: 'Protocol',\n            webCertConfig: 'WebCertConfig',\n            webTLSConfig: 'WebTLSConfig',\n            webWAFConfig: 'WebWAFConfig',\n        };\n    }\n    static types() {\n        return {\n            defaultForwardingAppName: 'string',\n            protocol: 'string',\n            webCertConfig: WebCertConfig,\n            webTLSConfig: WebTLSConfig,\n            webWAFConfig: WebWAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebCustomDomainInput = UpdateWebCustomDomainInput;\nclass VPCConfig extends $tea.Model {\n    static names() {\n        return {\n            anytunnelViaENI: 'anytunnelViaENI',\n            role: 'role',\n            securityGroupId: 'securityGroupId',\n            vSwitchIds: 'vSwitchIds',\n            vpcId: 'vpcId',\n        };\n    }\n    static types() {\n        return {\n            anytunnelViaENI: 'boolean',\n            role: 'string',\n            securityGroupId: 'string',\n            vSwitchIds: { 'type': 'array', 'itemType': 'string' },\n            vpcId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.VPCConfig = VPCConfig;\nclass Version extends $tea.Model {\n    static names() {\n        return {\n            createdTime: 'createdTime',\n            description: 'description',\n            image: 'image',\n            lastModifiedTime: 'lastModifiedTime',\n            requestId: 'requestId',\n            versionId: 'versionId',\n            weight: 'weight',\n        };\n    }\n    static types() {\n        return {\n            createdTime: 'string',\n            description: 'string',\n            image: 'string',\n            lastModifiedTime: 'string',\n            requestId: 'string',\n            versionId: 'string',\n            weight: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.Version = Version;\nclass VersionStatus extends $tea.Model {\n    static names() {\n        return {\n            errorMessage: 'errorMessage',\n            status: 'status',\n        };\n    }\n    static types() {\n        return {\n            errorMessage: 'string',\n            status: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.VersionStatus = VersionStatus;\nclass WAFConfig extends $tea.Model {\n    static names() {\n        return {\n            enableWAF: 'enableWAF',\n        };\n    }\n    static types() {\n        return {\n            enableWAF: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WAFConfig = WAFConfig;\nclass WebAclConfig extends $tea.Model {\n    static names() {\n        return {\n            webAclEntries: 'WebAclEntries',\n        };\n    }\n    static types() {\n        return {\n            webAclEntries: { 'type': 'array', 'itemType': WebAclEntryConfig },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebAclConfig = WebAclConfig;\nclass WebAclEntryConfig extends $tea.Model {\n    static names() {\n        return {\n            entry: 'Entry',\n        };\n    }\n    static types() {\n        return {\n            entry: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebAclEntryConfig = WebAclEntryConfig;\nclass WebApplication extends $tea.Model {\n    static names() {\n        return {\n            applicationId: 'ApplicationId',\n            applicationName: 'ApplicationName',\n            createdTime: 'CreatedTime',\n            description: 'Description',\n            internetURL: 'InternetURL',\n            intranetURL: 'IntranetURL',\n            lastModifiedTime: 'LastModifiedTime',\n            namespaceId: 'NamespaceId',\n            revisionConfig: 'RevisionConfig',\n            vpcId: 'VpcId',\n            webScalingConfig: 'WebScalingConfig',\n            webTrafficConfig: 'WebTrafficConfig',\n        };\n    }\n    static types() {\n        return {\n            applicationId: 'string',\n            applicationName: 'string',\n            createdTime: 'string',\n            description: 'string',\n            internetURL: 'string',\n            intranetURL: 'string',\n            lastModifiedTime: 'string',\n            namespaceId: 'string',\n            revisionConfig: RevisionConfig,\n            vpcId: 'string',\n            webScalingConfig: WebScalingConfig,\n            webTrafficConfig: WebTrafficConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplication = WebApplication;\nclass WebApplicationBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: WebApplication,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationBody = WebApplicationBody;\nclass WebApplicationInstanceLogsBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: DescribeInstanceLogsOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationInstanceLogsBody = WebApplicationInstanceLogsBody;\nclass WebApplicationResourceStaticsBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: DescribeWebAppStaticsOutput,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationResourceStaticsBody = WebApplicationResourceStaticsBody;\nclass WebApplicationRevisionBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: Revision,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationRevisionBody = WebApplicationRevisionBody;\nclass WebApplicationScalingConfigBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: WebScalingConfig,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationScalingConfigBody = WebApplicationScalingConfigBody;\nclass WebApplicationStatus extends $tea.Model {\n    static names() {\n        return {\n            instanceCount: 'InstanceCount',\n            webScalingConfig: 'WebScalingConfig',\n        };\n    }\n    static types() {\n        return {\n            instanceCount: 'number',\n            webScalingConfig: WebScalingConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationStatus = WebApplicationStatus;\nclass WebApplicationTrafficConfigBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: WebTrafficConfig,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationTrafficConfigBody = WebApplicationTrafficConfigBody;\nclass WebApplicationWithInstanceCount extends $tea.Model {\n    static names() {\n        return {\n            instanceCount: 'InstanceCount',\n            webApplication: 'WebApplication',\n        };\n    }\n    static types() {\n        return {\n            instanceCount: 'number',\n            webApplication: WebApplication,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationWithInstanceCount = WebApplicationWithInstanceCount;\nclass WebApplicationWithStatus extends $tea.Model {\n    static names() {\n        return {\n            status: 'Status',\n            webApplication: 'WebApplication',\n        };\n    }\n    static types() {\n        return {\n            status: WebApplicationStatus,\n            webApplication: WebApplication,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebApplicationWithStatus = WebApplicationWithStatus;\nclass WebCertConfig extends $tea.Model {\n    static names() {\n        return {\n            certName: 'CertName',\n            certificate: 'Certificate',\n            privateKey: 'PrivateKey',\n        };\n    }\n    static types() {\n        return {\n            certName: 'string',\n            certificate: 'string',\n            privateKey: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebCertConfig = WebCertConfig;\nclass WebCustomDomain extends $tea.Model {\n    static names() {\n        return {\n            accountId: 'AccountId',\n            createdTime: 'CreatedTime',\n            defaultForwardingAppName: 'DefaultForwardingAppName',\n            domainName: 'DomainName',\n            lastModifiedTime: 'LastModifiedTime',\n            namespaceId: 'NamespaceId',\n            protocol: 'Protocol',\n            webCertConfig: 'WebCertConfig',\n            webTLSConfig: 'WebTLSConfig',\n            webWAFConfig: 'WebWAFConfig',\n        };\n    }\n    static types() {\n        return {\n            accountId: 'string',\n            createdTime: 'string',\n            defaultForwardingAppName: 'string',\n            domainName: 'string',\n            lastModifiedTime: 'string',\n            namespaceId: 'string',\n            protocol: 'string',\n            webCertConfig: WebCertConfig,\n            webTLSConfig: WebTLSConfig,\n            webWAFConfig: WebWAFConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebCustomDomain = WebCustomDomain;\nclass WebCustomDomainBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            data: WebCustomDomain,\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebCustomDomainBody = WebCustomDomainBody;\nclass WebInstanceInfo extends $tea.Model {\n    static names() {\n        return {\n            imageUrl: 'ImageUrl',\n            instanceId: 'InstanceId',\n            status: 'Status',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            imageUrl: 'string',\n            instanceId: 'string',\n            status: 'string',\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebInstanceInfo = WebInstanceInfo;\nclass WebLogEntry extends $tea.Model {\n    static names() {\n        return {\n            message: 'Message',\n        };\n    }\n    static types() {\n        return {\n            message: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebLogEntry = WebLogEntry;\nclass WebNASConfig extends $tea.Model {\n    static names() {\n        return {\n            mountPoints: 'MountPoints',\n        };\n    }\n    static types() {\n        return {\n            mountPoints: { 'type': 'array', 'itemType': WebNASMountPoint },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebNASConfig = WebNASConfig;\nclass WebNASMountPoint extends $tea.Model {\n    static names() {\n        return {\n            mountDir: 'MountDir',\n            nasAddr: 'NasAddr',\n            nasPath: 'NasPath',\n        };\n    }\n    static types() {\n        return {\n            mountDir: 'string',\n            nasAddr: 'string',\n            nasPath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebNASMountPoint = WebNASMountPoint;\nclass WebNetworkConfig extends $tea.Model {\n    static names() {\n        return {\n            internetAccess: 'InternetAccess',\n            securityGroupId: 'SecurityGroupId',\n            vSwitchIds: 'VSwitchIds',\n        };\n    }\n    static types() {\n        return {\n            internetAccess: 'boolean',\n            securityGroupId: 'string',\n            vSwitchIds: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebNetworkConfig = WebNetworkConfig;\nclass WebOSSConfig extends $tea.Model {\n    static names() {\n        return {\n            mountPoints: 'MountPoints',\n        };\n    }\n    static types() {\n        return {\n            mountPoints: { 'type': 'array', 'itemType': WebOSSMountPoint },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebOSSConfig = WebOSSConfig;\nclass WebOSSMountPoint extends $tea.Model {\n    static names() {\n        return {\n            bucketName: 'BucketName',\n            bucketPath: 'BucketPath',\n            mountDir: 'MountDir',\n            readOnly: 'ReadOnly',\n        };\n    }\n    static types() {\n        return {\n            bucketName: 'string',\n            bucketPath: 'string',\n            mountDir: 'string',\n            readOnly: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebOSSMountPoint = WebOSSMountPoint;\nclass WebScalingConfig extends $tea.Model {\n    static names() {\n        return {\n            maximumInstanceCount: 'MaximumInstanceCount',\n            minimumInstanceCount: 'MinimumInstanceCount',\n        };\n    }\n    static types() {\n        return {\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebScalingConfig = WebScalingConfig;\nclass WebStaticsInfo extends $tea.Model {\n    static names() {\n        return {\n            cpuUsage: 'CpuUsage',\n            internetTrafficOut: 'InternetTrafficOut',\n            invocations: 'Invocations',\n            memoryUsage: 'MemoryUsage',\n        };\n    }\n    static types() {\n        return {\n            cpuUsage: 'number',\n            internetTrafficOut: 'number',\n            invocations: 'number',\n            memoryUsage: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebStaticsInfo = WebStaticsInfo;\nclass WebTLSConfig extends $tea.Model {\n    static names() {\n        return {\n            cipherSuites: 'CipherSuites',\n            maxVersion: 'MaxVersion',\n            minVersion: 'MinVersion',\n        };\n    }\n    static types() {\n        return {\n            cipherSuites: { 'type': 'array', 'itemType': 'string' },\n            maxVersion: 'string',\n            minVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebTLSConfig = WebTLSConfig;\nclass WebTrafficConfig extends $tea.Model {\n    static names() {\n        return {\n            authType: 'AuthType',\n            disableInternetURL: 'DisableInternetURL',\n            revisionsTrafficWeight: 'RevisionsTrafficWeight',\n            webAclConfig: 'WebAclConfig',\n        };\n    }\n    static types() {\n        return {\n            authType: 'string',\n            disableInternetURL: 'boolean',\n            revisionsTrafficWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },\n            webAclConfig: WebAclConfig,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebTrafficConfig = WebTrafficConfig;\nclass WebVersionStatus extends $tea.Model {\n    static names() {\n        return {\n            errorMessage: 'ErrorMessage',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            errorMessage: 'string',\n            status: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebVersionStatus = WebVersionStatus;\nclass WebWAFConfig extends $tea.Model {\n    static names() {\n        return {\n            enableWAF: 'EnableWAF',\n        };\n    }\n    static types() {\n        return {\n            enableWAF: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.WebWAFConfig = WebWAFConfig;\nclass AbortAndRollbackChangeOrderRequest extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortAndRollbackChangeOrderRequest = AbortAndRollbackChangeOrderRequest;\nclass AbortAndRollbackChangeOrderResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: AbortAndRollbackChangeOrderResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortAndRollbackChangeOrderResponseBody = AbortAndRollbackChangeOrderResponseBody;\nclass AbortAndRollbackChangeOrderResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: AbortAndRollbackChangeOrderResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortAndRollbackChangeOrderResponse = AbortAndRollbackChangeOrderResponse;\nclass AbortChangeOrderRequest extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortChangeOrderRequest = AbortChangeOrderRequest;\nclass AbortChangeOrderResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: AbortChangeOrderResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortChangeOrderResponseBody = AbortChangeOrderResponseBody;\nclass AbortChangeOrderResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: AbortChangeOrderResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortChangeOrderResponse = AbortChangeOrderResponse;\nclass BatchStartApplicationsRequest extends $tea.Model {\n    static names() {\n        return {\n            appIds: 'AppIds',\n            namespaceId: 'NamespaceId',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            appIds: 'string',\n            namespaceId: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStartApplicationsRequest = BatchStartApplicationsRequest;\nclass BatchStartApplicationsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: BatchStartApplicationsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStartApplicationsResponseBody = BatchStartApplicationsResponseBody;\nclass BatchStartApplicationsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchStartApplicationsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStartApplicationsResponse = BatchStartApplicationsResponse;\nclass BatchStopApplicationsRequest extends $tea.Model {\n    static names() {\n        return {\n            appIds: 'AppIds',\n            namespaceId: 'NamespaceId',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            appIds: 'string',\n            namespaceId: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStopApplicationsRequest = BatchStopApplicationsRequest;\nclass BatchStopApplicationsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: BatchStopApplicationsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStopApplicationsResponseBody = BatchStopApplicationsResponseBody;\nclass BatchStopApplicationsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchStopApplicationsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStopApplicationsResponse = BatchStopApplicationsResponse;\nclass BindSlbRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            internet: 'Internet',\n            internetSlbChargeType: 'InternetSlbChargeType',\n            internetSlbId: 'InternetSlbId',\n            intranet: 'Intranet',\n            intranetSlbChargeType: 'IntranetSlbChargeType',\n            intranetSlbId: 'IntranetSlbId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            internet: 'string',\n            internetSlbChargeType: 'string',\n            internetSlbId: 'string',\n            intranet: 'string',\n            intranetSlbChargeType: 'string',\n            intranetSlbId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BindSlbRequest = BindSlbRequest;\nclass BindSlbResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: BindSlbResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BindSlbResponseBody = BindSlbResponseBody;\nclass BindSlbResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BindSlbResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BindSlbResponse = BindSlbResponse;\nclass ConfirmPipelineBatchRequest extends $tea.Model {\n    static names() {\n        return {\n            confirm: 'Confirm',\n            pipelineId: 'PipelineId',\n        };\n    }\n    static types() {\n        return {\n            confirm: 'boolean',\n            pipelineId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ConfirmPipelineBatchRequest = ConfirmPipelineBatchRequest;\nclass ConfirmPipelineBatchResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ConfirmPipelineBatchResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ConfirmPipelineBatchResponseBody = ConfirmPipelineBatchResponseBody;\nclass ConfirmPipelineBatchResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ConfirmPipelineBatchResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ConfirmPipelineBatchResponse = ConfirmPipelineBatchResponse;\nclass CreateApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appDescription: 'AppDescription',\n            appName: 'AppName',\n            appSource: 'AppSource',\n            associateEip: 'AssociateEip',\n            autoConfig: 'AutoConfig',\n            baseAppId: 'BaseAppId',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            cpu: 'Cpu',\n            customHostAlias: 'CustomHostAlias',\n            deploy: 'Deploy',\n            edasContainerVersion: 'EdasContainerVersion',\n            enableEbpf: 'EnableEbpf',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            kafkaConfigs: 'KafkaConfigs',\n            liveness: 'Liveness',\n            memory: 'Memory',\n            microRegistration: 'MicroRegistration',\n            microRegistrationConfig: 'MicroRegistrationConfig',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            namespaceId: 'NamespaceId',\n            nasConfigs: 'NasConfigs',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            php: 'Php',\n            phpArmsConfigLocation: 'PhpArmsConfigLocation',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            programmingLanguage: 'ProgrammingLanguage',\n            pvtzDiscoverySvc: 'PvtzDiscoverySvc',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            readiness: 'Readiness',\n            replicas: 'Replicas',\n            saeVersion: 'SaeVersion',\n            securityGroupId: 'SecurityGroupId',\n            serviceTags: 'ServiceTags',\n            slsConfigs: 'SlsConfigs',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            vSwitchId: 'VSwitchId',\n            vpcId: 'VpcId',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appDescription: 'string',\n            appName: 'string',\n            appSource: 'string',\n            associateEip: 'boolean',\n            autoConfig: 'boolean',\n            baseAppId: 'string',\n            command: 'string',\n            commandArgs: 'string',\n            configMapMountDesc: 'string',\n            cpu: 'number',\n            customHostAlias: 'string',\n            deploy: 'boolean',\n            edasContainerVersion: 'string',\n            enableEbpf: 'string',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            kafkaConfigs: 'string',\n            liveness: 'string',\n            memory: 'number',\n            microRegistration: 'string',\n            microRegistrationConfig: 'string',\n            mountDesc: 'string',\n            mountHost: 'string',\n            namespaceId: 'string',\n            nasConfigs: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            php: 'string',\n            phpArmsConfigLocation: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            programmingLanguage: 'string',\n            pvtzDiscoverySvc: 'string',\n            python: 'string',\n            pythonModules: 'string',\n            readiness: 'string',\n            replicas: 'number',\n            saeVersion: 'string',\n            securityGroupId: 'string',\n            serviceTags: 'string',\n            slsConfigs: 'string',\n            terminationGracePeriodSeconds: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            vSwitchId: 'string',\n            vpcId: 'string',\n            warStartOptions: 'string',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationRequest = CreateApplicationRequest;\nclass CreateApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationResponseBody = CreateApplicationResponseBody;\nclass CreateApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationResponse = CreateApplicationResponse;\nclass CreateApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            scalingRuleEnable: 'ScalingRuleEnable',\n            scalingRuleMetric: 'ScalingRuleMetric',\n            scalingRuleName: 'ScalingRuleName',\n            scalingRuleTimer: 'ScalingRuleTimer',\n            scalingRuleType: 'ScalingRuleType',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            scalingRuleEnable: 'boolean',\n            scalingRuleMetric: 'string',\n            scalingRuleName: 'string',\n            scalingRuleTimer: 'string',\n            scalingRuleType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleRequest = CreateApplicationScalingRuleRequest;\nclass CreateApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateApplicationScalingRuleResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBody = CreateApplicationScalingRuleResponseBody;\nclass CreateApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponse = CreateApplicationScalingRuleResponse;\nclass CreateConfigMapRequest extends $tea.Model {\n    static names() {\n        return {\n            data: 'Data',\n            description: 'Description',\n            name: 'Name',\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            data: 'string',\n            description: 'string',\n            name: 'string',\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateConfigMapRequest = CreateConfigMapRequest;\nclass CreateConfigMapResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateConfigMapResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateConfigMapResponseBody = CreateConfigMapResponseBody;\nclass CreateConfigMapResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateConfigMapResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateConfigMapResponse = CreateConfigMapResponse;\nclass CreateGreyTagRouteRequest extends $tea.Model {\n    static names() {\n        return {\n            albRules: 'AlbRules',\n            appId: 'AppId',\n            description: 'Description',\n            dubboRules: 'DubboRules',\n            name: 'Name',\n            scRules: 'ScRules',\n        };\n    }\n    static types() {\n        return {\n            albRules: 'string',\n            appId: 'string',\n            description: 'string',\n            dubboRules: 'string',\n            name: 'string',\n            scRules: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateGreyTagRouteRequest = CreateGreyTagRouteRequest;\nclass CreateGreyTagRouteResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateGreyTagRouteResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateGreyTagRouteResponseBody = CreateGreyTagRouteResponseBody;\nclass CreateGreyTagRouteResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateGreyTagRouteResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateGreyTagRouteResponse = CreateGreyTagRouteResponse;\nclass CreateIngressRequest extends $tea.Model {\n    static names() {\n        return {\n            certId: 'CertId',\n            certIds: 'CertIds',\n            defaultRule: 'DefaultRule',\n            description: 'Description',\n            listenerPort: 'ListenerPort',\n            listenerProtocol: 'ListenerProtocol',\n            loadBalanceType: 'LoadBalanceType',\n            namespaceId: 'NamespaceId',\n            requestTimeout: 'RequestTimeout',\n            rules: 'Rules',\n            securityPolicyId: 'SecurityPolicyId',\n            slbId: 'SlbId',\n        };\n    }\n    static types() {\n        return {\n            certId: 'string',\n            certIds: 'string',\n            defaultRule: 'string',\n            description: 'string',\n            listenerPort: 'number',\n            listenerProtocol: 'string',\n            loadBalanceType: 'string',\n            namespaceId: 'string',\n            requestTimeout: 'number',\n            rules: 'string',\n            securityPolicyId: 'string',\n            slbId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateIngressRequest = CreateIngressRequest;\nclass CreateIngressResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateIngressResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateIngressResponseBody = CreateIngressResponseBody;\nclass CreateIngressResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateIngressResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateIngressResponse = CreateIngressResponse;\nclass CreateJobRequest extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appDescription: 'AppDescription',\n            appName: 'AppName',\n            autoConfig: 'AutoConfig',\n            backoffLimit: 'BackoffLimit',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            concurrencyPolicy: 'ConcurrencyPolicy',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            cpu: 'Cpu',\n            customHostAlias: 'CustomHostAlias',\n            edasContainerVersion: 'EdasContainerVersion',\n            enableImageAccl: 'EnableImageAccl',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            memory: 'Memory',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            namespaceId: 'NamespaceId',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            programmingLanguage: 'ProgrammingLanguage',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            refAppId: 'RefAppId',\n            replicas: 'Replicas',\n            securityGroupId: 'SecurityGroupId',\n            slice: 'Slice',\n            sliceEnvs: 'SliceEnvs',\n            slsConfigs: 'SlsConfigs',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timeout: 'Timeout',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            triggerConfig: 'TriggerConfig',\n            vSwitchId: 'VSwitchId',\n            vpcId: 'VpcId',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n            workload: 'Workload',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appDescription: 'string',\n            appName: 'string',\n            autoConfig: 'boolean',\n            backoffLimit: 'number',\n            command: 'string',\n            commandArgs: 'string',\n            concurrencyPolicy: 'string',\n            configMapMountDesc: 'string',\n            cpu: 'number',\n            customHostAlias: 'string',\n            edasContainerVersion: 'string',\n            enableImageAccl: 'boolean',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            memory: 'number',\n            mountDesc: 'string',\n            mountHost: 'string',\n            namespaceId: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            programmingLanguage: 'string',\n            python: 'string',\n            pythonModules: 'string',\n            refAppId: 'string',\n            replicas: 'number',\n            securityGroupId: 'string',\n            slice: 'boolean',\n            sliceEnvs: 'string',\n            slsConfigs: 'string',\n            terminationGracePeriodSeconds: 'number',\n            timeout: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            triggerConfig: 'string',\n            vSwitchId: 'string',\n            vpcId: 'string',\n            warStartOptions: 'string',\n            webContainer: 'string',\n            workload: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateJobRequest = CreateJobRequest;\nclass CreateJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateJobResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateJobResponseBody = CreateJobResponseBody;\nclass CreateJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateJobResponse = CreateJobResponse;\nclass CreateNamespaceRequest extends $tea.Model {\n    static names() {\n        return {\n            enableMicroRegistration: 'EnableMicroRegistration',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n        };\n    }\n    static types() {\n        return {\n            enableMicroRegistration: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateNamespaceRequest = CreateNamespaceRequest;\nclass CreateNamespaceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateNamespaceResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateNamespaceResponseBody = CreateNamespaceResponseBody;\nclass CreateNamespaceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateNamespaceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateNamespaceResponse = CreateNamespaceResponse;\nclass CreateSecretRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretData: 'SecretData',\n            secretName: 'SecretName',\n            secretType: 'SecretType',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretData: CreateSecretRequestSecretData,\n            secretName: 'string',\n            secretType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretRequest = CreateSecretRequest;\nclass CreateSecretShrinkRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretDataShrink: 'SecretData',\n            secretName: 'SecretName',\n            secretType: 'SecretType',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretDataShrink: 'string',\n            secretName: 'string',\n            secretType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretShrinkRequest = CreateSecretShrinkRequest;\nclass CreateSecretResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: CreateSecretResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretResponseBody = CreateSecretResponseBody;\nclass CreateSecretResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateSecretResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretResponse = CreateSecretResponse;\nclass CreateWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: CreateWebApplicationInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebApplicationRequest = CreateWebApplicationRequest;\nclass CreateWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebApplicationResponse = CreateWebApplicationResponse;\nclass CreateWebCustomDomainRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: CreateWebCustomDomainInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebCustomDomainRequest = CreateWebCustomDomainRequest;\nclass CreateWebCustomDomainResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebCustomDomainBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateWebCustomDomainResponse = CreateWebCustomDomainResponse;\nclass DeleteApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationRequest = DeleteApplicationRequest;\nclass DeleteApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeleteApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationResponseBody = DeleteApplicationResponseBody;\nclass DeleteApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationResponse = DeleteApplicationResponse;\nclass DeleteApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            scalingRuleName: 'ScalingRuleName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            scalingRuleName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationScalingRuleRequest = DeleteApplicationScalingRuleRequest;\nclass DeleteApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationScalingRuleResponseBody = DeleteApplicationScalingRuleResponseBody;\nclass DeleteApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationScalingRuleResponse = DeleteApplicationScalingRuleResponse;\nclass DeleteConfigMapRequest extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteConfigMapRequest = DeleteConfigMapRequest;\nclass DeleteConfigMapResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeleteConfigMapResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteConfigMapResponseBody = DeleteConfigMapResponseBody;\nclass DeleteConfigMapResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteConfigMapResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteConfigMapResponse = DeleteConfigMapResponse;\nclass DeleteGreyTagRouteRequest extends $tea.Model {\n    static names() {\n        return {\n            greyTagRouteId: 'GreyTagRouteId',\n        };\n    }\n    static types() {\n        return {\n            greyTagRouteId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteGreyTagRouteRequest = DeleteGreyTagRouteRequest;\nclass DeleteGreyTagRouteResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeleteGreyTagRouteResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteGreyTagRouteResponseBody = DeleteGreyTagRouteResponseBody;\nclass DeleteGreyTagRouteResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteGreyTagRouteResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteGreyTagRouteResponse = DeleteGreyTagRouteResponse;\nclass DeleteHistoryJobRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            jobId: 'JobId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            jobId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteHistoryJobRequest = DeleteHistoryJobRequest;\nclass DeleteHistoryJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteHistoryJobResponseBody = DeleteHistoryJobResponseBody;\nclass DeleteHistoryJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteHistoryJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteHistoryJobResponse = DeleteHistoryJobResponse;\nclass DeleteIngressRequest extends $tea.Model {\n    static names() {\n        return {\n            ingressId: 'IngressId',\n        };\n    }\n    static types() {\n        return {\n            ingressId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteIngressRequest = DeleteIngressRequest;\nclass DeleteIngressResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeleteIngressResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteIngressResponseBody = DeleteIngressResponseBody;\nclass DeleteIngressResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteIngressResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteIngressResponse = DeleteIngressResponse;\nclass DeleteJobRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteJobRequest = DeleteJobRequest;\nclass DeleteJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteJobResponseBody = DeleteJobResponseBody;\nclass DeleteJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteJobResponse = DeleteJobResponse;\nclass DeleteNamespaceRequest extends $tea.Model {\n    static names() {\n        return {\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteNamespaceRequest = DeleteNamespaceRequest;\nclass DeleteNamespaceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteNamespaceResponseBody = DeleteNamespaceResponseBody;\nclass DeleteNamespaceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteNamespaceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteNamespaceResponse = DeleteNamespaceResponse;\nclass DeleteSecretRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteSecretRequest = DeleteSecretRequest;\nclass DeleteSecretResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeleteSecretResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteSecretResponseBody = DeleteSecretResponseBody;\nclass DeleteSecretResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteSecretResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteSecretResponse = DeleteSecretResponse;\nclass DeleteWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebApplicationRequest = DeleteWebApplicationRequest;\nclass DeleteWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebApplicationResponse = DeleteWebApplicationResponse;\nclass DeleteWebApplicationRevisionRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebApplicationRevisionRequest = DeleteWebApplicationRevisionRequest;\nclass DeleteWebApplicationRevisionResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationRevisionBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebApplicationRevisionResponse = DeleteWebApplicationRevisionResponse;\nclass DeleteWebCustomDomainRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebCustomDomainRequest = DeleteWebCustomDomainRequest;\nclass DeleteWebCustomDomainResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebCustomDomainBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteWebCustomDomainResponse = DeleteWebCustomDomainResponse;\nclass DeployApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appId: 'AppId',\n            associateEip: 'AssociateEip',\n            autoEnableApplicationScalingRule: 'AutoEnableApplicationScalingRule',\n            batchWaitTime: 'BatchWaitTime',\n            changeOrderDesc: 'ChangeOrderDesc',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            cpu: 'Cpu',\n            customHostAlias: 'CustomHostAlias',\n            deploy: 'Deploy',\n            edasContainerVersion: 'EdasContainerVersion',\n            enableAhas: 'EnableAhas',\n            enableGreyTagRoute: 'EnableGreyTagRoute',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            kafkaConfigs: 'KafkaConfigs',\n            liveness: 'Liveness',\n            memory: 'Memory',\n            microRegistration: 'MicroRegistration',\n            microRegistrationConfig: 'MicroRegistrationConfig',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            nasConfigs: 'NasConfigs',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            php: 'Php',\n            phpArmsConfigLocation: 'PhpArmsConfigLocation',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            pvtzDiscoverySvc: 'PvtzDiscoverySvc',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            readiness: 'Readiness',\n            replicas: 'Replicas',\n            securityGroupId: 'SecurityGroupId',\n            serviceTags: 'ServiceTags',\n            slsConfigs: 'SlsConfigs',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            updateStrategy: 'UpdateStrategy',\n            vSwitchId: 'VSwitchId',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appId: 'string',\n            associateEip: 'boolean',\n            autoEnableApplicationScalingRule: 'boolean',\n            batchWaitTime: 'number',\n            changeOrderDesc: 'string',\n            command: 'string',\n            commandArgs: 'string',\n            configMapMountDesc: 'string',\n            cpu: 'number',\n            customHostAlias: 'string',\n            deploy: 'string',\n            edasContainerVersion: 'string',\n            enableAhas: 'string',\n            enableGreyTagRoute: 'boolean',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            kafkaConfigs: 'string',\n            liveness: 'string',\n            memory: 'number',\n            microRegistration: 'string',\n            microRegistrationConfig: 'string',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            mountDesc: 'string',\n            mountHost: 'string',\n            nasConfigs: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            php: 'string',\n            phpArmsConfigLocation: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            pvtzDiscoverySvc: 'string',\n            python: 'string',\n            pythonModules: 'string',\n            readiness: 'string',\n            replicas: 'number',\n            securityGroupId: 'string',\n            serviceTags: 'string',\n            slsConfigs: 'string',\n            terminationGracePeriodSeconds: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            updateStrategy: 'string',\n            vSwitchId: 'string',\n            warStartOptions: 'string',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeployApplicationRequest = DeployApplicationRequest;\nclass DeployApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DeployApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeployApplicationResponseBody = DeployApplicationResponseBody;\nclass DeployApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeployApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeployApplicationResponse = DeployApplicationResponse;\nclass DescribeAppServiceDetailRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            nacosInstanceId: 'NacosInstanceId',\n            nacosNamespaceId: 'NacosNamespaceId',\n            serviceGroup: 'ServiceGroup',\n            serviceName: 'ServiceName',\n            serviceType: 'ServiceType',\n            serviceVersion: 'ServiceVersion',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            nacosInstanceId: 'string',\n            nacosNamespaceId: 'string',\n            serviceGroup: 'string',\n            serviceName: 'string',\n            serviceType: 'string',\n            serviceVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailRequest = DescribeAppServiceDetailRequest;\nclass DescribeAppServiceDetailResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeAppServiceDetailResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailResponseBody = DescribeAppServiceDetailResponseBody;\nclass DescribeAppServiceDetailResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeAppServiceDetailResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailResponse = DescribeAppServiceDetailResponse;\nclass DescribeApplicationConfigRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigRequest = DescribeApplicationConfigRequest;\nclass DescribeApplicationConfigResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationConfigResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBody = DescribeApplicationConfigResponseBody;\nclass DescribeApplicationConfigResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationConfigResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponse = DescribeApplicationConfigResponse;\nclass DescribeApplicationGroupsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            currentPage: 'number',\n            pageSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationGroupsRequest = DescribeApplicationGroupsRequest;\nclass DescribeApplicationGroupsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': DescribeApplicationGroupsResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationGroupsResponseBody = DescribeApplicationGroupsResponseBody;\nclass DescribeApplicationGroupsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationGroupsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationGroupsResponse = DescribeApplicationGroupsResponse;\nclass DescribeApplicationImageRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            imageUrl: 'ImageUrl',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            imageUrl: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationImageRequest = DescribeApplicationImageRequest;\nclass DescribeApplicationImageResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationImageResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationImageResponseBody = DescribeApplicationImageResponseBody;\nclass DescribeApplicationImageResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationImageResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationImageResponse = DescribeApplicationImageResponse;\nclass DescribeApplicationInstancesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            currentPage: 'CurrentPage',\n            groupId: 'GroupId',\n            pageSize: 'PageSize',\n            reverse: 'Reverse',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            currentPage: 'number',\n            groupId: 'string',\n            pageSize: 'number',\n            reverse: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationInstancesRequest = DescribeApplicationInstancesRequest;\nclass DescribeApplicationInstancesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationInstancesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationInstancesResponseBody = DescribeApplicationInstancesResponseBody;\nclass DescribeApplicationInstancesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationInstancesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationInstancesResponse = DescribeApplicationInstancesResponse;\nclass DescribeApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            scalingRuleName: 'ScalingRuleName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            scalingRuleName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleRequest = DescribeApplicationScalingRuleRequest;\nclass DescribeApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationScalingRuleResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBody = DescribeApplicationScalingRuleResponseBody;\nclass DescribeApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponse = DescribeApplicationScalingRuleResponse;\nclass DescribeApplicationScalingRulesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesRequest = DescribeApplicationScalingRulesRequest;\nclass DescribeApplicationScalingRulesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationScalingRulesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBody = DescribeApplicationScalingRulesResponseBody;\nclass DescribeApplicationScalingRulesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationScalingRulesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponse = DescribeApplicationScalingRulesResponse;\nclass DescribeApplicationSlbsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsRequest = DescribeApplicationSlbsRequest;\nclass DescribeApplicationSlbsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationSlbsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsResponseBody = DescribeApplicationSlbsResponseBody;\nclass DescribeApplicationSlbsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationSlbsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsResponse = DescribeApplicationSlbsResponse;\nclass DescribeApplicationStatusRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationStatusRequest = DescribeApplicationStatusRequest;\nclass DescribeApplicationStatusResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeApplicationStatusResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationStatusResponseBody = DescribeApplicationStatusResponseBody;\nclass DescribeApplicationStatusResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeApplicationStatusResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationStatusResponse = DescribeApplicationStatusResponse;\nclass DescribeChangeOrderRequest extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeChangeOrderRequest = DescribeChangeOrderRequest;\nclass DescribeChangeOrderResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeChangeOrderResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeChangeOrderResponseBody = DescribeChangeOrderResponseBody;\nclass DescribeChangeOrderResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeChangeOrderResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeChangeOrderResponse = DescribeChangeOrderResponse;\nclass DescribeComponentsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeComponentsRequest = DescribeComponentsRequest;\nclass DescribeComponentsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': DescribeComponentsResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeComponentsResponseBody = DescribeComponentsResponseBody;\nclass DescribeComponentsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeComponentsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeComponentsResponse = DescribeComponentsResponse;\nclass DescribeConfigMapRequest extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigMapRequest = DescribeConfigMapRequest;\nclass DescribeConfigMapResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeConfigMapResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigMapResponseBody = DescribeConfigMapResponseBody;\nclass DescribeConfigMapResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeConfigMapResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigMapResponse = DescribeConfigMapResponse;\nclass DescribeConfigurationPriceRequest extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            memory: 'Memory',\n            workload: 'Workload',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            memory: 'number',\n            workload: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceRequest = DescribeConfigurationPriceRequest;\nclass DescribeConfigurationPriceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeConfigurationPriceResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBody = DescribeConfigurationPriceResponseBody;\nclass DescribeConfigurationPriceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeConfigurationPriceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponse = DescribeConfigurationPriceResponse;\nclass DescribeEdasContainersResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': DescribeEdasContainersResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeEdasContainersResponseBody = DescribeEdasContainersResponseBody;\nclass DescribeEdasContainersResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeEdasContainersResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeEdasContainersResponse = DescribeEdasContainersResponse;\nclass DescribeGreyTagRouteRequest extends $tea.Model {\n    static names() {\n        return {\n            greyTagRouteId: 'GreyTagRouteId',\n        };\n    }\n    static types() {\n        return {\n            greyTagRouteId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteRequest = DescribeGreyTagRouteRequest;\nclass DescribeGreyTagRouteResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeGreyTagRouteResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBody = DescribeGreyTagRouteResponseBody;\nclass DescribeGreyTagRouteResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeGreyTagRouteResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponse = DescribeGreyTagRouteResponse;\nclass DescribeIngressRequest extends $tea.Model {\n    static names() {\n        return {\n            ingressId: 'IngressId',\n        };\n    }\n    static types() {\n        return {\n            ingressId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressRequest = DescribeIngressRequest;\nclass DescribeIngressResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeIngressResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressResponseBody = DescribeIngressResponseBody;\nclass DescribeIngressResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeIngressResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressResponse = DescribeIngressResponse;\nclass DescribeInstanceLogRequest extends $tea.Model {\n    static names() {\n        return {\n            instanceId: 'InstanceId',\n        };\n    }\n    static types() {\n        return {\n            instanceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceLogRequest = DescribeInstanceLogRequest;\nclass DescribeInstanceLogResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceLogResponseBody = DescribeInstanceLogResponseBody;\nclass DescribeInstanceLogResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeInstanceLogResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceLogResponse = DescribeInstanceLogResponse;\nclass DescribeInstanceSpecificationsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': DescribeInstanceSpecificationsResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceSpecificationsResponseBody = DescribeInstanceSpecificationsResponseBody;\nclass DescribeInstanceSpecificationsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeInstanceSpecificationsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceSpecificationsResponse = DescribeInstanceSpecificationsResponse;\nclass DescribeJobRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            jobId: 'JobId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            jobId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobRequest = DescribeJobRequest;\nclass DescribeJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeJobResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBody = DescribeJobResponseBody;\nclass DescribeJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponse = DescribeJobResponse;\nclass DescribeJobHistoryRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            state: 'State',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            currentPage: 'number',\n            pageSize: 'number',\n            state: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobHistoryRequest = DescribeJobHistoryRequest;\nclass DescribeJobHistoryResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeJobHistoryResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobHistoryResponseBody = DescribeJobHistoryResponseBody;\nclass DescribeJobHistoryResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeJobHistoryResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobHistoryResponse = DescribeJobHistoryResponse;\nclass DescribeJobStatusRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            jobId: 'JobId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            jobId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobStatusRequest = DescribeJobStatusRequest;\nclass DescribeJobStatusResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeJobStatusResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobStatusResponseBody = DescribeJobStatusResponseBody;\nclass DescribeJobStatusResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeJobStatusResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobStatusResponse = DescribeJobStatusResponse;\nclass DescribeNamespaceRequest extends $tea.Model {\n    static names() {\n        return {\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceRequest = DescribeNamespaceRequest;\nclass DescribeNamespaceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeNamespaceResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResponseBody = DescribeNamespaceResponseBody;\nclass DescribeNamespaceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeNamespaceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResponse = DescribeNamespaceResponse;\nclass DescribeNamespaceListRequest extends $tea.Model {\n    static names() {\n        return {\n            containCustom: 'ContainCustom',\n            hybridCloudExclude: 'HybridCloudExclude',\n        };\n    }\n    static types() {\n        return {\n            containCustom: 'boolean',\n            hybridCloudExclude: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceListRequest = DescribeNamespaceListRequest;\nclass DescribeNamespaceListResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': DescribeNamespaceListResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceListResponseBody = DescribeNamespaceListResponseBody;\nclass DescribeNamespaceListResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeNamespaceListResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceListResponse = DescribeNamespaceListResponse;\nclass DescribeNamespaceResourcesRequest extends $tea.Model {\n    static names() {\n        return {\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResourcesRequest = DescribeNamespaceResourcesRequest;\nclass DescribeNamespaceResourcesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeNamespaceResourcesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResourcesResponseBody = DescribeNamespaceResourcesResponseBody;\nclass DescribeNamespaceResourcesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeNamespaceResourcesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResourcesResponse = DescribeNamespaceResourcesResponse;\nclass DescribeNamespacesRequest extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            pageSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespacesRequest = DescribeNamespacesRequest;\nclass DescribeNamespacesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeNamespacesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespacesResponseBody = DescribeNamespacesResponseBody;\nclass DescribeNamespacesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeNamespacesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespacesResponse = DescribeNamespacesResponse;\nclass DescribePipelineRequest extends $tea.Model {\n    static names() {\n        return {\n            pipelineId: 'PipelineId',\n        };\n    }\n    static types() {\n        return {\n            pipelineId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineRequest = DescribePipelineRequest;\nclass DescribePipelineResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribePipelineResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineResponseBody = DescribePipelineResponseBody;\nclass DescribePipelineResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribePipelineResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineResponse = DescribePipelineResponse;\nclass DescribeRegionsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            message: 'Message',\n            regions: 'Regions',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            code: 'number',\n            message: 'string',\n            regions: DescribeRegionsResponseBodyRegions,\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeRegionsResponseBody = DescribeRegionsResponseBody;\nclass DescribeRegionsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRegionsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeRegionsResponse = DescribeRegionsResponse;\nclass DescribeSecretRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeSecretRequest = DescribeSecretRequest;\nclass DescribeSecretResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: DescribeSecretResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeSecretResponseBody = DescribeSecretResponseBody;\nclass DescribeSecretResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeSecretResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeSecretResponse = DescribeSecretResponse;\nclass DescribeWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationRequest = DescribeWebApplicationRequest;\nclass DescribeWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationResponse = DescribeWebApplicationResponse;\nclass DescribeWebApplicationResourceStaticsRequest extends $tea.Model {\n    static names() {\n        return {\n            endTime: 'EndTime',\n            namespaceId: 'NamespaceId',\n            regionId: 'RegionId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'number',\n            namespaceId: 'string',\n            regionId: 'string',\n            startTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationResourceStaticsRequest = DescribeWebApplicationResourceStaticsRequest;\nclass DescribeWebApplicationResourceStaticsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationResourceStaticsBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationResourceStaticsResponse = DescribeWebApplicationResourceStaticsResponse;\nclass DescribeWebApplicationRevisionRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationRevisionRequest = DescribeWebApplicationRevisionRequest;\nclass DescribeWebApplicationRevisionResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationRevisionBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationRevisionResponse = DescribeWebApplicationRevisionResponse;\nclass DescribeWebApplicationScalingConfigRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationScalingConfigRequest = DescribeWebApplicationScalingConfigRequest;\nclass DescribeWebApplicationScalingConfigResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationScalingConfigBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationScalingConfigResponse = DescribeWebApplicationScalingConfigResponse;\nclass DescribeWebApplicationTrafficConfigRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationTrafficConfigRequest = DescribeWebApplicationTrafficConfigRequest;\nclass DescribeWebApplicationTrafficConfigResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationTrafficConfigBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebApplicationTrafficConfigResponse = DescribeWebApplicationTrafficConfigResponse;\nclass DescribeWebCustomDomainRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebCustomDomainRequest = DescribeWebCustomDomainRequest;\nclass DescribeWebCustomDomainResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebCustomDomainBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebCustomDomainResponse = DescribeWebCustomDomainResponse;\nclass DescribeWebInstanceLogsRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebInstanceLogsRequest = DescribeWebInstanceLogsRequest;\nclass DescribeWebInstanceLogsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationInstanceLogsBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeWebInstanceLogsResponse = DescribeWebInstanceLogsResponse;\nclass DisableApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            scalingRuleName: 'ScalingRuleName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            scalingRuleName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DisableApplicationScalingRuleRequest = DisableApplicationScalingRuleRequest;\nclass DisableApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DisableApplicationScalingRuleResponseBody = DisableApplicationScalingRuleResponseBody;\nclass DisableApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DisableApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DisableApplicationScalingRuleResponse = DisableApplicationScalingRuleResponse;\nclass EnableApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            scalingRuleName: 'ScalingRuleName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            scalingRuleName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.EnableApplicationScalingRuleRequest = EnableApplicationScalingRuleRequest;\nclass EnableApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.EnableApplicationScalingRuleResponseBody = EnableApplicationScalingRuleResponseBody;\nclass EnableApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: EnableApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.EnableApplicationScalingRuleResponse = EnableApplicationScalingRuleResponse;\nclass ExecJobRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            envs: 'Envs',\n            eventId: 'EventId',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            replicas: 'Replicas',\n            time: 'Time',\n            warStartOptions: 'WarStartOptions',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            command: 'string',\n            commandArgs: 'string',\n            envs: 'string',\n            eventId: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            replicas: 'string',\n            time: 'string',\n            warStartOptions: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExecJobRequest = ExecJobRequest;\nclass ExecJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ExecJobResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExecJobResponseBody = ExecJobResponseBody;\nclass ExecJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ExecJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExecJobResponse = ExecJobResponse;\nclass GetArmsTopNMetricRequest extends $tea.Model {\n    static names() {\n        return {\n            appSource: 'AppSource',\n            cpuStrategy: 'CpuStrategy',\n            endTime: 'EndTime',\n            limit: 'Limit',\n            orderBy: 'OrderBy',\n            regionId: 'RegionId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            appSource: 'string',\n            cpuStrategy: 'string',\n            endTime: 'number',\n            limit: 'number',\n            orderBy: 'string',\n            regionId: 'string',\n            startTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetArmsTopNMetricRequest = GetArmsTopNMetricRequest;\nclass GetArmsTopNMetricResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': GetArmsTopNMetricResponseBodyData },\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetArmsTopNMetricResponseBody = GetArmsTopNMetricResponseBody;\nclass GetArmsTopNMetricResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: GetArmsTopNMetricResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetArmsTopNMetricResponse = GetArmsTopNMetricResponse;\nclass GetAvailabilityMetricRequest extends $tea.Model {\n    static names() {\n        return {\n            appSource: 'AppSource',\n            cpuStrategy: 'CpuStrategy',\n            limit: 'Limit',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            appSource: 'string',\n            cpuStrategy: 'string',\n            limit: 'number',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetAvailabilityMetricRequest = GetAvailabilityMetricRequest;\nclass GetAvailabilityMetricResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': GetAvailabilityMetricResponseBodyData },\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetAvailabilityMetricResponseBody = GetAvailabilityMetricResponseBody;\nclass GetAvailabilityMetricResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: GetAvailabilityMetricResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetAvailabilityMetricResponse = GetAvailabilityMetricResponse;\nclass GetChangeOrderMetricRequest extends $tea.Model {\n    static names() {\n        return {\n            appSource: 'AppSource',\n            cpuStrategy: 'CpuStrategy',\n            createTime: 'CreateTime',\n            limit: 'Limit',\n            orderBy: 'OrderBy',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            appSource: 'string',\n            cpuStrategy: 'string',\n            createTime: 'string',\n            limit: 'number',\n            orderBy: 'string',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetChangeOrderMetricRequest = GetChangeOrderMetricRequest;\nclass GetChangeOrderMetricResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': GetChangeOrderMetricResponseBodyData },\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetChangeOrderMetricResponseBody = GetChangeOrderMetricResponseBody;\nclass GetChangeOrderMetricResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: GetChangeOrderMetricResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetChangeOrderMetricResponse = GetChangeOrderMetricResponse;\nclass GetScaleAppMetricRequest extends $tea.Model {\n    static names() {\n        return {\n            appSource: 'AppSource',\n            cpuStrategy: 'CpuStrategy',\n            limit: 'Limit',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            appSource: 'string',\n            cpuStrategy: 'string',\n            limit: 'number',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetScaleAppMetricRequest = GetScaleAppMetricRequest;\nclass GetScaleAppMetricResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': GetScaleAppMetricResponseBodyData },\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetScaleAppMetricResponseBody = GetScaleAppMetricResponseBody;\nclass GetScaleAppMetricResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: GetScaleAppMetricResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetScaleAppMetricResponse = GetScaleAppMetricResponse;\nclass GetWarningEventMetricRequest extends $tea.Model {\n    static names() {\n        return {\n            appSource: 'AppSource',\n            cpuStrategy: 'CpuStrategy',\n            endTime: 'EndTime',\n            limit: 'Limit',\n            regionId: 'RegionId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            appSource: 'string',\n            cpuStrategy: 'string',\n            endTime: 'number',\n            limit: 'number',\n            regionId: 'string',\n            startTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetWarningEventMetricRequest = GetWarningEventMetricRequest;\nclass GetWarningEventMetricResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': GetWarningEventMetricResponseBodyData },\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetWarningEventMetricResponseBody = GetWarningEventMetricResponseBody;\nclass GetWarningEventMetricResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: GetWarningEventMetricResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetWarningEventMetricResponse = GetWarningEventMetricResponse;\nclass ListAppEventsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            currentPage: 'CurrentPage',\n            eventType: 'EventType',\n            namespace: 'Namespace',\n            objectKind: 'ObjectKind',\n            objectName: 'ObjectName',\n            pageSize: 'PageSize',\n            reason: 'Reason',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            currentPage: 'number',\n            eventType: 'string',\n            namespace: 'string',\n            objectKind: 'string',\n            objectName: 'string',\n            pageSize: 'number',\n            reason: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppEventsRequest = ListAppEventsRequest;\nclass ListAppEventsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListAppEventsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppEventsResponseBody = ListAppEventsResponseBody;\nclass ListAppEventsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListAppEventsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppEventsResponse = ListAppEventsResponse;\nclass ListAppServicesPageRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            serviceType: 'ServiceType',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            pageNumber: 'number',\n            pageSize: 'number',\n            serviceType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppServicesPageRequest = ListAppServicesPageRequest;\nclass ListAppServicesPageResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': ListAppServicesPageResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppServicesPageResponseBody = ListAppServicesPageResponseBody;\nclass ListAppServicesPageResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListAppServicesPageResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppServicesPageResponse = ListAppServicesPageResponse;\nclass ListAppVersionsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppVersionsRequest = ListAppVersionsRequest;\nclass ListAppVersionsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': ListAppVersionsResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppVersionsResponseBody = ListAppVersionsResponseBody;\nclass ListAppVersionsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListAppVersionsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppVersionsResponse = ListAppVersionsResponse;\nclass ListApplicationsRequest extends $tea.Model {\n    static names() {\n        return {\n            appName: 'AppName',\n            appSource: 'AppSource',\n            currentPage: 'CurrentPage',\n            fieldType: 'FieldType',\n            fieldValue: 'FieldValue',\n            namespaceId: 'NamespaceId',\n            orderBy: 'OrderBy',\n            pageSize: 'PageSize',\n            reverse: 'Reverse',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            appName: 'string',\n            appSource: 'string',\n            currentPage: 'number',\n            fieldType: 'string',\n            fieldValue: 'string',\n            namespaceId: 'string',\n            orderBy: 'string',\n            pageSize: 'number',\n            reverse: 'boolean',\n            tags: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsRequest = ListApplicationsRequest;\nclass ListApplicationsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            currentPage: 'CurrentPage',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            success: 'Success',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            currentPage: 'number',\n            data: ListApplicationsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            pageSize: 'number',\n            requestId: 'string',\n            success: 'boolean',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBody = ListApplicationsResponseBody;\nclass ListApplicationsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListApplicationsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponse = ListApplicationsResponse;\nclass ListChangeOrdersRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            coStatus: 'CoStatus',\n            coType: 'CoType',\n            currentPage: 'CurrentPage',\n            key: 'Key',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            coStatus: 'string',\n            coType: 'string',\n            currentPage: 'number',\n            key: 'string',\n            pageSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListChangeOrdersRequest = ListChangeOrdersRequest;\nclass ListChangeOrdersResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListChangeOrdersResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListChangeOrdersResponseBody = ListChangeOrdersResponseBody;\nclass ListChangeOrdersResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListChangeOrdersResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListChangeOrdersResponse = ListChangeOrdersResponse;\nclass ListConsumedServicesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListConsumedServicesRequest = ListConsumedServicesRequest;\nclass ListConsumedServicesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': ListConsumedServicesResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListConsumedServicesResponseBody = ListConsumedServicesResponseBody;\nclass ListConsumedServicesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListConsumedServicesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListConsumedServicesResponse = ListConsumedServicesResponse;\nclass ListGreyTagRouteRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteRequest = ListGreyTagRouteRequest;\nclass ListGreyTagRouteResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListGreyTagRouteResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBody = ListGreyTagRouteResponseBody;\nclass ListGreyTagRouteResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListGreyTagRouteResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponse = ListGreyTagRouteResponse;\nclass ListIngressesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListIngressesRequest = ListIngressesRequest;\nclass ListIngressesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListIngressesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListIngressesResponseBody = ListIngressesResponseBody;\nclass ListIngressesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListIngressesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListIngressesResponse = ListIngressesResponse;\nclass ListJobsRequest extends $tea.Model {\n    static names() {\n        return {\n            appName: 'AppName',\n            currentPage: 'CurrentPage',\n            fieldType: 'FieldType',\n            fieldValue: 'FieldValue',\n            namespaceId: 'NamespaceId',\n            orderBy: 'OrderBy',\n            pageSize: 'PageSize',\n            reverse: 'Reverse',\n            tags: 'Tags',\n            workload: 'Workload',\n        };\n    }\n    static types() {\n        return {\n            appName: 'string',\n            currentPage: 'number',\n            fieldType: 'string',\n            fieldValue: 'string',\n            namespaceId: 'string',\n            orderBy: 'string',\n            pageSize: 'number',\n            reverse: 'boolean',\n            tags: 'string',\n            workload: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsRequest = ListJobsRequest;\nclass ListJobsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            currentPage: 'CurrentPage',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            success: 'Success',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            currentPage: 'number',\n            data: ListJobsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            pageSize: 'number',\n            requestId: 'string',\n            success: 'boolean',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsResponseBody = ListJobsResponseBody;\nclass ListJobsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListJobsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsResponse = ListJobsResponse;\nclass ListLogConfigsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            currentPage: 'number',\n            pageSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListLogConfigsRequest = ListLogConfigsRequest;\nclass ListLogConfigsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListLogConfigsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListLogConfigsResponseBody = ListLogConfigsResponseBody;\nclass ListLogConfigsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListLogConfigsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListLogConfigsResponse = ListLogConfigsResponse;\nclass ListNamespaceChangeOrdersRequest extends $tea.Model {\n    static names() {\n        return {\n            coStatus: 'CoStatus',\n            coType: 'CoType',\n            currentPage: 'CurrentPage',\n            key: 'Key',\n            namespaceId: 'NamespaceId',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            coStatus: 'string',\n            coType: 'string',\n            currentPage: 'number',\n            key: 'string',\n            namespaceId: 'string',\n            pageSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespaceChangeOrdersRequest = ListNamespaceChangeOrdersRequest;\nclass ListNamespaceChangeOrdersResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListNamespaceChangeOrdersResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespaceChangeOrdersResponseBody = ListNamespaceChangeOrdersResponseBody;\nclass ListNamespaceChangeOrdersResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListNamespaceChangeOrdersResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespaceChangeOrdersResponse = ListNamespaceChangeOrdersResponse;\nclass ListNamespacedConfigMapsRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsRequest = ListNamespacedConfigMapsRequest;\nclass ListNamespacedConfigMapsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListNamespacedConfigMapsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsResponseBody = ListNamespacedConfigMapsResponseBody;\nclass ListNamespacedConfigMapsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListNamespacedConfigMapsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsResponse = ListNamespacedConfigMapsResponse;\nclass ListPublishedServicesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListPublishedServicesRequest = ListPublishedServicesRequest;\nclass ListPublishedServicesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: { 'type': 'array', 'itemType': ListPublishedServicesResponseBodyData },\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListPublishedServicesResponseBody = ListPublishedServicesResponseBody;\nclass ListPublishedServicesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListPublishedServicesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListPublishedServicesResponse = ListPublishedServicesResponse;\nclass ListSecretsRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsRequest = ListSecretsRequest;\nclass ListSecretsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListSecretsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsResponseBody = ListSecretsResponseBody;\nclass ListSecretsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListSecretsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsResponse = ListSecretsResponse;\nclass ListTagResourcesRequest extends $tea.Model {\n    static names() {\n        return {\n            nextToken: 'NextToken',\n            regionId: 'RegionId',\n            resourceIds: 'ResourceIds',\n            resourceType: 'ResourceType',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            nextToken: 'string',\n            regionId: 'string',\n            resourceIds: 'string',\n            resourceType: 'string',\n            tags: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListTagResourcesRequest = ListTagResourcesRequest;\nclass ListTagResourcesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ListTagResourcesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListTagResourcesResponseBody = ListTagResourcesResponseBody;\nclass ListTagResourcesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListTagResourcesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListTagResourcesResponse = ListTagResourcesResponse;\nclass ListWebApplicationInstancesRequest extends $tea.Model {\n    static names() {\n        return {\n            endTime: 'EndTime',\n            instanceIds: 'InstanceIds',\n            limit: 'Limit',\n            namespaceId: 'NamespaceId',\n            startTime: 'StartTime',\n            statuses: 'Statuses',\n            versionIds: 'VersionIds',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'number',\n            instanceIds: { 'type': 'array', 'itemType': 'string' },\n            limit: 'string',\n            namespaceId: 'string',\n            startTime: 'number',\n            statuses: { 'type': 'array', 'itemType': 'string' },\n            versionIds: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationInstancesRequest = ListWebApplicationInstancesRequest;\nclass ListWebApplicationInstancesShrinkRequest extends $tea.Model {\n    static names() {\n        return {\n            endTime: 'EndTime',\n            instanceIdsShrink: 'InstanceIds',\n            limit: 'Limit',\n            namespaceId: 'NamespaceId',\n            startTime: 'StartTime',\n            statusesShrink: 'Statuses',\n            versionIdsShrink: 'VersionIds',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'number',\n            instanceIdsShrink: 'string',\n            limit: 'string',\n            namespaceId: 'string',\n            startTime: 'number',\n            statusesShrink: 'string',\n            versionIdsShrink: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationInstancesShrinkRequest = ListWebApplicationInstancesShrinkRequest;\nclass ListWebApplicationInstancesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListWebApplicationInstancesBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationInstancesResponse = ListWebApplicationInstancesResponse;\nclass ListWebApplicationRevisionsRequest extends $tea.Model {\n    static names() {\n        return {\n            limit: 'Limit',\n            namespaceId: 'NamespaceId',\n            nextToken: 'NextToken',\n        };\n    }\n    static types() {\n        return {\n            limit: 'number',\n            namespaceId: 'string',\n            nextToken: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationRevisionsRequest = ListWebApplicationRevisionsRequest;\nclass ListWebApplicationRevisionsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListWebApplicationRevisionsBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationRevisionsResponse = ListWebApplicationRevisionsResponse;\nclass ListWebApplicationsRequest extends $tea.Model {\n    static names() {\n        return {\n            limit: 'Limit',\n            namespaceId: 'NamespaceId',\n            nextToken: 'NextToken',\n            prefix: 'Prefix',\n        };\n    }\n    static types() {\n        return {\n            limit: 'number',\n            namespaceId: 'string',\n            nextToken: 'string',\n            prefix: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationsRequest = ListWebApplicationsRequest;\nclass ListWebApplicationsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListWebApplicationsBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebApplicationsResponse = ListWebApplicationsResponse;\nclass ListWebCustomDomainsRequest extends $tea.Model {\n    static names() {\n        return {\n            applicationId: 'ApplicationId',\n            limit: 'Limit',\n            namespaceId: 'NamespaceId',\n            nextToken: 'NextToken',\n            prefix: 'Prefix',\n        };\n    }\n    static types() {\n        return {\n            applicationId: 'string',\n            limit: 'number',\n            namespaceId: 'string',\n            nextToken: 'string',\n            prefix: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebCustomDomainsRequest = ListWebCustomDomainsRequest;\nclass ListWebCustomDomainsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListWebCustomDomainBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListWebCustomDomainsResponse = ListWebCustomDomainsResponse;\nclass OpenSaeServiceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            orderId: 'OrderId',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            orderId: 'string',\n            requestId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.OpenSaeServiceResponseBody = OpenSaeServiceResponseBody;\nclass OpenSaeServiceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: OpenSaeServiceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.OpenSaeServiceResponse = OpenSaeServiceResponse;\nclass PublishWebApplicationRevisionRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: PublishWebApplicationRevisionInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PublishWebApplicationRevisionRequest = PublishWebApplicationRevisionRequest;\nclass PublishWebApplicationRevisionResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationRevisionBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PublishWebApplicationRevisionResponse = PublishWebApplicationRevisionResponse;\nclass QueryResourceStaticsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsRequest = QueryResourceStaticsRequest;\nclass QueryResourceStaticsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: QueryResourceStaticsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsResponseBody = QueryResourceStaticsResponseBody;\nclass QueryResourceStaticsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: QueryResourceStaticsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsResponse = QueryResourceStaticsResponse;\nclass ReduceApplicationCapacityByInstanceIdsRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            instanceIds: 'InstanceIds',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            instanceIds: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ReduceApplicationCapacityByInstanceIdsRequest = ReduceApplicationCapacityByInstanceIdsRequest;\nclass ReduceApplicationCapacityByInstanceIdsResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: ReduceApplicationCapacityByInstanceIdsResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ReduceApplicationCapacityByInstanceIdsResponseBody = ReduceApplicationCapacityByInstanceIdsResponseBody;\nclass ReduceApplicationCapacityByInstanceIdsResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ReduceApplicationCapacityByInstanceIdsResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ReduceApplicationCapacityByInstanceIdsResponse = ReduceApplicationCapacityByInstanceIdsResponse;\nclass RescaleApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            autoEnableApplicationScalingRule: 'AutoEnableApplicationScalingRule',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            replicas: 'Replicas',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            autoEnableApplicationScalingRule: 'boolean',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            replicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationRequest = RescaleApplicationRequest;\nclass RescaleApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: RescaleApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationResponseBody = RescaleApplicationResponseBody;\nclass RescaleApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RescaleApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationResponse = RescaleApplicationResponse;\nclass RescaleApplicationVerticallyRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            cpu: 'Cpu',\n            memory: 'Memory',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            cpu: 'string',\n            memory: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationVerticallyRequest = RescaleApplicationVerticallyRequest;\nclass RescaleApplicationVerticallyResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: RescaleApplicationVerticallyResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationVerticallyResponseBody = RescaleApplicationVerticallyResponseBody;\nclass RescaleApplicationVerticallyResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RescaleApplicationVerticallyResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationVerticallyResponse = RescaleApplicationVerticallyResponse;\nclass RestartApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            autoEnableApplicationScalingRule: 'AutoEnableApplicationScalingRule',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            autoEnableApplicationScalingRule: 'boolean',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartApplicationRequest = RestartApplicationRequest;\nclass RestartApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: RestartApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartApplicationResponseBody = RestartApplicationResponseBody;\nclass RestartApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RestartApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartApplicationResponse = RestartApplicationResponse;\nclass RestartInstancesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            instanceIds: 'InstanceIds',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            instanceIds: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartInstancesRequest = RestartInstancesRequest;\nclass RestartInstancesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: RestartInstancesResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartInstancesResponseBody = RestartInstancesResponseBody;\nclass RestartInstancesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RestartInstancesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartInstancesResponse = RestartInstancesResponse;\nclass RollbackApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            autoEnableApplicationScalingRule: 'AutoEnableApplicationScalingRule',\n            batchWaitTime: 'BatchWaitTime',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            updateStrategy: 'UpdateStrategy',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            autoEnableApplicationScalingRule: 'string',\n            batchWaitTime: 'number',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            updateStrategy: 'string',\n            versionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RollbackApplicationRequest = RollbackApplicationRequest;\nclass RollbackApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: RollbackApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RollbackApplicationResponseBody = RollbackApplicationResponseBody;\nclass RollbackApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RollbackApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RollbackApplicationResponse = RollbackApplicationResponse;\nclass StartApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartApplicationRequest = StartApplicationRequest;\nclass StartApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: StartApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartApplicationResponseBody = StartApplicationResponseBody;\nclass StartApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: StartApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartApplicationResponse = StartApplicationResponse;\nclass StartWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartWebApplicationRequest = StartWebApplicationRequest;\nclass StartWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartWebApplicationResponse = StartWebApplicationResponse;\nclass StopApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopApplicationRequest = StopApplicationRequest;\nclass StopApplicationResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: StopApplicationResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopApplicationResponseBody = StopApplicationResponseBody;\nclass StopApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: StopApplicationResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopApplicationResponse = StopApplicationResponse;\nclass StopWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopWebApplicationRequest = StopWebApplicationRequest;\nclass StopWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopWebApplicationResponse = StopWebApplicationResponse;\nclass SuspendJobRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            suspend: 'Suspend',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            suspend: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SuspendJobRequest = SuspendJobRequest;\nclass SuspendJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SuspendJobResponseBody = SuspendJobResponseBody;\nclass SuspendJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SuspendJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SuspendJobResponse = SuspendJobResponse;\nclass TagResourcesRequest extends $tea.Model {\n    static names() {\n        return {\n            regionId: 'RegionId',\n            resourceIds: 'ResourceIds',\n            resourceType: 'ResourceType',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            regionId: 'string',\n            resourceIds: 'string',\n            resourceType: 'string',\n            tags: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TagResourcesRequest = TagResourcesRequest;\nclass TagResourcesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'boolean',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TagResourcesResponseBody = TagResourcesResponseBody;\nclass TagResourcesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: TagResourcesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.TagResourcesResponse = TagResourcesResponse;\nclass UnbindSlbRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            internet: 'Internet',\n            intranet: 'Intranet',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            internet: 'boolean',\n            intranet: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UnbindSlbRequest = UnbindSlbRequest;\nclass UnbindSlbResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UnbindSlbResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UnbindSlbResponseBody = UnbindSlbResponseBody;\nclass UnbindSlbResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UnbindSlbResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UnbindSlbResponse = UnbindSlbResponse;\nclass UntagResourcesRequest extends $tea.Model {\n    static names() {\n        return {\n            deleteAll: 'DeleteAll',\n            regionId: 'RegionId',\n            resourceIds: 'ResourceIds',\n            resourceType: 'ResourceType',\n            tagKeys: 'TagKeys',\n        };\n    }\n    static types() {\n        return {\n            deleteAll: 'boolean',\n            regionId: 'string',\n            resourceIds: 'string',\n            resourceType: 'string',\n            tagKeys: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UntagResourcesRequest = UntagResourcesRequest;\nclass UntagResourcesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'boolean',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UntagResourcesResponseBody = UntagResourcesResponseBody;\nclass UntagResourcesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UntagResourcesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UntagResourcesResponse = UntagResourcesResponse;\nclass UpdateAppSecurityGroupRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            securityGroupId: 'SecurityGroupId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            securityGroupId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateAppSecurityGroupRequest = UpdateAppSecurityGroupRequest;\nclass UpdateAppSecurityGroupResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateAppSecurityGroupResponseBody = UpdateAppSecurityGroupResponseBody;\nclass UpdateAppSecurityGroupResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateAppSecurityGroupResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateAppSecurityGroupResponse = UpdateAppSecurityGroupResponse;\nclass UpdateApplicationDescriptionRequest extends $tea.Model {\n    static names() {\n        return {\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n        };\n    }\n    static types() {\n        return {\n            appDescription: 'string',\n            appId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationDescriptionRequest = UpdateApplicationDescriptionRequest;\nclass UpdateApplicationDescriptionResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationDescriptionResponseBody = UpdateApplicationDescriptionResponseBody;\nclass UpdateApplicationDescriptionResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateApplicationDescriptionResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationDescriptionResponse = UpdateApplicationDescriptionResponse;\nclass UpdateApplicationScalingRuleRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            scalingRuleMetric: 'ScalingRuleMetric',\n            scalingRuleName: 'ScalingRuleName',\n            scalingRuleTimer: 'ScalingRuleTimer',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            scalingRuleMetric: 'string',\n            scalingRuleName: 'string',\n            scalingRuleTimer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleRequest = UpdateApplicationScalingRuleRequest;\nclass UpdateApplicationScalingRuleResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateApplicationScalingRuleResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBody = UpdateApplicationScalingRuleResponseBody;\nclass UpdateApplicationScalingRuleResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateApplicationScalingRuleResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponse = UpdateApplicationScalingRuleResponse;\nclass UpdateApplicationVswitchesRequest extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            vSwitchId: 'VSwitchId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            vSwitchId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationVswitchesRequest = UpdateApplicationVswitchesRequest;\nclass UpdateApplicationVswitchesResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationVswitchesResponseBody = UpdateApplicationVswitchesResponseBody;\nclass UpdateApplicationVswitchesResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateApplicationVswitchesResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationVswitchesResponse = UpdateApplicationVswitchesResponse;\nclass UpdateConfigMapRequest extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n            data: 'Data',\n            description: 'Description',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n            data: 'string',\n            description: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateConfigMapRequest = UpdateConfigMapRequest;\nclass UpdateConfigMapResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateConfigMapResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateConfigMapResponseBody = UpdateConfigMapResponseBody;\nclass UpdateConfigMapResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateConfigMapResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateConfigMapResponse = UpdateConfigMapResponse;\nclass UpdateGreyTagRouteRequest extends $tea.Model {\n    static names() {\n        return {\n            albRules: 'AlbRules',\n            description: 'Description',\n            dubboRules: 'DubboRules',\n            greyTagRouteId: 'GreyTagRouteId',\n            scRules: 'ScRules',\n        };\n    }\n    static types() {\n        return {\n            albRules: 'string',\n            description: 'string',\n            dubboRules: 'string',\n            greyTagRouteId: 'number',\n            scRules: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateGreyTagRouteRequest = UpdateGreyTagRouteRequest;\nclass UpdateGreyTagRouteResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateGreyTagRouteResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateGreyTagRouteResponseBody = UpdateGreyTagRouteResponseBody;\nclass UpdateGreyTagRouteResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateGreyTagRouteResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateGreyTagRouteResponse = UpdateGreyTagRouteResponse;\nclass UpdateIngressRequest extends $tea.Model {\n    static names() {\n        return {\n            certId: 'CertId',\n            certIds: 'CertIds',\n            defaultRule: 'DefaultRule',\n            description: 'Description',\n            ingressId: 'IngressId',\n            listenerPort: 'ListenerPort',\n            listenerProtocol: 'ListenerProtocol',\n            loadBalanceType: 'LoadBalanceType',\n            requestTimeout: 'RequestTimeout',\n            rules: 'Rules',\n            securityPolicyId: 'SecurityPolicyId',\n        };\n    }\n    static types() {\n        return {\n            certId: 'string',\n            certIds: 'string',\n            defaultRule: 'string',\n            description: 'string',\n            ingressId: 'number',\n            listenerPort: 'string',\n            listenerProtocol: 'string',\n            loadBalanceType: 'string',\n            requestTimeout: 'number',\n            rules: 'string',\n            securityPolicyId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateIngressRequest = UpdateIngressRequest;\nclass UpdateIngressResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateIngressResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateIngressResponseBody = UpdateIngressResponseBody;\nclass UpdateIngressResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateIngressResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateIngressResponse = UpdateIngressResponse;\nclass UpdateJobRequest extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appId: 'AppId',\n            backoffLimit: 'BackoffLimit',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            concurrencyPolicy: 'ConcurrencyPolicy',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            customHostAlias: 'CustomHostAlias',\n            edasContainerVersion: 'EdasContainerVersion',\n            enableImageAccl: 'EnableImageAccl',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            php: 'Php',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            programmingLanguage: 'ProgrammingLanguage',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            refAppId: 'RefAppId',\n            replicas: 'Replicas',\n            slice: 'Slice',\n            sliceEnvs: 'SliceEnvs',\n            slsConfigs: 'SlsConfigs',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timeout: 'Timeout',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            triggerConfig: 'TriggerConfig',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appId: 'string',\n            backoffLimit: 'number',\n            command: 'string',\n            commandArgs: 'string',\n            concurrencyPolicy: 'string',\n            configMapMountDesc: 'string',\n            customHostAlias: 'string',\n            edasContainerVersion: 'string',\n            enableImageAccl: 'boolean',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            mountDesc: 'string',\n            mountHost: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            php: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            programmingLanguage: 'string',\n            python: 'string',\n            pythonModules: 'string',\n            refAppId: 'string',\n            replicas: 'string',\n            slice: 'boolean',\n            sliceEnvs: 'string',\n            slsConfigs: 'string',\n            terminationGracePeriodSeconds: 'number',\n            timeout: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            triggerConfig: 'string',\n            warStartOptions: 'string',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateJobRequest = UpdateJobRequest;\nclass UpdateJobResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateJobResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateJobResponseBody = UpdateJobResponseBody;\nclass UpdateJobResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateJobResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateJobResponse = UpdateJobResponse;\nclass UpdateNamespaceRequest extends $tea.Model {\n    static names() {\n        return {\n            enableMicroRegistration: 'EnableMicroRegistration',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n        };\n    }\n    static types() {\n        return {\n            enableMicroRegistration: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceRequest = UpdateNamespaceRequest;\nclass UpdateNamespaceResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateNamespaceResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceResponseBody = UpdateNamespaceResponseBody;\nclass UpdateNamespaceResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateNamespaceResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceResponse = UpdateNamespaceResponse;\nclass UpdateNamespaceVpcRequest extends $tea.Model {\n    static names() {\n        return {\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n            vpcId: 'VpcId',\n        };\n    }\n    static types() {\n        return {\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n            vpcId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceVpcRequest = UpdateNamespaceVpcRequest;\nclass UpdateNamespaceVpcResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceVpcResponseBody = UpdateNamespaceVpcResponseBody;\nclass UpdateNamespaceVpcResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateNamespaceVpcResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceVpcResponse = UpdateNamespaceVpcResponse;\nclass UpdateSecretRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretData: 'SecretData',\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretData: UpdateSecretRequestSecretData,\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretRequest = UpdateSecretRequest;\nclass UpdateSecretShrinkRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            secretDataShrink: 'SecretData',\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            secretDataShrink: 'string',\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretShrinkRequest = UpdateSecretShrinkRequest;\nclass UpdateSecretResponseBody extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            errorCode: 'ErrorCode',\n            message: 'Message',\n            requestId: 'RequestId',\n            success: 'Success',\n            traceId: 'TraceId',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: UpdateSecretResponseBodyData,\n            errorCode: 'string',\n            message: 'string',\n            requestId: 'string',\n            success: 'boolean',\n            traceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretResponseBody = UpdateSecretResponseBody;\nclass UpdateSecretResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateSecretResponseBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretResponse = UpdateSecretResponse;\nclass UpdateWebApplicationRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: UpdateWebApplicationInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationRequest = UpdateWebApplicationRequest;\nclass UpdateWebApplicationResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationResponse = UpdateWebApplicationResponse;\nclass UpdateWebApplicationScalingConfigRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: UpdateWebApplicationScalingConfigInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationScalingConfigRequest = UpdateWebApplicationScalingConfigRequest;\nclass UpdateWebApplicationScalingConfigResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationScalingConfigBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationScalingConfigResponse = UpdateWebApplicationScalingConfigResponse;\nclass UpdateWebApplicationTrafficConfigRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: UpdateWebApplicationTrafficConfigInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationTrafficConfigRequest = UpdateWebApplicationTrafficConfigRequest;\nclass UpdateWebApplicationTrafficConfigResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebApplicationTrafficConfigBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebApplicationTrafficConfigResponse = UpdateWebApplicationTrafficConfigResponse;\nclass UpdateWebCustomDomainRequest extends $tea.Model {\n    static names() {\n        return {\n            namespaceId: 'NamespaceId',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            namespaceId: 'string',\n            body: UpdateWebCustomDomainInput,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebCustomDomainRequest = UpdateWebCustomDomainRequest;\nclass UpdateWebCustomDomainResponse extends $tea.Model {\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: WebCustomDomainBody,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateWebCustomDomainResponse = UpdateWebCustomDomainResponse;\nclass AppStackInstanceEndpoints extends $tea.Model {\n    static names() {\n        return {\n            address: 'Address',\n            name: 'Name',\n            protocol: 'Protocol',\n        };\n    }\n    static types() {\n        return {\n            address: 'string',\n            name: 'string',\n            protocol: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackInstanceEndpoints = AppStackInstanceEndpoints;\nclass AppStackInstanceParameters extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackInstanceParameters = AppStackInstanceParameters;\nclass AppStackTaskSteps extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            duration: 'Duration',\n            endTime: 'EndTime',\n            id: 'Id',\n            message: 'Message',\n            name: 'Name',\n            startTime: 'StartTime',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            duration: 'number',\n            endTime: 'number',\n            id: 'string',\n            message: 'string',\n            name: 'string',\n            startTime: 'number',\n            status: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AppStackTaskSteps = AppStackTaskSteps;\nclass BuildPipelineBuildConfig extends $tea.Model {\n    static names() {\n        return {\n            beforeBuildCommand: 'BeforeBuildCommand',\n            buildType: 'BuildType',\n            dockerfilePath: 'DockerfilePath',\n            runCommand: 'RunCommand',\n            runtimeType: 'RuntimeType',\n            runtimeVersion: 'RuntimeVersion',\n            tomcatConfig: 'TomcatConfig',\n            workingDir: 'WorkingDir',\n        };\n    }\n    static types() {\n        return {\n            beforeBuildCommand: 'string',\n            buildType: 'string',\n            dockerfilePath: 'string',\n            runCommand: 'string',\n            runtimeType: 'string',\n            runtimeVersion: 'string',\n            tomcatConfig: TomcatConfig,\n            workingDir: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineBuildConfig = BuildPipelineBuildConfig;\nclass BuildPipelineCodeConfig extends $tea.Model {\n    static names() {\n        return {\n            accountId: 'AccountId',\n            branchName: 'BranchName',\n            commitId: 'CommitId',\n            commitUrl: 'CommitUrl',\n            organizationId: 'OrganizationId',\n            provider: 'Provider',\n            repoFullName: 'RepoFullName',\n            repoId: 'RepoId',\n        };\n    }\n    static types() {\n        return {\n            accountId: 'string',\n            branchName: 'string',\n            commitId: 'string',\n            commitUrl: 'string',\n            organizationId: 'string',\n            provider: 'string',\n            repoFullName: 'string',\n            repoId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineCodeConfig = BuildPipelineCodeConfig;\nclass BuildPipelineDeployConfig extends $tea.Model {\n    static names() {\n        return {\n            alwaysAllocateCPU: 'AlwaysAllocateCPU',\n            maximumInstanceCount: 'MaximumInstanceCount',\n            minimumInstanceCount: 'MinimumInstanceCount',\n            updateApplicationInput: 'UpdateApplicationInput',\n            updateTraffic: 'UpdateTraffic',\n        };\n    }\n    static types() {\n        return {\n            alwaysAllocateCPU: 'boolean',\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n            updateApplicationInput: 'string',\n            updateTraffic: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineDeployConfig = BuildPipelineDeployConfig;\nclass BuildPipelineImageConfig extends $tea.Model {\n    static names() {\n        return {\n            instanceType: 'InstanceType',\n            namespace: 'Namespace',\n            repository: 'Repository',\n        };\n    }\n    static types() {\n        return {\n            instanceType: 'string',\n            namespace: 'string',\n            repository: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineImageConfig = BuildPipelineImageConfig;\nclass BuildPipelinePackageConfig extends $tea.Model {\n    static names() {\n        return {\n            packageName: 'PackageName',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n        };\n    }\n    static types() {\n        return {\n            packageName: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelinePackageConfig = BuildPipelinePackageConfig;\nclass BuildPipelineTriggerConfig extends $tea.Model {\n    static names() {\n        return {\n            branchName: 'BranchName',\n            tagName: 'TagName',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            branchName: 'string',\n            tagName: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineTriggerConfig = BuildPipelineTriggerConfig;\nclass BuildPipelineRunBuildConfigTrigger extends $tea.Model {\n    static names() {\n        return {\n            branchName: 'BranchName',\n            tagName: 'TagName',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            branchName: 'string',\n            tagName: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunBuildConfigTrigger = BuildPipelineRunBuildConfigTrigger;\nclass BuildPipelineRunBuildConfig extends $tea.Model {\n    static names() {\n        return {\n            beforeBuildCommand: 'BeforeBuildCommand',\n            buildType: 'BuildType',\n            dockerfilePath: 'DockerfilePath',\n            runCommand: 'RunCommand',\n            runtimeType: 'RuntimeType',\n            runtimeVersion: 'RuntimeVersion',\n            tomcatConfig: 'TomcatConfig',\n            trigger: 'Trigger',\n            workingDir: 'WorkingDir',\n        };\n    }\n    static types() {\n        return {\n            beforeBuildCommand: 'string',\n            buildType: 'string',\n            dockerfilePath: 'string',\n            runCommand: 'string',\n            runtimeType: 'string',\n            runtimeVersion: 'string',\n            tomcatConfig: TomcatConfig,\n            trigger: BuildPipelineRunBuildConfigTrigger,\n            workingDir: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunBuildConfig = BuildPipelineRunBuildConfig;\nclass BuildPipelineRunCodeConfig extends $tea.Model {\n    static names() {\n        return {\n            accountId: 'AccountId',\n            branchName: 'BranchName',\n            commitId: 'CommitId',\n            commitUrl: 'CommitUrl',\n            organizationId: 'OrganizationId',\n            provider: 'Provider',\n            repoFullName: 'RepoFullName',\n            repoId: 'RepoId',\n        };\n    }\n    static types() {\n        return {\n            accountId: 'string',\n            branchName: 'string',\n            commitId: 'string',\n            commitUrl: 'string',\n            organizationId: 'string',\n            provider: 'string',\n            repoFullName: 'string',\n            repoId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunCodeConfig = BuildPipelineRunCodeConfig;\nclass BuildPipelineRunDeployConfig extends $tea.Model {\n    static names() {\n        return {\n            alwaysAllocateCPU: 'AlwaysAllocateCPU',\n            maximumInstanceCount: 'MaximumInstanceCount',\n            minimumInstanceCount: 'MinimumInstanceCount',\n            updateApplicationInput: 'UpdateApplicationInput',\n            updateTraffic: 'UpdateTraffic',\n        };\n    }\n    static types() {\n        return {\n            alwaysAllocateCPU: 'boolean',\n            maximumInstanceCount: 'number',\n            minimumInstanceCount: 'number',\n            updateApplicationInput: 'string',\n            updateTraffic: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunDeployConfig = BuildPipelineRunDeployConfig;\nclass BuildPipelineRunImageConfig extends $tea.Model {\n    static names() {\n        return {\n            instanceType: 'InstanceType',\n            namespace: 'Namespace',\n            repository: 'Repository',\n        };\n    }\n    static types() {\n        return {\n            instanceType: 'string',\n            namespace: 'string',\n            repository: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunImageConfig = BuildPipelineRunImageConfig;\nclass BuildPipelineRunPackageConfig extends $tea.Model {\n    static names() {\n        return {\n            packageName: 'PackageName',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n        };\n    }\n    static types() {\n        return {\n            packageName: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunPackageConfig = BuildPipelineRunPackageConfig;\nclass BuildPipelineRunSteps extends $tea.Model {\n    static names() {\n        return {\n            description: 'Description',\n            duration: 'Duration',\n            endTime: 'EndTime',\n            id: 'Id',\n            name: 'Name',\n            result: 'Result',\n            startTime: 'StartTime',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            description: 'string',\n            duration: 'number',\n            endTime: 'number',\n            id: 'string',\n            name: 'string',\n            result: 'string',\n            startTime: 'number',\n            status: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunSteps = BuildPipelineRunSteps;\nclass BuildPipelineRunTriggerConfig extends $tea.Model {\n    static names() {\n        return {\n            branchName: 'BranchName',\n            tagName: 'TagName',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            branchName: 'string',\n            tagName: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BuildPipelineRunTriggerConfig = BuildPipelineRunTriggerConfig;\nclass PriceEstimateOutputAppsUsages extends $tea.Model {\n    static names() {\n        return {\n            amount: 'Amount',\n            id: 'Id',\n            unit: 'Unit',\n        };\n    }\n    static types() {\n        return {\n            amount: 'number',\n            id: 'string',\n            unit: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateOutputAppsUsages = PriceEstimateOutputAppsUsages;\nclass PriceEstimateOutputApps extends $tea.Model {\n    static names() {\n        return {\n            feature: 'Feature',\n            id: 'Id',\n            usages: 'Usages',\n        };\n    }\n    static types() {\n        return {\n            feature: PriceEstimateFeature,\n            id: 'number',\n            usages: { 'type': 'array', 'itemType': PriceEstimateOutputAppsUsages },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateOutputApps = PriceEstimateOutputApps;\nclass PriceEstimateOutputItemsSteps extends $tea.Model {\n    static names() {\n        return {\n            begin: 'Begin',\n            end: 'End',\n            price: 'Price',\n            regionIds: 'RegionIds',\n            unit: 'Unit',\n        };\n    }\n    static types() {\n        return {\n            begin: 'number',\n            end: 'number',\n            price: 'number',\n            regionIds: { 'type': 'array', 'itemType': 'string' },\n            unit: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateOutputItemsSteps = PriceEstimateOutputItemsSteps;\nclass PriceEstimateOutputItems extends $tea.Model {\n    static names() {\n        return {\n            amount: 'Amount',\n            count: 'Count',\n            id: 'Id',\n            price: 'Price',\n            steps: 'Steps',\n            type: 'Type',\n            unit: 'Unit',\n        };\n    }\n    static types() {\n        return {\n            amount: 'number',\n            count: 'number',\n            id: 'string',\n            price: 'number',\n            steps: { 'type': 'array', 'itemType': PriceEstimateOutputItemsSteps },\n            type: 'string',\n            unit: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.PriceEstimateOutputItems = PriceEstimateOutputItems;\nclass ProbeProbeHandlerHttpGetHttpHeaders extends $tea.Model {\n    static names() {\n        return {\n            name: 'name',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ProbeProbeHandlerHttpGetHttpHeaders = ProbeProbeHandlerHttpGetHttpHeaders;\nclass ProbeProbeHandlerHttpGet extends $tea.Model {\n    static names() {\n        return {\n            httpHeaders: 'httpHeaders',\n            path: 'path',\n            port: 'port',\n        };\n    }\n    static types() {\n        return {\n            httpHeaders: { 'type': 'array', 'itemType': ProbeProbeHandlerHttpGetHttpHeaders },\n            path: 'string',\n            port: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ProbeProbeHandlerHttpGet = ProbeProbeHandlerHttpGet;\nclass ProbeProbeHandlerTcpSocket extends $tea.Model {\n    static names() {\n        return {\n            port: 'port',\n        };\n    }\n    static types() {\n        return {\n            port: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ProbeProbeHandlerTcpSocket = ProbeProbeHandlerTcpSocket;\nclass ProbeProbeHandler extends $tea.Model {\n    static names() {\n        return {\n            httpGet: 'httpGet',\n            tcpSocket: 'tcpSocket',\n        };\n    }\n    static types() {\n        return {\n            httpGet: ProbeProbeHandlerHttpGet,\n            tcpSocket: ProbeProbeHandlerTcpSocket,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ProbeProbeHandler = ProbeProbeHandler;\nclass SLSConfigCollectConfigs extends $tea.Model {\n    static names() {\n        return {\n            logPath: 'logPath',\n            logType: 'logType',\n            logstoreName: 'logstoreName',\n            logtailName: 'logtailName',\n            projectName: 'projectName',\n        };\n    }\n    static types() {\n        return {\n            logPath: 'string',\n            logType: 'string',\n            logstoreName: 'string',\n            logtailName: 'string',\n            projectName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SLSConfigCollectConfigs = SLSConfigCollectConfigs;\nclass SourceCodeAccountOrganizations extends $tea.Model {\n    static names() {\n        return {\n            avatarUrl: 'AvatarUrl',\n            id: 'Id',\n            name: 'Name',\n        };\n    }\n    static types() {\n        return {\n            avatarUrl: 'string',\n            id: 'string',\n            name: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SourceCodeAccountOrganizations = SourceCodeAccountOrganizations;\nclass SubmenuItems extends $tea.Model {\n    static names() {\n        return {\n            defaultSelected: 'DefaultSelected',\n            itemDesc: 'ItemDesc',\n            itemType: 'ItemType',\n            relatingItems: 'RelatingItems',\n        };\n    }\n    static types() {\n        return {\n            defaultSelected: 'boolean',\n            itemDesc: 'string',\n            itemType: 'string',\n            relatingItems: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.SubmenuItems = SubmenuItems;\nclass AbortAndRollbackChangeOrderResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortAndRollbackChangeOrderResponseBodyData = AbortAndRollbackChangeOrderResponseBodyData;\nclass AbortChangeOrderResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.AbortChangeOrderResponseBodyData = AbortChangeOrderResponseBodyData;\nclass BatchStartApplicationsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStartApplicationsResponseBodyData = BatchStartApplicationsResponseBodyData;\nclass BatchStopApplicationsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BatchStopApplicationsResponseBodyData = BatchStopApplicationsResponseBodyData;\nclass BindSlbResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.BindSlbResponseBodyData = BindSlbResponseBodyData;\nclass ConfirmPipelineBatchResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            pipelineId: 'PipelineId',\n        };\n    }\n    static types() {\n        return {\n            pipelineId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ConfirmPipelineBatchResponseBodyData = ConfirmPipelineBatchResponseBodyData;\nclass CreateApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationResponseBodyData = CreateApplicationResponseBodyData;\nclass CreateApplicationScalingRuleResponseBodyDataMetricMetrics extends $tea.Model {\n    static names() {\n        return {\n            metricTargetAverageUtilization: 'MetricTargetAverageUtilization',\n            metricType: 'MetricType',\n            slbId: 'SlbId',\n            slbLogstore: 'SlbLogstore',\n            slbProject: 'SlbProject',\n            vport: 'Vport',\n        };\n    }\n    static types() {\n        return {\n            metricTargetAverageUtilization: 'number',\n            metricType: 'string',\n            slbId: 'string',\n            slbLogstore: 'string',\n            slbProject: 'string',\n            vport: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBodyDataMetricMetrics = CreateApplicationScalingRuleResponseBodyDataMetricMetrics;\nclass CreateApplicationScalingRuleResponseBodyDataMetric extends $tea.Model {\n    static names() {\n        return {\n            maxReplicas: 'MaxReplicas',\n            metrics: 'Metrics',\n            minReplicas: 'MinReplicas',\n        };\n    }\n    static types() {\n        return {\n            maxReplicas: 'number',\n            metrics: { 'type': 'array', 'itemType': CreateApplicationScalingRuleResponseBodyDataMetricMetrics },\n            minReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBodyDataMetric = CreateApplicationScalingRuleResponseBodyDataMetric;\nclass CreateApplicationScalingRuleResponseBodyDataTimerSchedules extends $tea.Model {\n    static names() {\n        return {\n            atTime: 'AtTime',\n            maxReplicas: 'MaxReplicas',\n            minReplicas: 'MinReplicas',\n            targetReplicas: 'TargetReplicas',\n        };\n    }\n    static types() {\n        return {\n            atTime: 'string',\n            maxReplicas: 'number',\n            minReplicas: 'number',\n            targetReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBodyDataTimerSchedules = CreateApplicationScalingRuleResponseBodyDataTimerSchedules;\nclass CreateApplicationScalingRuleResponseBodyDataTimer extends $tea.Model {\n    static names() {\n        return {\n            beginDate: 'BeginDate',\n            endDate: 'EndDate',\n            period: 'Period',\n            schedules: 'Schedules',\n        };\n    }\n    static types() {\n        return {\n            beginDate: 'string',\n            endDate: 'string',\n            period: 'string',\n            schedules: { 'type': 'array', 'itemType': CreateApplicationScalingRuleResponseBodyDataTimerSchedules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBodyDataTimer = CreateApplicationScalingRuleResponseBodyDataTimer;\nclass CreateApplicationScalingRuleResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            createTime: 'CreateTime',\n            lastDisableTime: 'LastDisableTime',\n            metric: 'Metric',\n            scaleRuleEnabled: 'ScaleRuleEnabled',\n            scaleRuleName: 'ScaleRuleName',\n            scaleRuleType: 'ScaleRuleType',\n            timer: 'Timer',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            createTime: 'number',\n            lastDisableTime: 'number',\n            metric: CreateApplicationScalingRuleResponseBodyDataMetric,\n            scaleRuleEnabled: 'boolean',\n            scaleRuleName: 'string',\n            scaleRuleType: 'string',\n            timer: CreateApplicationScalingRuleResponseBodyDataTimer,\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateApplicationScalingRuleResponseBodyData = CreateApplicationScalingRuleResponseBodyData;\nclass CreateConfigMapResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateConfigMapResponseBodyData = CreateConfigMapResponseBodyData;\nclass CreateGreyTagRouteResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            greyTagRouteId: 'GreyTagRouteId',\n        };\n    }\n    static types() {\n        return {\n            greyTagRouteId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateGreyTagRouteResponseBodyData = CreateGreyTagRouteResponseBodyData;\nclass CreateIngressResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            ingressId: 'IngressId',\n        };\n    }\n    static types() {\n        return {\n            ingressId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateIngressResponseBodyData = CreateIngressResponseBodyData;\nclass CreateJobResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateJobResponseBodyData = CreateJobResponseBodyData;\nclass CreateNamespaceResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            enableMicroRegistration: 'EnableMicroRegistration',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            enableMicroRegistration: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateNamespaceResponseBodyData = CreateNamespaceResponseBodyData;\nclass CreateSecretRequestSecretData extends $tea.Model {\n    static names() {\n        return {\n            secretData: 'SecretData',\n        };\n    }\n    static types() {\n        return {\n            secretData: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretRequestSecretData = CreateSecretRequestSecretData;\nclass CreateSecretResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.CreateSecretResponseBodyData = CreateSecretResponseBodyData;\nclass DeleteApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteApplicationResponseBodyData = DeleteApplicationResponseBodyData;\nclass DeleteConfigMapResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteConfigMapResponseBodyData = DeleteConfigMapResponseBodyData;\nclass DeleteGreyTagRouteResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            greyTagRouteId: 'GreyTagRouteId',\n        };\n    }\n    static types() {\n        return {\n            greyTagRouteId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteGreyTagRouteResponseBodyData = DeleteGreyTagRouteResponseBodyData;\nclass DeleteIngressResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            ingressId: 'IngressId',\n        };\n    }\n    static types() {\n        return {\n            ingressId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteIngressResponseBodyData = DeleteIngressResponseBodyData;\nclass DeleteSecretResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeleteSecretResponseBodyData = DeleteSecretResponseBodyData;\nclass DeployApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            changeOrderId: 'ChangeOrderId',\n            isNeedApproval: 'IsNeedApproval',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            changeOrderId: 'string',\n            isNeedApproval: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DeployApplicationResponseBodyData = DeployApplicationResponseBodyData;\nclass DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions extends $tea.Model {\n    static names() {\n        return {\n            description: 'Description',\n            name: 'Name',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            description: 'string',\n            name: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions = DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions;\nclass DescribeAppServiceDetailResponseBodyDataMethods extends $tea.Model {\n    static names() {\n        return {\n            methodController: 'MethodController',\n            name: 'Name',\n            nameDetail: 'NameDetail',\n            parameterDefinitions: 'ParameterDefinitions',\n            parameterDetails: 'ParameterDetails',\n            parameterTypes: 'ParameterTypes',\n            paths: 'Paths',\n            requestMethods: 'RequestMethods',\n            returnDetails: 'ReturnDetails',\n            returnType: 'ReturnType',\n        };\n    }\n    static types() {\n        return {\n            methodController: 'string',\n            name: 'string',\n            nameDetail: 'string',\n            parameterDefinitions: { 'type': 'array', 'itemType': DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions },\n            parameterDetails: { 'type': 'array', 'itemType': 'string' },\n            parameterTypes: { 'type': 'array', 'itemType': 'string' },\n            paths: { 'type': 'array', 'itemType': 'string' },\n            requestMethods: { 'type': 'array', 'itemType': 'string' },\n            returnDetails: 'string',\n            returnType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailResponseBodyDataMethods = DescribeAppServiceDetailResponseBodyDataMethods;\nclass DescribeAppServiceDetailResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            dubboApplicationName: 'DubboApplicationName',\n            edasAppName: 'EdasAppName',\n            group: 'Group',\n            metadata: 'Metadata',\n            methods: 'Methods',\n            serviceName: 'ServiceName',\n            servicePorts: 'ServicePorts',\n            serviceProtocol: 'ServiceProtocol',\n            serviceTags: 'ServiceTags',\n            serviceType: 'ServiceType',\n            springApplicationName: 'SpringApplicationName',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            dubboApplicationName: 'string',\n            edasAppName: 'string',\n            group: 'string',\n            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },\n            methods: { 'type': 'array', 'itemType': DescribeAppServiceDetailResponseBodyDataMethods },\n            serviceName: 'string',\n            servicePorts: { 'type': 'array', 'itemType': 'number' },\n            serviceProtocol: 'string',\n            serviceTags: { 'type': 'array', 'itemType': 'string' },\n            serviceType: 'string',\n            springApplicationName: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeAppServiceDetailResponseBodyData = DescribeAppServiceDetailResponseBodyData;\nclass DescribeApplicationConfigResponseBodyDataConfigMapMountDesc extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n            configMapName: 'ConfigMapName',\n            key: 'Key',\n            mountPath: 'MountPath',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n            configMapName: 'string',\n            key: 'string',\n            mountPath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBodyDataConfigMapMountDesc = DescribeApplicationConfigResponseBodyDataConfigMapMountDesc;\nclass DescribeApplicationConfigResponseBodyDataMountDesc extends $tea.Model {\n    static names() {\n        return {\n            mountPath: 'MountPath',\n            nasPath: 'NasPath',\n        };\n    }\n    static types() {\n        return {\n            mountPath: 'string',\n            nasPath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBodyDataMountDesc = DescribeApplicationConfigResponseBodyDataMountDesc;\nclass DescribeApplicationConfigResponseBodyDataOssMountDescs extends $tea.Model {\n    static names() {\n        return {\n            bucketName: 'bucketName',\n            bucketPath: 'bucketPath',\n            mountPath: 'mountPath',\n            readOnly: 'readOnly',\n        };\n    }\n    static types() {\n        return {\n            bucketName: 'string',\n            bucketPath: 'string',\n            mountPath: 'string',\n            readOnly: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBodyDataOssMountDescs = DescribeApplicationConfigResponseBodyDataOssMountDescs;\nclass DescribeApplicationConfigResponseBodyDataTags extends $tea.Model {\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBodyDataTags = DescribeApplicationConfigResponseBodyDataTags;\nclass DescribeApplicationConfigResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n            appName: 'AppName',\n            appSource: 'AppSource',\n            associateEip: 'AssociateEip',\n            batchWaitTime: 'BatchWaitTime',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            cpu: 'Cpu',\n            customHostAlias: 'CustomHostAlias',\n            edasContainerVersion: 'EdasContainerVersion',\n            enableAhas: 'EnableAhas',\n            enableGreyTagRoute: 'EnableGreyTagRoute',\n            enableIdle: 'EnableIdle',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            kafkaConfigs: 'KafkaConfigs',\n            liveness: 'Liveness',\n            memory: 'Memory',\n            microRegistration: 'MicroRegistration',\n            microRegistrationConfig: 'MicroRegistrationConfig',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            mseApplicationId: 'MseApplicationId',\n            mseApplicationName: 'MseApplicationName',\n            namespaceId: 'NamespaceId',\n            nasConfigs: 'NasConfigs',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            php: 'Php',\n            phpArmsConfigLocation: 'PhpArmsConfigLocation',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            programmingLanguage: 'ProgrammingLanguage',\n            pvtzDiscovery: 'PvtzDiscovery',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            readiness: 'Readiness',\n            regionId: 'RegionId',\n            replicas: 'Replicas',\n            securityGroupId: 'SecurityGroupId',\n            serviceTags: 'ServiceTags',\n            slsConfigs: 'SlsConfigs',\n            tags: 'Tags',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            updateStrategy: 'UpdateStrategy',\n            vSwitchId: 'VSwitchId',\n            vpcId: 'VpcId',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appDescription: 'string',\n            appId: 'string',\n            appName: 'string',\n            appSource: 'string',\n            associateEip: 'boolean',\n            batchWaitTime: 'number',\n            command: 'string',\n            commandArgs: 'string',\n            configMapMountDesc: { 'type': 'array', 'itemType': DescribeApplicationConfigResponseBodyDataConfigMapMountDesc },\n            cpu: 'number',\n            customHostAlias: 'string',\n            edasContainerVersion: 'string',\n            enableAhas: 'string',\n            enableGreyTagRoute: 'boolean',\n            enableIdle: 'boolean',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            kafkaConfigs: 'string',\n            liveness: 'string',\n            memory: 'number',\n            microRegistration: 'string',\n            microRegistrationConfig: 'string',\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            mountDesc: { 'type': 'array', 'itemType': DescribeApplicationConfigResponseBodyDataMountDesc },\n            mountHost: 'string',\n            mseApplicationId: 'string',\n            mseApplicationName: 'string',\n            namespaceId: 'string',\n            nasConfigs: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: { 'type': 'array', 'itemType': DescribeApplicationConfigResponseBodyDataOssMountDescs },\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            php: 'string',\n            phpArmsConfigLocation: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            programmingLanguage: 'string',\n            pvtzDiscovery: 'string',\n            python: 'string',\n            pythonModules: 'string',\n            readiness: 'string',\n            regionId: 'string',\n            replicas: 'number',\n            securityGroupId: 'string',\n            serviceTags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            slsConfigs: 'string',\n            tags: { 'type': 'array', 'itemType': DescribeApplicationConfigResponseBodyDataTags },\n            terminationGracePeriodSeconds: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            updateStrategy: 'string',\n            vSwitchId: 'string',\n            vpcId: 'string',\n            warStartOptions: 'string',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationConfigResponseBodyData = DescribeApplicationConfigResponseBodyData;\nclass DescribeApplicationGroupsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            edasContainerVersion: 'EdasContainerVersion',\n            groupId: 'GroupId',\n            groupName: 'GroupName',\n            groupType: 'GroupType',\n            imageUrl: 'ImageUrl',\n            jdk: 'Jdk',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            replicas: 'Replicas',\n            runningInstances: 'RunningInstances',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            edasContainerVersion: 'string',\n            groupId: 'string',\n            groupName: 'string',\n            groupType: 'number',\n            imageUrl: 'string',\n            jdk: 'string',\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            replicas: 'number',\n            runningInstances: 'number',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationGroupsResponseBodyData = DescribeApplicationGroupsResponseBodyData;\nclass DescribeApplicationImageResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            crUrl: 'CrUrl',\n            logo: 'Logo',\n            regionId: 'RegionId',\n            repoName: 'RepoName',\n            repoNamespace: 'RepoNamespace',\n            repoOriginType: 'RepoOriginType',\n            repoTag: 'RepoTag',\n            repoType: 'RepoType',\n        };\n    }\n    static types() {\n        return {\n            crUrl: 'string',\n            logo: 'string',\n            regionId: 'string',\n            repoName: 'string',\n            repoNamespace: 'string',\n            repoOriginType: 'string',\n            repoTag: 'string',\n            repoType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationImageResponseBodyData = DescribeApplicationImageResponseBodyData;\nclass DescribeApplicationInstancesResponseBodyDataInstances extends $tea.Model {\n    static names() {\n        return {\n            createTimeStamp: 'CreateTimeStamp',\n            debugStatus: 'DebugStatus',\n            eip: 'Eip',\n            finishTimeStamp: 'FinishTimeStamp',\n            groupId: 'GroupId',\n            imageUrl: 'ImageUrl',\n            instanceContainerIp: 'InstanceContainerIp',\n            instanceContainerRestarts: 'InstanceContainerRestarts',\n            instanceContainerStatus: 'InstanceContainerStatus',\n            instanceHealthStatus: 'InstanceHealthStatus',\n            instanceId: 'InstanceId',\n            packageVersion: 'PackageVersion',\n            vSwitchId: 'VSwitchId',\n        };\n    }\n    static types() {\n        return {\n            createTimeStamp: 'number',\n            debugStatus: 'boolean',\n            eip: 'string',\n            finishTimeStamp: 'number',\n            groupId: 'string',\n            imageUrl: 'string',\n            instanceContainerIp: 'string',\n            instanceContainerRestarts: 'number',\n            instanceContainerStatus: 'string',\n            instanceHealthStatus: 'string',\n            instanceId: 'string',\n            packageVersion: 'string',\n            vSwitchId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationInstancesResponseBodyDataInstances = DescribeApplicationInstancesResponseBodyDataInstances;\nclass DescribeApplicationInstancesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            instances: 'Instances',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            instances: { 'type': 'array', 'itemType': DescribeApplicationInstancesResponseBodyDataInstances },\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationInstancesResponseBodyData = DescribeApplicationInstancesResponseBodyData;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricMetrics extends $tea.Model {\n    static names() {\n        return {\n            metricTargetAverageUtilization: 'MetricTargetAverageUtilization',\n            metricType: 'MetricType',\n            slbId: 'SlbId',\n            slbLogstore: 'SlbLogstore',\n            slbProject: 'SlbProject',\n            vport: 'Vport',\n        };\n    }\n    static types() {\n        return {\n            metricTargetAverageUtilization: 'number',\n            metricType: 'string',\n            slbId: 'string',\n            slbLogstore: 'string',\n            slbProject: 'string',\n            vport: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricMetrics = DescribeApplicationScalingRuleResponseBodyDataMetricMetrics;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics extends $tea.Model {\n    static names() {\n        return {\n            currentValue: 'CurrentValue',\n            name: 'Name',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            currentValue: 'number',\n            name: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            nextScaleInAverageUtilization: 'NextScaleInAverageUtilization',\n            nextScaleOutAverageUtilization: 'NextScaleOutAverageUtilization',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            nextScaleInAverageUtilization: 'number',\n            nextScaleOutAverageUtilization: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus extends $tea.Model {\n    static names() {\n        return {\n            currentMetrics: 'CurrentMetrics',\n            currentReplicas: 'CurrentReplicas',\n            desiredReplicas: 'DesiredReplicas',\n            lastScaleTime: 'LastScaleTime',\n            nextScaleMetrics: 'NextScaleMetrics',\n            nextScaleTimePeriod: 'NextScaleTimePeriod',\n        };\n    }\n    static types() {\n        return {\n            currentMetrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics },\n            currentReplicas: 'number',\n            desiredReplicas: 'number',\n            lastScaleTime: 'string',\n            nextScaleMetrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics },\n            nextScaleTimePeriod: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules extends $tea.Model {\n    static names() {\n        return {\n            disabled: 'Disabled',\n            stabilizationWindowSeconds: 'StabilizationWindowSeconds',\n            step: 'Step',\n        };\n    }\n    static types() {\n        return {\n            disabled: 'boolean',\n            stabilizationWindowSeconds: 'number',\n            step: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules = DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules;\nclass DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules extends $tea.Model {\n    static names() {\n        return {\n            disabled: 'Disabled',\n            stabilizationWindowSeconds: 'StabilizationWindowSeconds',\n            step: 'Step',\n        };\n    }\n    static types() {\n        return {\n            disabled: 'boolean',\n            stabilizationWindowSeconds: 'number',\n            step: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules = DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules;\nclass DescribeApplicationScalingRuleResponseBodyDataMetric extends $tea.Model {\n    static names() {\n        return {\n            maxReplicas: 'MaxReplicas',\n            metrics: 'Metrics',\n            metricsStatus: 'MetricsStatus',\n            minReplicas: 'MinReplicas',\n            scaleDownRules: 'ScaleDownRules',\n            scaleUpRules: 'ScaleUpRules',\n        };\n    }\n    static types() {\n        return {\n            maxReplicas: 'number',\n            metrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRuleResponseBodyDataMetricMetrics },\n            metricsStatus: DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus,\n            minReplicas: 'number',\n            scaleDownRules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules,\n            scaleUpRules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataMetric = DescribeApplicationScalingRuleResponseBodyDataMetric;\nclass DescribeApplicationScalingRuleResponseBodyDataTimerSchedules extends $tea.Model {\n    static names() {\n        return {\n            atTime: 'AtTime',\n            maxReplicas: 'MaxReplicas',\n            minReplicas: 'MinReplicas',\n            targetReplicas: 'TargetReplicas',\n        };\n    }\n    static types() {\n        return {\n            atTime: 'string',\n            maxReplicas: 'number',\n            minReplicas: 'number',\n            targetReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataTimerSchedules = DescribeApplicationScalingRuleResponseBodyDataTimerSchedules;\nclass DescribeApplicationScalingRuleResponseBodyDataTimer extends $tea.Model {\n    static names() {\n        return {\n            beginDate: 'BeginDate',\n            endDate: 'EndDate',\n            period: 'Period',\n            schedules: 'Schedules',\n        };\n    }\n    static types() {\n        return {\n            beginDate: 'string',\n            endDate: 'string',\n            period: 'string',\n            schedules: { 'type': 'array', 'itemType': DescribeApplicationScalingRuleResponseBodyDataTimerSchedules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyDataTimer = DescribeApplicationScalingRuleResponseBodyDataTimer;\nclass DescribeApplicationScalingRuleResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            createTime: 'CreateTime',\n            lastDisableTime: 'LastDisableTime',\n            metric: 'Metric',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            scaleRuleEnabled: 'ScaleRuleEnabled',\n            scaleRuleName: 'ScaleRuleName',\n            scaleRuleType: 'ScaleRuleType',\n            timer: 'Timer',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            createTime: 'number',\n            lastDisableTime: 'number',\n            metric: DescribeApplicationScalingRuleResponseBodyDataMetric,\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            scaleRuleEnabled: 'boolean',\n            scaleRuleName: 'string',\n            scaleRuleType: 'string',\n            timer: DescribeApplicationScalingRuleResponseBodyDataTimer,\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRuleResponseBodyData = DescribeApplicationScalingRuleResponseBodyData;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics extends $tea.Model {\n    static names() {\n        return {\n            metricTargetAverageUtilization: 'MetricTargetAverageUtilization',\n            metricType: 'MetricType',\n            slbId: 'SlbId',\n            slbLogstore: 'SlbLogstore',\n            slbProject: 'SlbProject',\n            vport: 'Vport',\n        };\n    }\n    static types() {\n        return {\n            metricTargetAverageUtilization: 'number',\n            metricType: 'string',\n            slbId: 'string',\n            slbLogstore: 'string',\n            slbProject: 'string',\n            vport: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics extends $tea.Model {\n    static names() {\n        return {\n            currentValue: 'CurrentValue',\n            name: 'Name',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            currentValue: 'number',\n            name: 'string',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            nextScaleInAverageUtilization: 'NextScaleInAverageUtilization',\n            nextScaleOutAverageUtilization: 'NextScaleOutAverageUtilization',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            nextScaleInAverageUtilization: 'number',\n            nextScaleOutAverageUtilization: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus extends $tea.Model {\n    static names() {\n        return {\n            currentMetrics: 'CurrentMetrics',\n            currentReplicas: 'CurrentReplicas',\n            desiredReplicas: 'DesiredReplicas',\n            lastScaleTime: 'LastScaleTime',\n            maxReplicas: 'MaxReplicas',\n            minReplicas: 'MinReplicas',\n            nextScaleMetrics: 'NextScaleMetrics',\n            nextScaleTimePeriod: 'NextScaleTimePeriod',\n        };\n    }\n    static types() {\n        return {\n            currentMetrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics },\n            currentReplicas: 'number',\n            desiredReplicas: 'number',\n            lastScaleTime: 'string',\n            maxReplicas: 'number',\n            minReplicas: 'number',\n            nextScaleMetrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics },\n            nextScaleTimePeriod: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules extends $tea.Model {\n    static names() {\n        return {\n            disabled: 'Disabled',\n            stabilizationWindowSeconds: 'StabilizationWindowSeconds',\n            step: 'Step',\n        };\n    }\n    static types() {\n        return {\n            disabled: 'boolean',\n            stabilizationWindowSeconds: 'number',\n            step: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules extends $tea.Model {\n    static names() {\n        return {\n            disabled: 'Disabled',\n            stabilizationWindowSeconds: 'StabilizationWindowSeconds',\n            step: 'Step',\n        };\n    }\n    static types() {\n        return {\n            disabled: 'boolean',\n            stabilizationWindowSeconds: 'number',\n            step: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric extends $tea.Model {\n    static names() {\n        return {\n            maxReplicas: 'MaxReplicas',\n            metrics: 'Metrics',\n            metricsStatus: 'MetricsStatus',\n            minReplicas: 'MinReplicas',\n            scaleDownRules: 'ScaleDownRules',\n            scaleUpRules: 'ScaleUpRules',\n        };\n    }\n    static types() {\n        return {\n            maxReplicas: 'number',\n            metrics: { 'type': 'array', 'itemType': DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics },\n            metricsStatus: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus,\n            minReplicas: 'number',\n            scaleDownRules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules,\n            scaleUpRules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules extends $tea.Model {\n    static names() {\n        return {\n            atTime: 'AtTime',\n            maxReplicas: 'MaxReplicas',\n            minReplicas: 'MinReplicas',\n            targetReplicas: 'TargetReplicas',\n        };\n    }\n    static types() {\n        return {\n            atTime: 'string',\n            maxReplicas: 'number',\n            minReplicas: 'number',\n            targetReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer extends $tea.Model {\n    static names() {\n        return {\n            beginDate: 'BeginDate',\n            endDate: 'EndDate',\n            period: 'Period',\n            schedules: 'Schedules',\n        };\n    }\n    static types() {\n        return {\n            beginDate: 'string',\n            endDate: 'string',\n            period: 'string',\n            schedules: { 'type': 'array', 'itemType': DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer;\nclass DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            createTime: 'CreateTime',\n            lastDisableTime: 'LastDisableTime',\n            metric: 'Metric',\n            minReadyInstanceRatio: 'MinReadyInstanceRatio',\n            minReadyInstances: 'MinReadyInstances',\n            scaleRuleEnabled: 'ScaleRuleEnabled',\n            scaleRuleName: 'ScaleRuleName',\n            scaleRuleType: 'ScaleRuleType',\n            timer: 'Timer',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            createTime: 'number',\n            lastDisableTime: 'number',\n            metric: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric,\n            minReadyInstanceRatio: 'number',\n            minReadyInstances: 'number',\n            scaleRuleEnabled: 'boolean',\n            scaleRuleName: 'string',\n            scaleRuleType: 'string',\n            timer: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer,\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules;\nclass DescribeApplicationScalingRulesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            applicationScalingRules: 'ApplicationScalingRules',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            applicationScalingRules: { 'type': 'array', 'itemType': DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationScalingRulesResponseBodyData = DescribeApplicationScalingRulesResponseBodyData;\nclass DescribeApplicationSlbsResponseBodyDataInternet extends $tea.Model {\n    static names() {\n        return {\n            cookie: 'Cookie',\n            cookieTimeout: 'CookieTimeout',\n            httpsCaCertId: 'HttpsCaCertId',\n            httpsCertId: 'HttpsCertId',\n            port: 'Port',\n            protocol: 'Protocol',\n            stickySession: 'StickySession',\n            stickySessionType: 'StickySessionType',\n            targetPort: 'TargetPort',\n        };\n    }\n    static types() {\n        return {\n            cookie: 'string',\n            cookieTimeout: 'number',\n            httpsCaCertId: 'string',\n            httpsCertId: 'string',\n            port: 'number',\n            protocol: 'string',\n            stickySession: 'boolean',\n            stickySessionType: 'string',\n            targetPort: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsResponseBodyDataInternet = DescribeApplicationSlbsResponseBodyDataInternet;\nclass DescribeApplicationSlbsResponseBodyDataIntranet extends $tea.Model {\n    static names() {\n        return {\n            cookie: 'Cookie',\n            cookieTimeout: 'CookieTimeout',\n            httpsCaCertId: 'HttpsCaCertId',\n            httpsCertId: 'HttpsCertId',\n            port: 'Port',\n            protocol: 'Protocol',\n            stickySession: 'StickySession',\n            stickySessionType: 'StickySessionType',\n            targetPort: 'TargetPort',\n        };\n    }\n    static types() {\n        return {\n            cookie: 'string',\n            cookieTimeout: 'number',\n            httpsCaCertId: 'string',\n            httpsCertId: 'string',\n            port: 'number',\n            protocol: 'string',\n            stickySession: 'boolean',\n            stickySessionType: 'string',\n            targetPort: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsResponseBodyDataIntranet = DescribeApplicationSlbsResponseBodyDataIntranet;\nclass DescribeApplicationSlbsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            internet: 'Internet',\n            internetIp: 'InternetIp',\n            internetSlbChargeType: 'InternetSlbChargeType',\n            internetSlbExpired: 'InternetSlbExpired',\n            internetSlbId: 'InternetSlbId',\n            intranet: 'Intranet',\n            intranetIp: 'IntranetIp',\n            intranetSlbChargeType: 'IntranetSlbChargeType',\n            intranetSlbExpired: 'IntranetSlbExpired',\n            intranetSlbId: 'IntranetSlbId',\n        };\n    }\n    static types() {\n        return {\n            internet: { 'type': 'array', 'itemType': DescribeApplicationSlbsResponseBodyDataInternet },\n            internetIp: 'string',\n            internetSlbChargeType: 'string',\n            internetSlbExpired: 'boolean',\n            internetSlbId: 'string',\n            intranet: { 'type': 'array', 'itemType': DescribeApplicationSlbsResponseBodyDataIntranet },\n            intranetIp: 'string',\n            intranetSlbChargeType: 'string',\n            intranetSlbExpired: 'boolean',\n            intranetSlbId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationSlbsResponseBodyData = DescribeApplicationSlbsResponseBodyData;\nclass DescribeApplicationStatusResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            armsAdvancedEnabled: 'ArmsAdvancedEnabled',\n            armsApmInfo: 'ArmsApmInfo',\n            createTime: 'CreateTime',\n            currentStatus: 'CurrentStatus',\n            enableAgent: 'EnableAgent',\n            fileSizeLimit: 'FileSizeLimit',\n            lastChangeOrderId: 'LastChangeOrderId',\n            lastChangeOrderRunning: 'LastChangeOrderRunning',\n            lastChangeOrderStatus: 'LastChangeOrderStatus',\n            runningInstances: 'RunningInstances',\n            subStatus: 'SubStatus',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            armsAdvancedEnabled: 'string',\n            armsApmInfo: 'string',\n            createTime: 'string',\n            currentStatus: 'string',\n            enableAgent: 'boolean',\n            fileSizeLimit: 'number',\n            lastChangeOrderId: 'string',\n            lastChangeOrderRunning: 'boolean',\n            lastChangeOrderStatus: 'string',\n            runningInstances: 'number',\n            subStatus: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeApplicationStatusResponseBodyData = DescribeApplicationStatusResponseBodyData;\nclass DescribeChangeOrderResponseBodyDataPipelines extends $tea.Model {\n    static names() {\n        return {\n            batchType: 'BatchType',\n            parallelCount: 'ParallelCount',\n            pipelineId: 'PipelineId',\n            pipelineName: 'PipelineName',\n            startTime: 'StartTime',\n            status: 'Status',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            batchType: 'number',\n            parallelCount: 'number',\n            pipelineId: 'string',\n            pipelineName: 'string',\n            startTime: 'number',\n            status: 'number',\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeChangeOrderResponseBodyDataPipelines = DescribeChangeOrderResponseBodyDataPipelines;\nclass DescribeChangeOrderResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n            approvalId: 'ApprovalId',\n            auto: 'Auto',\n            batchCount: 'BatchCount',\n            batchType: 'BatchType',\n            batchWaitTime: 'BatchWaitTime',\n            changeOrderId: 'ChangeOrderId',\n            coType: 'CoType',\n            coTypeCode: 'CoTypeCode',\n            createTime: 'CreateTime',\n            currentPipelineId: 'CurrentPipelineId',\n            description: 'Description',\n            errorMessage: 'ErrorMessage',\n            pipelines: 'Pipelines',\n            status: 'Status',\n            subStatus: 'SubStatus',\n            supportRollback: 'SupportRollback',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n            approvalId: 'string',\n            auto: 'boolean',\n            batchCount: 'number',\n            batchType: 'string',\n            batchWaitTime: 'number',\n            changeOrderId: 'string',\n            coType: 'string',\n            coTypeCode: 'string',\n            createTime: 'string',\n            currentPipelineId: 'string',\n            description: 'string',\n            errorMessage: 'string',\n            pipelines: { 'type': 'array', 'itemType': DescribeChangeOrderResponseBodyDataPipelines },\n            status: 'number',\n            subStatus: 'number',\n            supportRollback: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeChangeOrderResponseBodyData = DescribeChangeOrderResponseBodyData;\nclass DescribeComponentsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            componentDescription: 'ComponentDescription',\n            componentKey: 'ComponentKey',\n            expired: 'Expired',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            componentDescription: 'string',\n            componentKey: 'string',\n            expired: 'boolean',\n            type: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeComponentsResponseBodyData = DescribeComponentsResponseBodyData;\nclass DescribeConfigMapResponseBodyDataRelateApps extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigMapResponseBodyDataRelateApps = DescribeConfigMapResponseBodyDataRelateApps;\nclass DescribeConfigMapResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n            createTime: 'CreateTime',\n            data: 'Data',\n            description: 'Description',\n            name: 'Name',\n            namespaceId: 'NamespaceId',\n            relateApps: 'RelateApps',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n            createTime: 'number',\n            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },\n            description: 'string',\n            name: 'string',\n            namespaceId: 'string',\n            relateApps: { 'type': 'array', 'itemType': DescribeConfigMapResponseBodyDataRelateApps },\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigMapResponseBodyData = DescribeConfigMapResponseBodyData;\nclass DescribeConfigurationPriceResponseBodyDataBagUsage extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            mem: 'Mem',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            mem: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataBagUsage = DescribeConfigurationPriceResponseBodyDataBagUsage;\nclass DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder extends $tea.Model {\n    static names() {\n        return {\n            discountAmount: 'DiscountAmount',\n            originalAmount: 'OriginalAmount',\n            ruleIds: 'RuleIds',\n            tradeAmount: 'TradeAmount',\n        };\n    }\n    static types() {\n        return {\n            discountAmount: 'number',\n            originalAmount: 'number',\n            ruleIds: { 'type': 'array', 'itemType': 'string' },\n            tradeAmount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder = DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder;\nclass DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            ruleDescId: 'RuleDescId',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            ruleDescId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules = DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules;\nclass DescribeConfigurationPriceResponseBodyDataCpuMemPrice extends $tea.Model {\n    static names() {\n        return {\n            order: 'Order',\n            rules: 'Rules',\n        };\n    }\n    static types() {\n        return {\n            order: DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder,\n            rules: { 'type': 'array', 'itemType': DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataCpuMemPrice = DescribeConfigurationPriceResponseBodyDataCpuMemPrice;\nclass DescribeConfigurationPriceResponseBodyDataOrder extends $tea.Model {\n    static names() {\n        return {\n            discountAmount: 'DiscountAmount',\n            originalAmount: 'OriginalAmount',\n            ruleIds: 'RuleIds',\n            tradeAmount: 'TradeAmount',\n        };\n    }\n    static types() {\n        return {\n            discountAmount: 'number',\n            originalAmount: 'number',\n            ruleIds: { 'type': 'array', 'itemType': 'string' },\n            tradeAmount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataOrder = DescribeConfigurationPriceResponseBodyDataOrder;\nclass DescribeConfigurationPriceResponseBodyDataRequestPriceOrder extends $tea.Model {\n    static names() {\n        return {\n            discountAmount: 'DiscountAmount',\n            originalAmount: 'OriginalAmount',\n            ruleIds: 'RuleIds',\n            tradeAmount: 'TradeAmount',\n        };\n    }\n    static types() {\n        return {\n            discountAmount: 'number',\n            originalAmount: 'number',\n            ruleIds: { 'type': 'array', 'itemType': 'string' },\n            tradeAmount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataRequestPriceOrder = DescribeConfigurationPriceResponseBodyDataRequestPriceOrder;\nclass DescribeConfigurationPriceResponseBodyDataRequestPriceRules extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            ruleDescId: 'RuleDescId',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            ruleDescId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataRequestPriceRules = DescribeConfigurationPriceResponseBodyDataRequestPriceRules;\nclass DescribeConfigurationPriceResponseBodyDataRequestPrice extends $tea.Model {\n    static names() {\n        return {\n            order: 'Order',\n            rules: 'Rules',\n        };\n    }\n    static types() {\n        return {\n            order: DescribeConfigurationPriceResponseBodyDataRequestPriceOrder,\n            rules: { 'type': 'array', 'itemType': DescribeConfigurationPriceResponseBodyDataRequestPriceRules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataRequestPrice = DescribeConfigurationPriceResponseBodyDataRequestPrice;\nclass DescribeConfigurationPriceResponseBodyDataRules extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            ruleDescId: 'RuleDescId',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            ruleDescId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataRules = DescribeConfigurationPriceResponseBodyDataRules;\nclass DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder extends $tea.Model {\n    static names() {\n        return {\n            discountAmount: 'DiscountAmount',\n            originalAmount: 'OriginalAmount',\n            ruleIds: 'RuleIds',\n            tradeAmount: 'TradeAmount',\n        };\n    }\n    static types() {\n        return {\n            discountAmount: 'number',\n            originalAmount: 'number',\n            ruleIds: { 'type': 'array', 'itemType': 'string' },\n            tradeAmount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder = DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder;\nclass DescribeConfigurationPriceResponseBodyDataTrafficPriceRules extends $tea.Model {\n    static names() {\n        return {\n            name: 'Name',\n            ruleDescId: 'RuleDescId',\n        };\n    }\n    static types() {\n        return {\n            name: 'string',\n            ruleDescId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataTrafficPriceRules = DescribeConfigurationPriceResponseBodyDataTrafficPriceRules;\nclass DescribeConfigurationPriceResponseBodyDataTrafficPrice extends $tea.Model {\n    static names() {\n        return {\n            order: 'Order',\n            rules: 'Rules',\n        };\n    }\n    static types() {\n        return {\n            order: DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder,\n            rules: { 'type': 'array', 'itemType': DescribeConfigurationPriceResponseBodyDataTrafficPriceRules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyDataTrafficPrice = DescribeConfigurationPriceResponseBodyDataTrafficPrice;\nclass DescribeConfigurationPriceResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            bagUsage: 'BagUsage',\n            cpuMemPrice: 'CpuMemPrice',\n            order: 'Order',\n            requestPrice: 'RequestPrice',\n            rules: 'Rules',\n            trafficPrice: 'TrafficPrice',\n        };\n    }\n    static types() {\n        return {\n            bagUsage: DescribeConfigurationPriceResponseBodyDataBagUsage,\n            cpuMemPrice: DescribeConfigurationPriceResponseBodyDataCpuMemPrice,\n            order: DescribeConfigurationPriceResponseBodyDataOrder,\n            requestPrice: DescribeConfigurationPriceResponseBodyDataRequestPrice,\n            rules: { 'type': 'array', 'itemType': DescribeConfigurationPriceResponseBodyDataRules },\n            trafficPrice: DescribeConfigurationPriceResponseBodyDataTrafficPrice,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeConfigurationPriceResponseBodyData = DescribeConfigurationPriceResponseBodyData;\nclass DescribeEdasContainersResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            disabled: 'Disabled',\n            edasContainerVersion: 'EdasContainerVersion',\n        };\n    }\n    static types() {\n        return {\n            disabled: 'boolean',\n            edasContainerVersion: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeEdasContainersResponseBodyData = DescribeEdasContainersResponseBodyData;\nclass DescribeGreyTagRouteResponseBodyDataAlbRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataAlbRulesItems = DescribeGreyTagRouteResponseBodyDataAlbRulesItems;\nclass DescribeGreyTagRouteResponseBodyDataAlbRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            ingressId: 'ingressId',\n            items: 'items',\n            serviceId: 'serviceId',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            ingressId: 'string',\n            items: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataAlbRulesItems },\n            serviceId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataAlbRules = DescribeGreyTagRouteResponseBodyDataAlbRules;\nclass DescribeGreyTagRouteResponseBodyDataDubboRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataDubboRulesItems = DescribeGreyTagRouteResponseBodyDataDubboRulesItems;\nclass DescribeGreyTagRouteResponseBodyDataDubboRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            group: 'group',\n            items: 'items',\n            methodName: 'methodName',\n            serviceName: 'serviceName',\n            version: 'version',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            group: 'string',\n            items: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataDubboRulesItems },\n            methodName: 'string',\n            serviceName: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataDubboRules = DescribeGreyTagRouteResponseBodyDataDubboRules;\nclass DescribeGreyTagRouteResponseBodyDataScRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataScRulesItems = DescribeGreyTagRouteResponseBodyDataScRulesItems;\nclass DescribeGreyTagRouteResponseBodyDataScRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            items: 'items',\n            path: 'path',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            items: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataScRulesItems },\n            path: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyDataScRules = DescribeGreyTagRouteResponseBodyDataScRules;\nclass DescribeGreyTagRouteResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            albRules: 'AlbRules',\n            appId: 'AppId',\n            createTime: 'CreateTime',\n            description: 'Description',\n            dubboRules: 'DubboRules',\n            greyTagRouteId: 'GreyTagRouteId',\n            name: 'Name',\n            scRules: 'ScRules',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            albRules: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataAlbRules },\n            appId: 'string',\n            createTime: 'number',\n            description: 'string',\n            dubboRules: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataDubboRules },\n            greyTagRouteId: 'number',\n            name: 'string',\n            scRules: { 'type': 'array', 'itemType': DescribeGreyTagRouteResponseBodyDataScRules },\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeGreyTagRouteResponseBodyData = DescribeGreyTagRouteResponseBodyData;\nclass DescribeIngressResponseBodyDataDefaultRule extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n            backendProtocol: 'BackendProtocol',\n            containerPort: 'ContainerPort',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n            backendProtocol: 'string',\n            containerPort: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressResponseBodyDataDefaultRule = DescribeIngressResponseBodyDataDefaultRule;\nclass DescribeIngressResponseBodyDataRules extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n            backendProtocol: 'BackendProtocol',\n            containerPort: 'ContainerPort',\n            domain: 'Domain',\n            path: 'Path',\n            rewritePath: 'RewritePath',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n            backendProtocol: 'string',\n            containerPort: 'number',\n            domain: 'string',\n            path: 'string',\n            rewritePath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressResponseBodyDataRules = DescribeIngressResponseBodyDataRules;\nclass DescribeIngressResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            certId: 'CertId',\n            certIds: 'CertIds',\n            defaultRule: 'DefaultRule',\n            description: 'Description',\n            id: 'Id',\n            listenerPort: 'ListenerPort',\n            listenerProtocol: 'ListenerProtocol',\n            loadBalanceType: 'LoadBalanceType',\n            name: 'Name',\n            namespaceId: 'NamespaceId',\n            requestTimeout: 'RequestTimeout',\n            rules: 'Rules',\n            securityPolicyId: 'SecurityPolicyId',\n            slbId: 'SlbId',\n            slbType: 'SlbType',\n        };\n    }\n    static types() {\n        return {\n            certId: 'string',\n            certIds: 'string',\n            defaultRule: DescribeIngressResponseBodyDataDefaultRule,\n            description: 'string',\n            id: 'number',\n            listenerPort: 'number',\n            listenerProtocol: 'string',\n            loadBalanceType: 'string',\n            name: 'string',\n            namespaceId: 'string',\n            requestTimeout: 'number',\n            rules: { 'type': 'array', 'itemType': DescribeIngressResponseBodyDataRules },\n            securityPolicyId: 'string',\n            slbId: 'string',\n            slbType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeIngressResponseBodyData = DescribeIngressResponseBodyData;\nclass DescribeInstanceSpecificationsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            enable: 'Enable',\n            id: 'Id',\n            memory: 'Memory',\n            specInfo: 'SpecInfo',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            enable: 'boolean',\n            id: 'number',\n            memory: 'number',\n            specInfo: 'string',\n            version: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeInstanceSpecificationsResponseBodyData = DescribeInstanceSpecificationsResponseBodyData;\nclass DescribeJobResponseBodyDataConfigMapMountDesc extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n            configMapName: 'ConfigMapName',\n            key: 'Key',\n            mountPath: 'MountPath',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n            configMapName: 'string',\n            key: 'string',\n            mountPath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBodyDataConfigMapMountDesc = DescribeJobResponseBodyDataConfigMapMountDesc;\nclass DescribeJobResponseBodyDataMountDesc extends $tea.Model {\n    static names() {\n        return {\n            mountPath: 'MountPath',\n            nasPath: 'NasPath',\n        };\n    }\n    static types() {\n        return {\n            mountPath: 'string',\n            nasPath: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBodyDataMountDesc = DescribeJobResponseBodyDataMountDesc;\nclass DescribeJobResponseBodyDataOssMountDescs extends $tea.Model {\n    static names() {\n        return {\n            bucketName: 'bucketName',\n            bucketPath: 'bucketPath',\n            mountPath: 'mountPath',\n            readOnly: 'readOnly',\n        };\n    }\n    static types() {\n        return {\n            bucketName: 'string',\n            bucketPath: 'string',\n            mountPath: 'string',\n            readOnly: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBodyDataOssMountDescs = DescribeJobResponseBodyDataOssMountDescs;\nclass DescribeJobResponseBodyDataTags extends $tea.Model {\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBodyDataTags = DescribeJobResponseBodyDataTags;\nclass DescribeJobResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            acrAssumeRoleArn: 'AcrAssumeRoleArn',\n            acrInstanceId: 'AcrInstanceId',\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n            appName: 'AppName',\n            backoffLimit: 'BackoffLimit',\n            command: 'Command',\n            commandArgs: 'CommandArgs',\n            concurrencyPolicy: 'ConcurrencyPolicy',\n            configMapMountDesc: 'ConfigMapMountDesc',\n            cpu: 'Cpu',\n            customHostAlias: 'CustomHostAlias',\n            edasContainerVersion: 'EdasContainerVersion',\n            envs: 'Envs',\n            imagePullSecrets: 'ImagePullSecrets',\n            imageUrl: 'ImageUrl',\n            jarStartArgs: 'JarStartArgs',\n            jarStartOptions: 'JarStartOptions',\n            jdk: 'Jdk',\n            memory: 'Memory',\n            mountDesc: 'MountDesc',\n            mountHost: 'MountHost',\n            namespaceId: 'NamespaceId',\n            nasConfigs: 'NasConfigs',\n            nasId: 'NasId',\n            ossAkId: 'OssAkId',\n            ossAkSecret: 'OssAkSecret',\n            ossMountDescs: 'OssMountDescs',\n            packageType: 'PackageType',\n            packageUrl: 'PackageUrl',\n            packageVersion: 'PackageVersion',\n            phpConfig: 'PhpConfig',\n            phpConfigLocation: 'PhpConfigLocation',\n            postStart: 'PostStart',\n            preStop: 'PreStop',\n            programmingLanguage: 'ProgrammingLanguage',\n            publicWebHookUrls: 'PublicWebHookUrls',\n            python: 'Python',\n            pythonModules: 'PythonModules',\n            refAppId: 'RefAppId',\n            refedAppIds: 'RefedAppIds',\n            regionId: 'RegionId',\n            replicas: 'Replicas',\n            securityGroupId: 'SecurityGroupId',\n            slice: 'Slice',\n            sliceEnvs: 'SliceEnvs',\n            slsConfigs: 'SlsConfigs',\n            suspend: 'Suspend',\n            tags: 'Tags',\n            terminationGracePeriodSeconds: 'TerminationGracePeriodSeconds',\n            timeout: 'Timeout',\n            timezone: 'Timezone',\n            tomcatConfig: 'TomcatConfig',\n            triggerConfig: 'TriggerConfig',\n            vSwitchId: 'VSwitchId',\n            vpcId: 'VpcId',\n            vpcWebHookUrls: 'VpcWebHookUrls',\n            warStartOptions: 'WarStartOptions',\n            webContainer: 'WebContainer',\n        };\n    }\n    static types() {\n        return {\n            acrAssumeRoleArn: 'string',\n            acrInstanceId: 'string',\n            appDescription: 'string',\n            appId: 'string',\n            appName: 'string',\n            backoffLimit: 'number',\n            command: 'string',\n            commandArgs: 'string',\n            concurrencyPolicy: 'string',\n            configMapMountDesc: { 'type': 'array', 'itemType': DescribeJobResponseBodyDataConfigMapMountDesc },\n            cpu: 'number',\n            customHostAlias: 'string',\n            edasContainerVersion: 'string',\n            envs: 'string',\n            imagePullSecrets: 'string',\n            imageUrl: 'string',\n            jarStartArgs: 'string',\n            jarStartOptions: 'string',\n            jdk: 'string',\n            memory: 'number',\n            mountDesc: { 'type': 'array', 'itemType': DescribeJobResponseBodyDataMountDesc },\n            mountHost: 'string',\n            namespaceId: 'string',\n            nasConfigs: 'string',\n            nasId: 'string',\n            ossAkId: 'string',\n            ossAkSecret: 'string',\n            ossMountDescs: { 'type': 'array', 'itemType': DescribeJobResponseBodyDataOssMountDescs },\n            packageType: 'string',\n            packageUrl: 'string',\n            packageVersion: 'string',\n            phpConfig: 'string',\n            phpConfigLocation: 'string',\n            postStart: 'string',\n            preStop: 'string',\n            programmingLanguage: 'string',\n            publicWebHookUrls: { 'type': 'array', 'itemType': 'string' },\n            python: 'string',\n            pythonModules: 'string',\n            refAppId: 'string',\n            refedAppIds: { 'type': 'array', 'itemType': 'string' },\n            regionId: 'string',\n            replicas: 'number',\n            securityGroupId: 'string',\n            slice: 'boolean',\n            sliceEnvs: 'string',\n            slsConfigs: 'string',\n            suspend: 'boolean',\n            tags: { 'type': 'array', 'itemType': DescribeJobResponseBodyDataTags },\n            terminationGracePeriodSeconds: 'number',\n            timeout: 'number',\n            timezone: 'string',\n            tomcatConfig: 'string',\n            triggerConfig: 'string',\n            vSwitchId: 'string',\n            vpcId: 'string',\n            vpcWebHookUrls: { 'type': 'array', 'itemType': 'string' },\n            warStartOptions: 'string',\n            webContainer: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobResponseBodyData = DescribeJobResponseBodyData;\nclass DescribeJobHistoryResponseBodyDataJobs extends $tea.Model {\n    static names() {\n        return {\n            active: 'Active',\n            completionTime: 'CompletionTime',\n            failed: 'Failed',\n            jobId: 'JobId',\n            message: 'Message',\n            startTime: 'StartTime',\n            state: 'State',\n            succeeded: 'Succeeded',\n        };\n    }\n    static types() {\n        return {\n            active: 'number',\n            completionTime: 'number',\n            failed: 'number',\n            jobId: 'string',\n            message: 'string',\n            startTime: 'number',\n            state: 'string',\n            succeeded: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobHistoryResponseBodyDataJobs = DescribeJobHistoryResponseBodyDataJobs;\nclass DescribeJobHistoryResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            jobs: 'Jobs',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            jobs: { 'type': 'array', 'itemType': DescribeJobHistoryResponseBodyDataJobs },\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobHistoryResponseBodyData = DescribeJobHistoryResponseBodyData;\nclass DescribeJobStatusResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            active: 'Active',\n            completionTime: 'CompletionTime',\n            failed: 'Failed',\n            jobId: 'JobId',\n            message: 'Message',\n            startTime: 'StartTime',\n            state: 'State',\n            succeeded: 'Succeeded',\n        };\n    }\n    static types() {\n        return {\n            active: 'number',\n            completionTime: 'number',\n            failed: 'number',\n            jobId: 'string',\n            message: 'string',\n            startTime: 'number',\n            state: 'string',\n            succeeded: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeJobStatusResponseBodyData = DescribeJobStatusResponseBodyData;\nclass DescribeNamespaceResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            enableMicroRegistration: 'EnableMicroRegistration',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            enableMicroRegistration: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResponseBodyData = DescribeNamespaceResponseBodyData;\nclass DescribeNamespaceListResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            agentInstall: 'AgentInstall',\n            current: 'Current',\n            custom: 'Custom',\n            hybridCloudEnable: 'HybridCloudEnable',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            regionId: 'RegionId',\n            securityGroupId: 'SecurityGroupId',\n            vSwitchId: 'VSwitchId',\n            vpcId: 'VpcId',\n        };\n    }\n    static types() {\n        return {\n            agentInstall: 'string',\n            current: 'boolean',\n            custom: 'boolean',\n            hybridCloudEnable: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            regionId: 'string',\n            securityGroupId: 'string',\n            vSwitchId: 'string',\n            vpcId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceListResponseBodyData = DescribeNamespaceListResponseBodyData;\nclass DescribeNamespaceResourcesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appCount: 'AppCount',\n            belongRegion: 'BelongRegion',\n            description: 'Description',\n            jumpServerAppId: 'JumpServerAppId',\n            jumpServerIp: 'JumpServerIp',\n            lastChangeOrderId: 'LastChangeOrderId',\n            lastChangeOrderRunning: 'LastChangeOrderRunning',\n            lastChangeOrderStatus: 'LastChangeOrderStatus',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            notificationExpired: 'NotificationExpired',\n            securityGroupId: 'SecurityGroupId',\n            tenantId: 'TenantId',\n            userId: 'UserId',\n            vSwitchId: 'VSwitchId',\n            vSwitchName: 'VSwitchName',\n            vpcId: 'VpcId',\n            vpcName: 'VpcName',\n        };\n    }\n    static types() {\n        return {\n            appCount: 'number',\n            belongRegion: 'string',\n            description: 'string',\n            jumpServerAppId: 'string',\n            jumpServerIp: 'string',\n            lastChangeOrderId: 'string',\n            lastChangeOrderRunning: 'boolean',\n            lastChangeOrderStatus: 'string',\n            nameSpaceShortId: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            notificationExpired: 'boolean',\n            securityGroupId: 'string',\n            tenantId: 'string',\n            userId: 'string',\n            vSwitchId: 'string',\n            vSwitchName: 'string',\n            vpcId: 'string',\n            vpcName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespaceResourcesResponseBodyData = DescribeNamespaceResourcesResponseBodyData;\nclass DescribeNamespacesResponseBodyDataNamespaces extends $tea.Model {\n    static names() {\n        return {\n            accessKey: 'AccessKey',\n            addressServerHost: 'AddressServerHost',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            regionId: 'RegionId',\n            secretKey: 'SecretKey',\n            tenantId: 'TenantId',\n        };\n    }\n    static types() {\n        return {\n            accessKey: 'string',\n            addressServerHost: 'string',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            regionId: 'string',\n            secretKey: 'string',\n            tenantId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespacesResponseBodyDataNamespaces = DescribeNamespacesResponseBodyDataNamespaces;\nclass DescribeNamespacesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            namespaces: 'Namespaces',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            namespaces: { 'type': 'array', 'itemType': DescribeNamespacesResponseBodyDataNamespaces },\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeNamespacesResponseBodyData = DescribeNamespacesResponseBodyData;\nclass DescribePipelineResponseBodyDataStageListTaskList extends $tea.Model {\n    static names() {\n        return {\n            errorCode: 'ErrorCode',\n            errorIgnore: 'ErrorIgnore',\n            errorMessage: 'ErrorMessage',\n            message: 'Message',\n            showManualIgnore: 'ShowManualIgnore',\n            stageId: 'StageId',\n            status: 'Status',\n            taskId: 'TaskId',\n            taskName: 'TaskName',\n        };\n    }\n    static types() {\n        return {\n            errorCode: 'string',\n            errorIgnore: 'number',\n            errorMessage: 'string',\n            message: 'string',\n            showManualIgnore: 'boolean',\n            stageId: 'string',\n            status: 'number',\n            taskId: 'string',\n            taskName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineResponseBodyDataStageListTaskList = DescribePipelineResponseBodyDataStageListTaskList;\nclass DescribePipelineResponseBodyDataStageList extends $tea.Model {\n    static names() {\n        return {\n            executorType: 'ExecutorType',\n            stageId: 'StageId',\n            stageName: 'StageName',\n            status: 'Status',\n            taskList: 'TaskList',\n        };\n    }\n    static types() {\n        return {\n            executorType: 'number',\n            stageId: 'string',\n            stageName: 'string',\n            status: 'number',\n            taskList: { 'type': 'array', 'itemType': DescribePipelineResponseBodyDataStageListTaskList },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineResponseBodyDataStageList = DescribePipelineResponseBodyDataStageList;\nclass DescribePipelineResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            coStatus: 'CoStatus',\n            currentStageId: 'CurrentStageId',\n            nextPipelineId: 'NextPipelineId',\n            pipelineId: 'PipelineId',\n            pipelineName: 'PipelineName',\n            pipelineStatus: 'PipelineStatus',\n            showBatch: 'ShowBatch',\n            stageList: 'StageList',\n        };\n    }\n    static types() {\n        return {\n            coStatus: 'string',\n            currentStageId: 'string',\n            nextPipelineId: 'string',\n            pipelineId: 'string',\n            pipelineName: 'string',\n            pipelineStatus: 'number',\n            showBatch: 'boolean',\n            stageList: { 'type': 'array', 'itemType': DescribePipelineResponseBodyDataStageList },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribePipelineResponseBodyData = DescribePipelineResponseBodyData;\nclass DescribeRegionsResponseBodyRegionsRegionRecommendZones extends $tea.Model {\n    static names() {\n        return {\n            recommendZone: 'RecommendZone',\n        };\n    }\n    static types() {\n        return {\n            recommendZone: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeRegionsResponseBodyRegionsRegionRecommendZones = DescribeRegionsResponseBodyRegionsRegionRecommendZones;\nclass DescribeRegionsResponseBodyRegionsRegion extends $tea.Model {\n    static names() {\n        return {\n            localName: 'LocalName',\n            recommendZones: 'RecommendZones',\n            regionEndpoint: 'RegionEndpoint',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            localName: 'string',\n            recommendZones: DescribeRegionsResponseBodyRegionsRegionRecommendZones,\n            regionEndpoint: 'string',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeRegionsResponseBodyRegionsRegion = DescribeRegionsResponseBodyRegionsRegion;\nclass DescribeRegionsResponseBodyRegions extends $tea.Model {\n    static names() {\n        return {\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            region: { 'type': 'array', 'itemType': DescribeRegionsResponseBodyRegionsRegion },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeRegionsResponseBodyRegions = DescribeRegionsResponseBodyRegions;\nclass DescribeSecretResponseBodyDataRelateApps extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeSecretResponseBodyDataRelateApps = DescribeSecretResponseBodyDataRelateApps;\nclass DescribeSecretResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            namespaceId: 'NamespaceId',\n            relateApps: 'RelateApps',\n            secretData: 'SecretData',\n            secretId: 'SecretId',\n            secretName: 'SecretName',\n            secretType: 'SecretType',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'number',\n            namespaceId: 'string',\n            relateApps: { 'type': 'array', 'itemType': DescribeSecretResponseBodyDataRelateApps },\n            secretData: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            secretId: 'number',\n            secretName: 'string',\n            secretType: 'string',\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.DescribeSecretResponseBodyData = DescribeSecretResponseBodyData;\nclass ExecJobResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            code: 'Code',\n            data: 'Data',\n            msg: 'Msg',\n            success: 'Success',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            data: 'string',\n            msg: 'string',\n            success: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ExecJobResponseBodyData = ExecJobResponseBodyData;\nclass GetArmsTopNMetricResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            count: 'Count',\n            error: 'Error',\n            name: 'Name',\n            regionId: 'RegionId',\n            rt: 'Rt',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            count: 'number',\n            error: 'number',\n            name: 'string',\n            regionId: 'string',\n            rt: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetArmsTopNMetricResponseBodyData = GetArmsTopNMetricResponseBodyData;\nclass GetAvailabilityMetricResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            enableAutoscale: 'EnableAutoscale',\n            errorInstances: 'ErrorInstances',\n            instances: 'Instances',\n            name: 'Name',\n            regionId: 'RegionId',\n            runnings: 'Runnings',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            enableAutoscale: 'number',\n            errorInstances: 'number',\n            instances: 'number',\n            name: 'string',\n            regionId: 'string',\n            runnings: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetAvailabilityMetricResponseBodyData = GetAvailabilityMetricResponseBodyData;\nclass GetChangeOrderMetricResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            error: 'Error',\n            errorPercent: 'ErrorPercent',\n            name: 'Name',\n            regionId: 'RegionId',\n            total: 'Total',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            error: 'number',\n            errorPercent: 'number',\n            name: 'string',\n            regionId: 'string',\n            total: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetChangeOrderMetricResponseBodyData = GetChangeOrderMetricResponseBodyData;\nclass GetScaleAppMetricResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            maxReplicas: 'MaxReplicas',\n            name: 'Name',\n            regionId: 'RegionId',\n            runnings: 'Runnings',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            maxReplicas: 'number',\n            name: 'string',\n            regionId: 'string',\n            runnings: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetScaleAppMetricResponseBodyData = GetScaleAppMetricResponseBodyData;\nclass GetWarningEventMetricResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            name: 'Name',\n            regionId: 'RegionId',\n            warningCount: 'WarningCount',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            name: 'string',\n            regionId: 'string',\n            warningCount: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.GetWarningEventMetricResponseBodyData = GetWarningEventMetricResponseBodyData;\nclass ListAppEventsResponseBodyDataAppEventEntity extends $tea.Model {\n    static names() {\n        return {\n            eventType: 'EventType',\n            firstTimestamp: 'FirstTimestamp',\n            lastTimestamp: 'LastTimestamp',\n            message: 'Message',\n            objectKind: 'ObjectKind',\n            objectName: 'ObjectName',\n            reason: 'Reason',\n        };\n    }\n    static types() {\n        return {\n            eventType: 'string',\n            firstTimestamp: 'string',\n            lastTimestamp: 'string',\n            message: 'string',\n            objectKind: 'string',\n            objectName: 'string',\n            reason: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppEventsResponseBodyDataAppEventEntity = ListAppEventsResponseBodyDataAppEventEntity;\nclass ListAppEventsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appEventEntity: 'AppEventEntity',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            appEventEntity: { 'type': 'array', 'itemType': ListAppEventsResponseBodyDataAppEventEntity },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppEventsResponseBodyData = ListAppEventsResponseBodyData;\nclass ListAppServicesPageResponseBodyDataResult extends $tea.Model {\n    static names() {\n        return {\n            edasAppId: 'EdasAppId',\n            edasAppName: 'EdasAppName',\n            group: 'Group',\n            instanceNum: 'InstanceNum',\n            serviceName: 'ServiceName',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            edasAppId: 'string',\n            edasAppName: 'string',\n            group: 'string',\n            instanceNum: 'number',\n            serviceName: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppServicesPageResponseBodyDataResult = ListAppServicesPageResponseBodyDataResult;\nclass ListAppServicesPageResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            result: 'Result',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'string',\n            pageNumber: 'string',\n            pageSize: 'string',\n            result: { 'type': 'array', 'itemType': ListAppServicesPageResponseBodyDataResult },\n            totalSize: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppServicesPageResponseBodyData = ListAppServicesPageResponseBodyData;\nclass ListAppVersionsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            buildPackageUrl: 'BuildPackageUrl',\n            createTime: 'CreateTime',\n            id: 'Id',\n            type: 'Type',\n            warUrl: 'WarUrl',\n        };\n    }\n    static types() {\n        return {\n            buildPackageUrl: 'string',\n            createTime: 'string',\n            id: 'string',\n            type: 'string',\n            warUrl: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListAppVersionsResponseBodyData = ListAppVersionsResponseBodyData;\nclass ListApplicationsResponseBodyDataApplicationsChildrenTags extends $tea.Model {\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBodyDataApplicationsChildrenTags = ListApplicationsResponseBodyDataApplicationsChildrenTags;\nclass ListApplicationsResponseBodyDataApplicationsChildren extends $tea.Model {\n    static names() {\n        return {\n            appDeletingStatus: 'AppDeletingStatus',\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n            appName: 'AppName',\n            baseAppId: 'BaseAppId',\n            cpu: 'Cpu',\n            instances: 'Instances',\n            mem: 'Mem',\n            mseEnabled: 'MseEnabled',\n            namespaceId: 'NamespaceId',\n            programmingLanguage: 'ProgrammingLanguage',\n            regionId: 'RegionId',\n            runningInstances: 'RunningInstances',\n            scaleRuleEnabled: 'ScaleRuleEnabled',\n            scaleRuleType: 'ScaleRuleType',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            appDeletingStatus: 'boolean',\n            appDescription: 'string',\n            appId: 'string',\n            appName: 'string',\n            baseAppId: 'string',\n            cpu: 'number',\n            instances: 'number',\n            mem: 'number',\n            mseEnabled: 'boolean',\n            namespaceId: 'string',\n            programmingLanguage: 'string',\n            regionId: 'string',\n            runningInstances: 'number',\n            scaleRuleEnabled: 'boolean',\n            scaleRuleType: 'string',\n            tags: { 'type': 'array', 'itemType': ListApplicationsResponseBodyDataApplicationsChildrenTags },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBodyDataApplicationsChildren = ListApplicationsResponseBodyDataApplicationsChildren;\nclass ListApplicationsResponseBodyDataApplicationsTags extends $tea.Model {\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBodyDataApplicationsTags = ListApplicationsResponseBodyDataApplicationsTags;\nclass ListApplicationsResponseBodyDataApplications extends $tea.Model {\n    static names() {\n        return {\n            appDeletingStatus: 'AppDeletingStatus',\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n            appName: 'AppName',\n            baseAppId: 'BaseAppId',\n            children: 'Children',\n            cpu: 'Cpu',\n            instances: 'Instances',\n            mem: 'Mem',\n            mseEnabled: 'MseEnabled',\n            mseNamespaceId: 'MseNamespaceId',\n            namespaceId: 'NamespaceId',\n            programmingLanguage: 'ProgrammingLanguage',\n            regionId: 'RegionId',\n            runningInstances: 'RunningInstances',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            appDeletingStatus: 'boolean',\n            appDescription: 'string',\n            appId: 'string',\n            appName: 'string',\n            baseAppId: 'string',\n            children: { 'type': 'array', 'itemType': ListApplicationsResponseBodyDataApplicationsChildren },\n            cpu: 'number',\n            instances: 'number',\n            mem: 'number',\n            mseEnabled: 'boolean',\n            mseNamespaceId: 'string',\n            namespaceId: 'string',\n            programmingLanguage: 'string',\n            regionId: 'string',\n            runningInstances: 'number',\n            tags: { 'type': 'array', 'itemType': ListApplicationsResponseBodyDataApplicationsTags },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBodyDataApplications = ListApplicationsResponseBodyDataApplications;\nclass ListApplicationsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            applications: 'Applications',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            applications: { 'type': 'array', 'itemType': ListApplicationsResponseBodyDataApplications },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListApplicationsResponseBodyData = ListApplicationsResponseBodyData;\nclass ListChangeOrdersResponseBodyDataChangeOrderList extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            batchCount: 'BatchCount',\n            batchType: 'BatchType',\n            changeOrderId: 'ChangeOrderId',\n            coType: 'CoType',\n            coTypeCode: 'CoTypeCode',\n            createTime: 'CreateTime',\n            createUserId: 'CreateUserId',\n            description: 'Description',\n            finishTime: 'FinishTime',\n            groupId: 'GroupId',\n            source: 'Source',\n            status: 'Status',\n            userId: 'UserId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            batchCount: 'number',\n            batchType: 'string',\n            changeOrderId: 'string',\n            coType: 'string',\n            coTypeCode: 'string',\n            createTime: 'string',\n            createUserId: 'string',\n            description: 'string',\n            finishTime: 'string',\n            groupId: 'string',\n            source: 'string',\n            status: 'number',\n            userId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListChangeOrdersResponseBodyDataChangeOrderList = ListChangeOrdersResponseBodyDataChangeOrderList;\nclass ListChangeOrdersResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderList: 'ChangeOrderList',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            changeOrderList: { 'type': 'array', 'itemType': ListChangeOrdersResponseBodyDataChangeOrderList },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListChangeOrdersResponseBodyData = ListChangeOrdersResponseBodyData;\nclass ListConsumedServicesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            group2Ip: 'Group2Ip',\n            groups: 'Groups',\n            ips: 'Ips',\n            name: 'Name',\n            type: 'Type',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            group2Ip: 'string',\n            groups: { 'type': 'array', 'itemType': 'string' },\n            ips: { 'type': 'array', 'itemType': 'string' },\n            name: 'string',\n            type: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListConsumedServicesResponseBodyData = ListConsumedServicesResponseBodyData;\nclass ListGreyTagRouteResponseBodyDataResultAlbRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultAlbRulesItems = ListGreyTagRouteResponseBodyDataResultAlbRulesItems;\nclass ListGreyTagRouteResponseBodyDataResultAlbRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            ingressId: 'ingressId',\n            items: 'items',\n            serviceName: 'serviceName',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            ingressId: 'string',\n            items: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultAlbRulesItems },\n            serviceName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultAlbRules = ListGreyTagRouteResponseBodyDataResultAlbRules;\nclass ListGreyTagRouteResponseBodyDataResultDubboRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultDubboRulesItems = ListGreyTagRouteResponseBodyDataResultDubboRulesItems;\nclass ListGreyTagRouteResponseBodyDataResultDubboRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            group: 'group',\n            items: 'items',\n            methodName: 'methodName',\n            serviceName: 'serviceName',\n            version: 'version',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            group: 'string',\n            items: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultDubboRulesItems },\n            methodName: 'string',\n            serviceName: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultDubboRules = ListGreyTagRouteResponseBodyDataResultDubboRules;\nclass ListGreyTagRouteResponseBodyDataResultScRulesItems extends $tea.Model {\n    static names() {\n        return {\n            cond: 'cond',\n            expr: 'expr',\n            index: 'index',\n            name: 'name',\n            operator: 'operator',\n            type: 'type',\n            value: 'value',\n        };\n    }\n    static types() {\n        return {\n            cond: 'string',\n            expr: 'string',\n            index: 'number',\n            name: 'string',\n            operator: 'string',\n            type: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultScRulesItems = ListGreyTagRouteResponseBodyDataResultScRulesItems;\nclass ListGreyTagRouteResponseBodyDataResultScRules extends $tea.Model {\n    static names() {\n        return {\n            condition: 'condition',\n            items: 'items',\n            path: 'path',\n        };\n    }\n    static types() {\n        return {\n            condition: 'string',\n            items: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultScRulesItems },\n            path: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResultScRules = ListGreyTagRouteResponseBodyDataResultScRules;\nclass ListGreyTagRouteResponseBodyDataResult extends $tea.Model {\n    static names() {\n        return {\n            albRules: 'AlbRules',\n            createTime: 'CreateTime',\n            description: 'Description',\n            dubboRules: 'DubboRules',\n            greyTagRouteId: 'GreyTagRouteId',\n            name: 'Name',\n            scRules: 'ScRules',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            albRules: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultAlbRules },\n            createTime: 'number',\n            description: 'string',\n            dubboRules: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultDubboRules },\n            greyTagRouteId: 'number',\n            name: 'string',\n            scRules: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResultScRules },\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyDataResult = ListGreyTagRouteResponseBodyDataResult;\nclass ListGreyTagRouteResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            result: 'Result',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            pageSize: 'number',\n            result: { 'type': 'array', 'itemType': ListGreyTagRouteResponseBodyDataResult },\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListGreyTagRouteResponseBodyData = ListGreyTagRouteResponseBodyData;\nclass ListIngressesResponseBodyDataIngressList extends $tea.Model {\n    static names() {\n        return {\n            certId: 'CertId',\n            certIds: 'CertIds',\n            description: 'Description',\n            id: 'Id',\n            listenerPort: 'ListenerPort',\n            listenerProtocol: 'ListenerProtocol',\n            loadBalanceType: 'LoadBalanceType',\n            mseGatewayId: 'MseGatewayId',\n            mseGatewayPort: 'MseGatewayPort',\n            mseGatewayProtocol: 'MseGatewayProtocol',\n            name: 'Name',\n            namespaceId: 'NamespaceId',\n            slbId: 'SlbId',\n            slbType: 'SlbType',\n        };\n    }\n    static types() {\n        return {\n            certId: 'string',\n            certIds: 'string',\n            description: 'string',\n            id: 'number',\n            listenerPort: 'string',\n            listenerProtocol: 'string',\n            loadBalanceType: 'string',\n            mseGatewayId: 'string',\n            mseGatewayPort: 'string',\n            mseGatewayProtocol: 'string',\n            name: 'string',\n            namespaceId: 'string',\n            slbId: 'string',\n            slbType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListIngressesResponseBodyDataIngressList = ListIngressesResponseBodyDataIngressList;\nclass ListIngressesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            ingressList: 'IngressList',\n        };\n    }\n    static types() {\n        return {\n            ingressList: { 'type': 'array', 'itemType': ListIngressesResponseBodyDataIngressList },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListIngressesResponseBodyData = ListIngressesResponseBodyData;\nclass ListJobsResponseBodyDataApplicationsTags extends $tea.Model {\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsResponseBodyDataApplicationsTags = ListJobsResponseBodyDataApplicationsTags;\nclass ListJobsResponseBodyDataApplications extends $tea.Model {\n    static names() {\n        return {\n            active: 'Active',\n            appDescription: 'AppDescription',\n            appId: 'AppId',\n            appName: 'AppName',\n            completionTime: 'CompletionTime',\n            cpu: 'Cpu',\n            failed: 'Failed',\n            lastChangeorderState: 'LastChangeorderState',\n            lastJobState: 'LastJobState',\n            lastStartTime: 'LastStartTime',\n            mem: 'Mem',\n            message: 'Message',\n            namespaceId: 'NamespaceId',\n            regionId: 'RegionId',\n            succeeded: 'Succeeded',\n            suspend: 'Suspend',\n            tags: 'Tags',\n            triggerConfig: 'TriggerConfig',\n        };\n    }\n    static types() {\n        return {\n            active: 'number',\n            appDescription: 'string',\n            appId: 'string',\n            appName: 'string',\n            completionTime: 'number',\n            cpu: 'number',\n            failed: 'number',\n            lastChangeorderState: 'string',\n            lastJobState: 'string',\n            lastStartTime: 'number',\n            mem: 'number',\n            message: 'string',\n            namespaceId: 'string',\n            regionId: 'string',\n            succeeded: 'number',\n            suspend: 'boolean',\n            tags: { 'type': 'array', 'itemType': ListJobsResponseBodyDataApplicationsTags },\n            triggerConfig: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsResponseBodyDataApplications = ListJobsResponseBodyDataApplications;\nclass ListJobsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            applications: 'Applications',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            applications: { 'type': 'array', 'itemType': ListJobsResponseBodyDataApplications },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListJobsResponseBodyData = ListJobsResponseBodyData;\nclass ListLogConfigsResponseBodyDataLogConfigs extends $tea.Model {\n    static names() {\n        return {\n            configName: 'ConfigName',\n            createTime: 'CreateTime',\n            logDir: 'LogDir',\n            logType: 'LogType',\n            regionId: 'RegionId',\n            slsLogStore: 'SlsLogStore',\n            slsProject: 'SlsProject',\n            storeType: 'StoreType',\n        };\n    }\n    static types() {\n        return {\n            configName: 'string',\n            createTime: 'string',\n            logDir: 'string',\n            logType: 'string',\n            regionId: 'string',\n            slsLogStore: 'string',\n            slsProject: 'string',\n            storeType: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListLogConfigsResponseBodyDataLogConfigs = ListLogConfigsResponseBodyDataLogConfigs;\nclass ListLogConfigsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            currentPage: 'CurrentPage',\n            logConfigs: 'LogConfigs',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            currentPage: 'number',\n            logConfigs: { 'type': 'array', 'itemType': ListLogConfigsResponseBodyDataLogConfigs },\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListLogConfigsResponseBodyData = ListLogConfigsResponseBodyData;\nclass ListNamespaceChangeOrdersResponseBodyDataChangeOrderList extends $tea.Model {\n    static names() {\n        return {\n            batchCount: 'BatchCount',\n            batchType: 'BatchType',\n            changeOrderId: 'ChangeOrderId',\n            coType: 'CoType',\n            coTypeCode: 'CoTypeCode',\n            createTime: 'CreateTime',\n            createUserId: 'CreateUserId',\n            description: 'Description',\n            finishTime: 'FinishTime',\n            groupId: 'GroupId',\n            namespaceId: 'NamespaceId',\n            pipelines: 'Pipelines',\n            source: 'Source',\n            status: 'Status',\n            userId: 'UserId',\n        };\n    }\n    static types() {\n        return {\n            batchCount: 'number',\n            batchType: 'string',\n            changeOrderId: 'string',\n            coType: 'string',\n            coTypeCode: 'string',\n            createTime: 'string',\n            createUserId: 'string',\n            description: 'string',\n            finishTime: 'string',\n            groupId: 'string',\n            namespaceId: 'string',\n            pipelines: 'string',\n            source: 'string',\n            status: 'number',\n            userId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespaceChangeOrdersResponseBodyDataChangeOrderList = ListNamespaceChangeOrdersResponseBodyDataChangeOrderList;\nclass ListNamespaceChangeOrdersResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderList: 'ChangeOrderList',\n            currentPage: 'CurrentPage',\n            pageSize: 'PageSize',\n            totalSize: 'TotalSize',\n        };\n    }\n    static types() {\n        return {\n            changeOrderList: { 'type': 'array', 'itemType': ListNamespaceChangeOrdersResponseBodyDataChangeOrderList },\n            currentPage: 'number',\n            pageSize: 'number',\n            totalSize: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespaceChangeOrdersResponseBodyData = ListNamespaceChangeOrdersResponseBodyData;\nclass ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps = ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps;\nclass ListNamespacedConfigMapsResponseBodyDataConfigMaps extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n            createTime: 'CreateTime',\n            data: 'Data',\n            description: 'Description',\n            name: 'Name',\n            namespaceId: 'NamespaceId',\n            relateApps: 'RelateApps',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'number',\n            createTime: 'number',\n            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },\n            description: 'string',\n            name: 'string',\n            namespaceId: 'string',\n            relateApps: { 'type': 'array', 'itemType': ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps },\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsResponseBodyDataConfigMaps = ListNamespacedConfigMapsResponseBodyDataConfigMaps;\nclass ListNamespacedConfigMapsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            configMaps: 'ConfigMaps',\n        };\n    }\n    static types() {\n        return {\n            configMaps: { 'type': 'array', 'itemType': ListNamespacedConfigMapsResponseBodyDataConfigMaps },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListNamespacedConfigMapsResponseBodyData = ListNamespacedConfigMapsResponseBodyData;\nclass ListPublishedServicesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            group2Ip: 'Group2Ip',\n            groups: 'Groups',\n            ips: 'Ips',\n            name: 'Name',\n            type: 'Type',\n            version: 'Version',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            group2Ip: 'string',\n            groups: { 'type': 'array', 'itemType': 'string' },\n            ips: { 'type': 'array', 'itemType': 'string' },\n            name: 'string',\n            type: 'string',\n            version: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListPublishedServicesResponseBodyData = ListPublishedServicesResponseBodyData;\nclass ListSecretsResponseBodyDataSecretsRelateApps extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            appName: 'AppName',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            appName: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsResponseBodyDataSecretsRelateApps = ListSecretsResponseBodyDataSecretsRelateApps;\nclass ListSecretsResponseBodyDataSecrets extends $tea.Model {\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            namespaceId: 'NamespaceId',\n            relateApps: 'RelateApps',\n            secretId: 'SecretId',\n            secretName: 'SecretName',\n            secretType: 'SecretType',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'number',\n            namespaceId: 'string',\n            relateApps: { 'type': 'array', 'itemType': ListSecretsResponseBodyDataSecretsRelateApps },\n            secretId: 'number',\n            secretName: 'string',\n            secretType: 'string',\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsResponseBodyDataSecrets = ListSecretsResponseBodyDataSecrets;\nclass ListSecretsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            secrets: 'Secrets',\n        };\n    }\n    static types() {\n        return {\n            secrets: { 'type': 'array', 'itemType': ListSecretsResponseBodyDataSecrets },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListSecretsResponseBodyData = ListSecretsResponseBodyData;\nclass ListTagResourcesResponseBodyDataTagResources extends $tea.Model {\n    static names() {\n        return {\n            resourceId: 'ResourceId',\n            resourceType: 'ResourceType',\n            tagKey: 'TagKey',\n            tagValue: 'TagValue',\n        };\n    }\n    static types() {\n        return {\n            resourceId: 'string',\n            resourceType: 'string',\n            tagKey: 'string',\n            tagValue: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListTagResourcesResponseBodyDataTagResources = ListTagResourcesResponseBodyDataTagResources;\nclass ListTagResourcesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            nextToken: 'NextToken',\n            tagResources: 'TagResources',\n        };\n    }\n    static types() {\n        return {\n            nextToken: 'string',\n            tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyDataTagResources },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ListTagResourcesResponseBodyData = ListTagResourcesResponseBodyData;\nclass QueryResourceStaticsResponseBodyDataRealTimeRes extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            memory: 'Memory',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            memory: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsResponseBodyDataRealTimeRes = QueryResourceStaticsResponseBodyDataRealTimeRes;\nclass QueryResourceStaticsResponseBodyDataSummary extends $tea.Model {\n    static names() {\n        return {\n            cpu: 'Cpu',\n            memory: 'Memory',\n        };\n    }\n    static types() {\n        return {\n            cpu: 'number',\n            memory: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsResponseBodyDataSummary = QueryResourceStaticsResponseBodyDataSummary;\nclass QueryResourceStaticsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            realTimeRes: 'RealTimeRes',\n            summary: 'Summary',\n        };\n    }\n    static types() {\n        return {\n            realTimeRes: QueryResourceStaticsResponseBodyDataRealTimeRes,\n            summary: QueryResourceStaticsResponseBodyDataSummary,\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.QueryResourceStaticsResponseBodyData = QueryResourceStaticsResponseBodyData;\nclass ReduceApplicationCapacityByInstanceIdsResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.ReduceApplicationCapacityByInstanceIdsResponseBodyData = ReduceApplicationCapacityByInstanceIdsResponseBodyData;\nclass RescaleApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationResponseBodyData = RescaleApplicationResponseBodyData;\nclass RescaleApplicationVerticallyResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RescaleApplicationVerticallyResponseBodyData = RescaleApplicationVerticallyResponseBodyData;\nclass RestartApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartApplicationResponseBodyData = RestartApplicationResponseBodyData;\nclass RestartInstancesResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RestartInstancesResponseBodyData = RestartInstancesResponseBodyData;\nclass RollbackApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n            isNeedApproval: 'IsNeedApproval',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n            isNeedApproval: 'boolean',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.RollbackApplicationResponseBodyData = RollbackApplicationResponseBodyData;\nclass StartApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StartApplicationResponseBodyData = StartApplicationResponseBodyData;\nclass StopApplicationResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.StopApplicationResponseBodyData = StopApplicationResponseBodyData;\nclass UnbindSlbResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UnbindSlbResponseBodyData = UnbindSlbResponseBodyData;\nclass UpdateApplicationScalingRuleResponseBodyDataMetricMetrics extends $tea.Model {\n    static names() {\n        return {\n            metricTargetAverageUtilization: 'MetricTargetAverageUtilization',\n            metricType: 'MetricType',\n            slbId: 'SlbId',\n            slbLogstore: 'SlbLogstore',\n            slbProject: 'SlbProject',\n            vport: 'Vport',\n        };\n    }\n    static types() {\n        return {\n            metricTargetAverageUtilization: 'number',\n            metricType: 'string',\n            slbId: 'string',\n            slbLogstore: 'string',\n            slbProject: 'string',\n            vport: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBodyDataMetricMetrics = UpdateApplicationScalingRuleResponseBodyDataMetricMetrics;\nclass UpdateApplicationScalingRuleResponseBodyDataMetric extends $tea.Model {\n    static names() {\n        return {\n            maxReplicas: 'MaxReplicas',\n            metrics: 'Metrics',\n            minReplicas: 'MinReplicas',\n        };\n    }\n    static types() {\n        return {\n            maxReplicas: 'number',\n            metrics: { 'type': 'array', 'itemType': UpdateApplicationScalingRuleResponseBodyDataMetricMetrics },\n            minReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBodyDataMetric = UpdateApplicationScalingRuleResponseBodyDataMetric;\nclass UpdateApplicationScalingRuleResponseBodyDataTimerSchedules extends $tea.Model {\n    static names() {\n        return {\n            atTime: 'AtTime',\n            maxReplicas: 'MaxReplicas',\n            minReplicas: 'MinReplicas',\n            targetReplicas: 'TargetReplicas',\n        };\n    }\n    static types() {\n        return {\n            atTime: 'string',\n            maxReplicas: 'number',\n            minReplicas: 'number',\n            targetReplicas: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBodyDataTimerSchedules = UpdateApplicationScalingRuleResponseBodyDataTimerSchedules;\nclass UpdateApplicationScalingRuleResponseBodyDataTimer extends $tea.Model {\n    static names() {\n        return {\n            beginDate: 'BeginDate',\n            endDate: 'EndDate',\n            period: 'Period',\n            schedules: 'Schedules',\n        };\n    }\n    static types() {\n        return {\n            beginDate: 'string',\n            endDate: 'string',\n            period: 'string',\n            schedules: { 'type': 'array', 'itemType': UpdateApplicationScalingRuleResponseBodyDataTimerSchedules },\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBodyDataTimer = UpdateApplicationScalingRuleResponseBodyDataTimer;\nclass UpdateApplicationScalingRuleResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            createTime: 'CreateTime',\n            lastDisableTime: 'LastDisableTime',\n            metric: 'Metric',\n            scaleRuleEnabled: 'ScaleRuleEnabled',\n            scaleRuleName: 'ScaleRuleName',\n            scaleRuleType: 'ScaleRuleType',\n            timer: 'Timer',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            createTime: 'number',\n            lastDisableTime: 'number',\n            metric: UpdateApplicationScalingRuleResponseBodyDataMetric,\n            scaleRuleEnabled: 'boolean',\n            scaleRuleName: 'string',\n            scaleRuleType: 'string',\n            timer: UpdateApplicationScalingRuleResponseBodyDataTimer,\n            updateTime: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateApplicationScalingRuleResponseBodyData = UpdateApplicationScalingRuleResponseBodyData;\nclass UpdateConfigMapResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            configMapId: 'ConfigMapId',\n        };\n    }\n    static types() {\n        return {\n            configMapId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateConfigMapResponseBodyData = UpdateConfigMapResponseBodyData;\nclass UpdateGreyTagRouteResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            greyTagRouteId: 'GreyTagRouteId',\n        };\n    }\n    static types() {\n        return {\n            greyTagRouteId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateGreyTagRouteResponseBodyData = UpdateGreyTagRouteResponseBodyData;\nclass UpdateIngressResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            ingressId: 'IngressId',\n        };\n    }\n    static types() {\n        return {\n            ingressId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateIngressResponseBodyData = UpdateIngressResponseBodyData;\nclass UpdateJobResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            appId: 'AppId',\n            changeOrderId: 'ChangeOrderId',\n        };\n    }\n    static types() {\n        return {\n            appId: 'string',\n            changeOrderId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateJobResponseBodyData = UpdateJobResponseBodyData;\nclass UpdateNamespaceResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            enableMicroRegistration: 'EnableMicroRegistration',\n            nameSpaceShortId: 'NameSpaceShortId',\n            namespaceDescription: 'NamespaceDescription',\n            namespaceId: 'NamespaceId',\n            namespaceName: 'NamespaceName',\n            regionId: 'RegionId',\n        };\n    }\n    static types() {\n        return {\n            enableMicroRegistration: 'boolean',\n            nameSpaceShortId: 'string',\n            namespaceDescription: 'string',\n            namespaceId: 'string',\n            namespaceName: 'string',\n            regionId: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateNamespaceResponseBodyData = UpdateNamespaceResponseBodyData;\nclass UpdateSecretRequestSecretData extends $tea.Model {\n    static names() {\n        return {\n            secretData: 'SecretData',\n        };\n    }\n    static types() {\n        return {\n            secretData: 'string',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretRequestSecretData = UpdateSecretRequestSecretData;\nclass UpdateSecretResponseBodyData extends $tea.Model {\n    static names() {\n        return {\n            secretId: 'SecretId',\n        };\n    }\n    static types() {\n        return {\n            secretId: 'number',\n        };\n    }\n    constructor(map) {\n        super(map);\n    }\n}\nexports.UpdateSecretResponseBodyData = UpdateSecretResponseBodyData;\nclass Client extends openapi_client_1.default {\n    constructor(config) {\n        super(config);\n        this._endpointRule = \"regional\";\n        this.checkConfig(config);\n        this._endpoint = this.getEndpoint(\"sae\", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);\n    }\n    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {\n        if (!tea_util_1.default.empty(endpoint)) {\n            return endpoint;\n        }\n        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {\n            return endpointMap[regionId];\n        }\n        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);\n    }\n    /**\n     * ba386059-69b1-4e65-b1e5-0682d9fa\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - AbortAndRollbackChangeOrderRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns AbortAndRollbackChangeOrderResponse\n     */\n    async abortAndRollbackChangeOrderWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.changeOrderId)) {\n            query[\"ChangeOrderId\"] = request.changeOrderId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"AbortAndRollbackChangeOrder\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/AbortAndRollbackChangeOrder`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new AbortAndRollbackChangeOrderResponse({}));\n    }\n    /**\n     * ba386059-69b1-4e65-b1e5-0682d9fa\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - AbortAndRollbackChangeOrderRequest\n     * @returns AbortAndRollbackChangeOrderResponse\n     */\n    async abortAndRollbackChangeOrder(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.abortAndRollbackChangeOrderWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - AbortChangeOrderRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns AbortChangeOrderResponse\n     */\n    async abortChangeOrderWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.changeOrderId)) {\n            query[\"ChangeOrderId\"] = request.changeOrderId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"AbortChangeOrder\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/AbortChangeOrder`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new AbortChangeOrderResponse({}));\n    }\n    /**\n     * @param request - AbortChangeOrderRequest\n     * @returns AbortChangeOrderResponse\n     */\n    async abortChangeOrder(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.abortChangeOrderWithOptions(request, headers, runtime);\n    }\n    /**\n     * cn-shanghai\n     *\n     * @param request - BatchStartApplicationsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns BatchStartApplicationsResponse\n     */\n    async batchStartApplicationsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appIds)) {\n            query[\"AppIds\"] = request.appIds;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.version)) {\n            query[\"Version\"] = request.version;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchStartApplications\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/batchStartApplications`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchStartApplicationsResponse({}));\n    }\n    /**\n     * cn-shanghai\n     *\n     * @param request - BatchStartApplicationsRequest\n     * @returns BatchStartApplicationsResponse\n     */\n    async batchStartApplications(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.batchStartApplicationsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Stops multiple applications at a time.\n     *\n     * @param request - BatchStopApplicationsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns BatchStopApplicationsResponse\n     */\n    async batchStopApplicationsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appIds)) {\n            query[\"AppIds\"] = request.appIds;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.version)) {\n            query[\"Version\"] = request.version;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchStopApplications\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/batchStopApplications`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchStopApplicationsResponse({}));\n    }\n    /**\n     * Stops multiple applications at a time.\n     *\n     * @param request - BatchStopApplicationsRequest\n     * @returns BatchStopApplicationsResponse\n     */\n    async batchStopApplications(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.batchStopApplicationsWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - BindSlbRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns BindSlbResponse\n     */\n    async bindSlbWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.internet)) {\n            query[\"Internet\"] = request.internet;\n        }\n        if (!tea_util_1.default.isUnset(request.internetSlbChargeType)) {\n            query[\"InternetSlbChargeType\"] = request.internetSlbChargeType;\n        }\n        if (!tea_util_1.default.isUnset(request.internetSlbId)) {\n            query[\"InternetSlbId\"] = request.internetSlbId;\n        }\n        if (!tea_util_1.default.isUnset(request.intranet)) {\n            query[\"Intranet\"] = request.intranet;\n        }\n        if (!tea_util_1.default.isUnset(request.intranetSlbChargeType)) {\n            query[\"IntranetSlbChargeType\"] = request.intranetSlbChargeType;\n        }\n        if (!tea_util_1.default.isUnset(request.intranetSlbId)) {\n            query[\"IntranetSlbId\"] = request.intranetSlbId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BindSlb\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/slb`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BindSlbResponse({}));\n    }\n    /**\n     * @param request - BindSlbRequest\n     * @returns BindSlbResponse\n     */\n    async bindSlb(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.bindSlbWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - ConfirmPipelineBatchRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ConfirmPipelineBatchResponse\n     */\n    async confirmPipelineBatchWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.confirm)) {\n            query[\"Confirm\"] = request.confirm;\n        }\n        if (!tea_util_1.default.isUnset(request.pipelineId)) {\n            query[\"PipelineId\"] = request.pipelineId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ConfirmPipelineBatch\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/ConfirmPipelineBatch`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ConfirmPipelineBatchResponse({}));\n    }\n    /**\n     * @param request - ConfirmPipelineBatchRequest\n     * @returns ConfirmPipelineBatchResponse\n     */\n    async confirmPipelineBatch(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.confirmPipelineBatchWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - CreateApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateApplicationResponse\n     */\n    async createApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.acrAssumeRoleArn)) {\n            query[\"AcrAssumeRoleArn\"] = request.acrAssumeRoleArn;\n        }\n        if (!tea_util_1.default.isUnset(request.appDescription)) {\n            query[\"AppDescription\"] = request.appDescription;\n        }\n        if (!tea_util_1.default.isUnset(request.appName)) {\n            query[\"AppName\"] = request.appName;\n        }\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.autoConfig)) {\n            query[\"AutoConfig\"] = request.autoConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.command)) {\n            query[\"Command\"] = request.command;\n        }\n        if (!tea_util_1.default.isUnset(request.commandArgs)) {\n            query[\"CommandArgs\"] = request.commandArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.cpu)) {\n            query[\"Cpu\"] = request.cpu;\n        }\n        if (!tea_util_1.default.isUnset(request.customHostAlias)) {\n            query[\"CustomHostAlias\"] = request.customHostAlias;\n        }\n        if (!tea_util_1.default.isUnset(request.deploy)) {\n            query[\"Deploy\"] = request.deploy;\n        }\n        if (!tea_util_1.default.isUnset(request.edasContainerVersion)) {\n            query[\"EdasContainerVersion\"] = request.edasContainerVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.enableEbpf)) {\n            query[\"EnableEbpf\"] = request.enableEbpf;\n        }\n        if (!tea_util_1.default.isUnset(request.envs)) {\n            query[\"Envs\"] = request.envs;\n        }\n        if (!tea_util_1.default.isUnset(request.imagePullSecrets)) {\n            query[\"ImagePullSecrets\"] = request.imagePullSecrets;\n        }\n        if (!tea_util_1.default.isUnset(request.imageUrl)) {\n            query[\"ImageUrl\"] = request.imageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartArgs)) {\n            query[\"JarStartArgs\"] = request.jarStartArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartOptions)) {\n            query[\"JarStartOptions\"] = request.jarStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.jdk)) {\n            query[\"Jdk\"] = request.jdk;\n        }\n        if (!tea_util_1.default.isUnset(request.kafkaConfigs)) {\n            query[\"KafkaConfigs\"] = request.kafkaConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.liveness)) {\n            query[\"Liveness\"] = request.liveness;\n        }\n        if (!tea_util_1.default.isUnset(request.memory)) {\n            query[\"Memory\"] = request.memory;\n        }\n        if (!tea_util_1.default.isUnset(request.microRegistration)) {\n            query[\"MicroRegistration\"] = request.microRegistration;\n        }\n        if (!tea_util_1.default.isUnset(request.mountDesc)) {\n            query[\"MountDesc\"] = request.mountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.mountHost)) {\n            query[\"MountHost\"] = request.mountHost;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nasConfigs)) {\n            query[\"NasConfigs\"] = request.nasConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.nasId)) {\n            query[\"NasId\"] = request.nasId;\n        }\n        if (!tea_util_1.default.isUnset(request.packageType)) {\n            query[\"PackageType\"] = request.packageType;\n        }\n        if (!tea_util_1.default.isUnset(request.packageUrl)) {\n            query[\"PackageUrl\"] = request.packageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.packageVersion)) {\n            query[\"PackageVersion\"] = request.packageVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.phpArmsConfigLocation)) {\n            query[\"PhpArmsConfigLocation\"] = request.phpArmsConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfigLocation)) {\n            query[\"PhpConfigLocation\"] = request.phpConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.postStart)) {\n            query[\"PostStart\"] = request.postStart;\n        }\n        if (!tea_util_1.default.isUnset(request.preStop)) {\n            query[\"PreStop\"] = request.preStop;\n        }\n        if (!tea_util_1.default.isUnset(request.programmingLanguage)) {\n            query[\"ProgrammingLanguage\"] = request.programmingLanguage;\n        }\n        if (!tea_util_1.default.isUnset(request.pvtzDiscoverySvc)) {\n            query[\"PvtzDiscoverySvc\"] = request.pvtzDiscoverySvc;\n        }\n        if (!tea_util_1.default.isUnset(request.python)) {\n            query[\"Python\"] = request.python;\n        }\n        if (!tea_util_1.default.isUnset(request.pythonModules)) {\n            query[\"PythonModules\"] = request.pythonModules;\n        }\n        if (!tea_util_1.default.isUnset(request.readiness)) {\n            query[\"Readiness\"] = request.readiness;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        if (!tea_util_1.default.isUnset(request.saeVersion)) {\n            query[\"SaeVersion\"] = request.saeVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.securityGroupId)) {\n            query[\"SecurityGroupId\"] = request.securityGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.slsConfigs)) {\n            query[\"SlsConfigs\"] = request.slsConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.terminationGracePeriodSeconds)) {\n            query[\"TerminationGracePeriodSeconds\"] = request.terminationGracePeriodSeconds;\n        }\n        if (!tea_util_1.default.isUnset(request.timezone)) {\n            query[\"Timezone\"] = request.timezone;\n        }\n        if (!tea_util_1.default.isUnset(request.tomcatConfig)) {\n            query[\"TomcatConfig\"] = request.tomcatConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.vSwitchId)) {\n            query[\"VSwitchId\"] = request.vSwitchId;\n        }\n        if (!tea_util_1.default.isUnset(request.vpcId)) {\n            query[\"VpcId\"] = request.vpcId;\n        }\n        if (!tea_util_1.default.isUnset(request.warStartOptions)) {\n            query[\"WarStartOptions\"] = request.warStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.webContainer)) {\n            query[\"WebContainer\"] = request.webContainer;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.acrInstanceId)) {\n            body[\"AcrInstanceId\"] = request.acrInstanceId;\n        }\n        if (!tea_util_1.default.isUnset(request.associateEip)) {\n            body[\"AssociateEip\"] = request.associateEip;\n        }\n        if (!tea_util_1.default.isUnset(request.baseAppId)) {\n            body[\"BaseAppId\"] = request.baseAppId;\n        }\n        if (!tea_util_1.default.isUnset(request.configMapMountDesc)) {\n            body[\"ConfigMapMountDesc\"] = request.configMapMountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.microRegistrationConfig)) {\n            body[\"MicroRegistrationConfig\"] = request.microRegistrationConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkId)) {\n            body[\"OssAkId\"] = request.ossAkId;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkSecret)) {\n            body[\"OssAkSecret\"] = request.ossAkSecret;\n        }\n        if (!tea_util_1.default.isUnset(request.ossMountDescs)) {\n            body[\"OssMountDescs\"] = request.ossMountDescs;\n        }\n        if (!tea_util_1.default.isUnset(request.php)) {\n            body[\"Php\"] = request.php;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfig)) {\n            body[\"PhpConfig\"] = request.phpConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceTags)) {\n            body[\"ServiceTags\"] = request.serviceTags;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/createApplication`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateApplicationResponse({}));\n    }\n    /**\n     * @param request - CreateApplicationRequest\n     * @returns CreateApplicationResponse\n     */\n    async createApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * Null\n     *\n     * @remarks\n     * The HTTP status code. Take note of the following rules:\n     * *   **2xx**: The call was successful.\n     * *   **3xx**: The call was redirected.\n     * *   **4xx**: The call failed.\n     * *   **5xx**: A server error occurred.\n     *\n     * @param request - CreateApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateApplicationScalingRuleResponse\n     */\n    async createApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleEnable)) {\n            query[\"ScalingRuleEnable\"] = request.scalingRuleEnable;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleMetric)) {\n            query[\"ScalingRuleMetric\"] = request.scalingRuleMetric;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleTimer)) {\n            query[\"ScalingRuleTimer\"] = request.scalingRuleTimer;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleType)) {\n            query[\"ScalingRuleType\"] = request.scalingRuleType;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/applicationScalingRule`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateApplicationScalingRuleResponse({}));\n    }\n    /**\n     * Null\n     *\n     * @remarks\n     * The HTTP status code. Take note of the following rules:\n     * *   **2xx**: The call was successful.\n     * *   **3xx**: The call was redirected.\n     * *   **4xx**: The call failed.\n     * *   **5xx**: A server error occurred.\n     *\n     * @param request - CreateApplicationScalingRuleRequest\n     * @returns CreateApplicationScalingRuleResponse\n     */\n    async createApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * name\n     *\n     * @param request - CreateConfigMapRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateConfigMapResponse\n     */\n    async createConfigMapWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        if (!tea_util_1.default.isUnset(request.name)) {\n            query[\"Name\"] = request.name;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.data)) {\n            body[\"Data\"] = request.data;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateConfigMap\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/configmap/configMap`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateConfigMapResponse({}));\n    }\n    /**\n     * name\n     *\n     * @param request - CreateConfigMapRequest\n     * @returns CreateConfigMapResponse\n     */\n    async createConfigMap(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createConfigMapWithOptions(request, headers, runtime);\n    }\n    /**\n     * Creates a canary release rule for a Spring Cloud or Dubbo application.\n     *\n     * @remarks\n     * >  You can configure only one canary release rule for each application.\n     *\n     * @param request - CreateGreyTagRouteRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateGreyTagRouteResponse\n     */\n    async createGreyTagRouteWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.albRules)) {\n            query[\"AlbRules\"] = request.albRules;\n        }\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        if (!tea_util_1.default.isUnset(request.dubboRules)) {\n            query[\"DubboRules\"] = request.dubboRules;\n        }\n        if (!tea_util_1.default.isUnset(request.name)) {\n            query[\"Name\"] = request.name;\n        }\n        if (!tea_util_1.default.isUnset(request.scRules)) {\n            query[\"ScRules\"] = request.scRules;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateGreyTagRoute\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/tagroute/greyTagRoute`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateGreyTagRouteResponse({}));\n    }\n    /**\n     * Creates a canary release rule for a Spring Cloud or Dubbo application.\n     *\n     * @remarks\n     * >  You can configure only one canary release rule for each application.\n     *\n     * @param request - CreateGreyTagRouteRequest\n     * @returns CreateGreyTagRouteResponse\n     */\n    async createGreyTagRoute(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createGreyTagRouteWithOptions(request, headers, runtime);\n    }\n    /**\n     * {\"appId\":\"395b60e4-0550-458d-9c54-a265d036\\\\*\\\\*\\\\*\\\\*\",\"containerPort\":8080}\n     *\n     * @param request - CreateIngressRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateIngressResponse\n     */\n    async createIngressWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certId)) {\n            query[\"CertId\"] = request.certId;\n        }\n        if (!tea_util_1.default.isUnset(request.certIds)) {\n            query[\"CertIds\"] = request.certIds;\n        }\n        if (!tea_util_1.default.isUnset(request.defaultRule)) {\n            query[\"DefaultRule\"] = request.defaultRule;\n        }\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        if (!tea_util_1.default.isUnset(request.listenerPort)) {\n            query[\"ListenerPort\"] = request.listenerPort;\n        }\n        if (!tea_util_1.default.isUnset(request.listenerProtocol)) {\n            query[\"ListenerProtocol\"] = request.listenerProtocol;\n        }\n        if (!tea_util_1.default.isUnset(request.loadBalanceType)) {\n            query[\"LoadBalanceType\"] = request.loadBalanceType;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.requestTimeout)) {\n            query[\"RequestTimeout\"] = request.requestTimeout;\n        }\n        if (!tea_util_1.default.isUnset(request.securityPolicyId)) {\n            query[\"SecurityPolicyId\"] = request.securityPolicyId;\n        }\n        if (!tea_util_1.default.isUnset(request.slbId)) {\n            query[\"SlbId\"] = request.slbId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.rules)) {\n            body[\"Rules\"] = request.rules;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateIngress\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/ingress/Ingress`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateIngressResponse({}));\n    }\n    /**\n     * {\"appId\":\"395b60e4-0550-458d-9c54-a265d036\\\\*\\\\*\\\\*\\\\*\",\"containerPort\":8080}\n     *\n     * @param request - CreateIngressRequest\n     * @returns CreateIngressResponse\n     */\n    async createIngress(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createIngressWithOptions(request, headers, runtime);\n    }\n    /**\n     * Updates a job template.\n     *\n     * @param request - CreateJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateJobResponse\n     */\n    async createJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.acrAssumeRoleArn)) {\n            query[\"AcrAssumeRoleArn\"] = request.acrAssumeRoleArn;\n        }\n        if (!tea_util_1.default.isUnset(request.appDescription)) {\n            query[\"AppDescription\"] = request.appDescription;\n        }\n        if (!tea_util_1.default.isUnset(request.appName)) {\n            query[\"AppName\"] = request.appName;\n        }\n        if (!tea_util_1.default.isUnset(request.autoConfig)) {\n            query[\"AutoConfig\"] = request.autoConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.backoffLimit)) {\n            query[\"BackoffLimit\"] = request.backoffLimit;\n        }\n        if (!tea_util_1.default.isUnset(request.command)) {\n            query[\"Command\"] = request.command;\n        }\n        if (!tea_util_1.default.isUnset(request.commandArgs)) {\n            query[\"CommandArgs\"] = request.commandArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.concurrencyPolicy)) {\n            query[\"ConcurrencyPolicy\"] = request.concurrencyPolicy;\n        }\n        if (!tea_util_1.default.isUnset(request.cpu)) {\n            query[\"Cpu\"] = request.cpu;\n        }\n        if (!tea_util_1.default.isUnset(request.customHostAlias)) {\n            query[\"CustomHostAlias\"] = request.customHostAlias;\n        }\n        if (!tea_util_1.default.isUnset(request.edasContainerVersion)) {\n            query[\"EdasContainerVersion\"] = request.edasContainerVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.envs)) {\n            query[\"Envs\"] = request.envs;\n        }\n        if (!tea_util_1.default.isUnset(request.imagePullSecrets)) {\n            query[\"ImagePullSecrets\"] = request.imagePullSecrets;\n        }\n        if (!tea_util_1.default.isUnset(request.imageUrl)) {\n            query[\"ImageUrl\"] = request.imageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartArgs)) {\n            query[\"JarStartArgs\"] = request.jarStartArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartOptions)) {\n            query[\"JarStartOptions\"] = request.jarStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.jdk)) {\n            query[\"Jdk\"] = request.jdk;\n        }\n        if (!tea_util_1.default.isUnset(request.memory)) {\n            query[\"Memory\"] = request.memory;\n        }\n        if (!tea_util_1.default.isUnset(request.mountDesc)) {\n            query[\"MountDesc\"] = request.mountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.mountHost)) {\n            query[\"MountHost\"] = request.mountHost;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nasId)) {\n            query[\"NasId\"] = request.nasId;\n        }\n        if (!tea_util_1.default.isUnset(request.packageType)) {\n            query[\"PackageType\"] = request.packageType;\n        }\n        if (!tea_util_1.default.isUnset(request.packageUrl)) {\n            query[\"PackageUrl\"] = request.packageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.packageVersion)) {\n            query[\"PackageVersion\"] = request.packageVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfigLocation)) {\n            query[\"PhpConfigLocation\"] = request.phpConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.postStart)) {\n            query[\"PostStart\"] = request.postStart;\n        }\n        if (!tea_util_1.default.isUnset(request.preStop)) {\n            query[\"PreStop\"] = request.preStop;\n        }\n        if (!tea_util_1.default.isUnset(request.programmingLanguage)) {\n            query[\"ProgrammingLanguage\"] = request.programmingLanguage;\n        }\n        if (!tea_util_1.default.isUnset(request.python)) {\n            query[\"Python\"] = request.python;\n        }\n        if (!tea_util_1.default.isUnset(request.pythonModules)) {\n            query[\"PythonModules\"] = request.pythonModules;\n        }\n        if (!tea_util_1.default.isUnset(request.refAppId)) {\n            query[\"RefAppId\"] = request.refAppId;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        if (!tea_util_1.default.isUnset(request.securityGroupId)) {\n            query[\"SecurityGroupId\"] = request.securityGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.slice)) {\n            query[\"Slice\"] = request.slice;\n        }\n        if (!tea_util_1.default.isUnset(request.sliceEnvs)) {\n            query[\"SliceEnvs\"] = request.sliceEnvs;\n        }\n        if (!tea_util_1.default.isUnset(request.slsConfigs)) {\n            query[\"SlsConfigs\"] = request.slsConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.terminationGracePeriodSeconds)) {\n            query[\"TerminationGracePeriodSeconds\"] = request.terminationGracePeriodSeconds;\n        }\n        if (!tea_util_1.default.isUnset(request.timeout)) {\n            query[\"Timeout\"] = request.timeout;\n        }\n        if (!tea_util_1.default.isUnset(request.timezone)) {\n            query[\"Timezone\"] = request.timezone;\n        }\n        if (!tea_util_1.default.isUnset(request.tomcatConfig)) {\n            query[\"TomcatConfig\"] = request.tomcatConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerConfig)) {\n            query[\"TriggerConfig\"] = request.triggerConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.vSwitchId)) {\n            query[\"VSwitchId\"] = request.vSwitchId;\n        }\n        if (!tea_util_1.default.isUnset(request.vpcId)) {\n            query[\"VpcId\"] = request.vpcId;\n        }\n        if (!tea_util_1.default.isUnset(request.warStartOptions)) {\n            query[\"WarStartOptions\"] = request.warStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.webContainer)) {\n            query[\"WebContainer\"] = request.webContainer;\n        }\n        if (!tea_util_1.default.isUnset(request.workload)) {\n            query[\"Workload\"] = request.workload;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.acrInstanceId)) {\n            body[\"AcrInstanceId\"] = request.acrInstanceId;\n        }\n        if (!tea_util_1.default.isUnset(request.configMapMountDesc)) {\n            body[\"ConfigMapMountDesc\"] = request.configMapMountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.enableImageAccl)) {\n            body[\"EnableImageAccl\"] = request.enableImageAccl;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkId)) {\n            body[\"OssAkId\"] = request.ossAkId;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkSecret)) {\n            body[\"OssAkSecret\"] = request.ossAkSecret;\n        }\n        if (!tea_util_1.default.isUnset(request.ossMountDescs)) {\n            body[\"OssMountDescs\"] = request.ossMountDescs;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfig)) {\n            body[\"PhpConfig\"] = request.phpConfig;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/createJob`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateJobResponse({}));\n    }\n    /**\n     * Updates a job template.\n     *\n     * @param request - CreateJobRequest\n     * @returns CreateJobResponse\n     */\n    async createJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * Creates a namespace.\n     *\n     * @param request - CreateNamespaceRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateNamespaceResponse\n     */\n    async createNamespaceWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.enableMicroRegistration)) {\n            query[\"EnableMicroRegistration\"] = request.enableMicroRegistration;\n        }\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceDescription)) {\n            query[\"NamespaceDescription\"] = request.namespaceDescription;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceName)) {\n            query[\"NamespaceName\"] = request.namespaceName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateNamespace\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/namespace`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateNamespaceResponse({}));\n    }\n    /**\n     * Creates a namespace.\n     *\n     * @param request - CreateNamespaceRequest\n     * @returns CreateNamespaceResponse\n     */\n    async createNamespace(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createNamespaceWithOptions(request, headers, runtime);\n    }\n    /**\n     * Null\n     *\n     * @param tmpReq - CreateSecretRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateSecretResponse\n     */\n    async createSecretWithOptions(tmpReq, headers, runtime) {\n        tea_util_1.default.validateModel(tmpReq);\n        let request = new CreateSecretShrinkRequest({});\n        openapi_util_1.default.convert(tmpReq, request);\n        if (!tea_util_1.default.isUnset(tmpReq.secretData)) {\n            request.secretDataShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.secretData, \"SecretData\", \"json\");\n        }\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.secretDataShrink)) {\n            query[\"SecretData\"] = request.secretDataShrink;\n        }\n        if (!tea_util_1.default.isUnset(request.secretName)) {\n            query[\"SecretName\"] = request.secretName;\n        }\n        if (!tea_util_1.default.isUnset(request.secretType)) {\n            query[\"SecretType\"] = request.secretType;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateSecret\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/secret/secret`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateSecretResponse({}));\n    }\n    /**\n     * Null\n     *\n     * @param request - CreateSecretRequest\n     * @returns CreateSecretResponse\n     */\n    async createSecret(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createSecretWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - CreateWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateWebApplicationResponse\n     */\n    async createWebApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - CreateWebApplicationRequest\n     * @returns CreateWebApplicationResponse\n     */\n    async createWebApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createWebApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - CreateWebCustomDomainRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns CreateWebCustomDomainResponse\n     */\n    async createWebCustomDomainWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateWebCustomDomain\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/custom-domains`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateWebCustomDomainResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - CreateWebCustomDomainRequest\n     * @returns CreateWebCustomDomainResponse\n     */\n    async createWebCustomDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.createWebCustomDomainWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DeleteApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteApplicationResponse\n     */\n    async deleteApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/deleteApplication`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteApplicationResponse({}));\n    }\n    /**\n     * @param request - DeleteApplicationRequest\n     * @returns DeleteApplicationResponse\n     */\n    async deleteApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * 7171a6ca-d1cd-4928-8642-7d5cfe69\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - DeleteApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteApplicationScalingRuleResponse\n     */\n    async deleteApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/applicationScalingRule`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteApplicationScalingRuleResponse({}));\n    }\n    /**\n     * 7171a6ca-d1cd-4928-8642-7d5cfe69\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - DeleteApplicationScalingRuleRequest\n     * @returns DeleteApplicationScalingRuleResponse\n     */\n    async deleteApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DeleteConfigMapRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteConfigMapResponse\n     */\n    async deleteConfigMapWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configMapId)) {\n            query[\"ConfigMapId\"] = request.configMapId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteConfigMap\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/configmap/configMap`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteConfigMapResponse({}));\n    }\n    /**\n     * @param request - DeleteConfigMapRequest\n     * @returns DeleteConfigMapResponse\n     */\n    async deleteConfigMap(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteConfigMapWithOptions(request, headers, runtime);\n    }\n    /**\n     * 1\n     *\n     * @param request - DeleteGreyTagRouteRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteGreyTagRouteResponse\n     */\n    async deleteGreyTagRouteWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.greyTagRouteId)) {\n            query[\"GreyTagRouteId\"] = request.greyTagRouteId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteGreyTagRoute\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/tagroute/greyTagRoute`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteGreyTagRouteResponse({}));\n    }\n    /**\n     * 1\n     *\n     * @param request - DeleteGreyTagRouteRequest\n     * @returns DeleteGreyTagRouteResponse\n     */\n    async deleteGreyTagRoute(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteGreyTagRouteWithOptions(request, headers, runtime);\n    }\n    /**\n     * Deletes a job.\n     *\n     * @param request - DeleteHistoryJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteHistoryJobResponse\n     */\n    async deleteHistoryJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.jobId)) {\n            query[\"JobId\"] = request.jobId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteHistoryJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/deleteHistoryJob`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteHistoryJobResponse({}));\n    }\n    /**\n     * Deletes a job.\n     *\n     * @param request - DeleteHistoryJobRequest\n     * @returns DeleteHistoryJobResponse\n     */\n    async deleteHistoryJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteHistoryJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DeleteIngressRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteIngressResponse\n     */\n    async deleteIngressWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ingressId)) {\n            query[\"IngressId\"] = request.ingressId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteIngress\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/ingress/Ingress`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteIngressResponse({}));\n    }\n    /**\n     * @param request - DeleteIngressRequest\n     * @returns DeleteIngressResponse\n     */\n    async deleteIngress(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteIngressWithOptions(request, headers, runtime);\n    }\n    /**\n     * Deletes a job template.\n     *\n     * @param request - DeleteJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteJobResponse\n     */\n    async deleteJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/deleteJob`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteJobResponse({}));\n    }\n    /**\n     * Deletes a job template.\n     *\n     * @param request - DeleteJobRequest\n     * @returns DeleteJobResponse\n     */\n    async deleteJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DeleteNamespaceRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteNamespaceResponse\n     */\n    async deleteNamespaceWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteNamespace\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/namespace`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteNamespaceResponse({}));\n    }\n    /**\n     * @param request - DeleteNamespaceRequest\n     * @returns DeleteNamespaceResponse\n     */\n    async deleteNamespace(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteNamespaceWithOptions(request, headers, runtime);\n    }\n    /**\n     * Deletes a Secret.\n     *\n     * @param request - DeleteSecretRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteSecretResponse\n     */\n    async deleteSecretWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.secretId)) {\n            query[\"SecretId\"] = request.secretId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteSecret\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/secret/secret`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSecretResponse({}));\n    }\n    /**\n     * Deletes a Secret.\n     *\n     * @param request - DeleteSecretRequest\n     * @returns DeleteSecretResponse\n     */\n    async deleteSecret(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteSecretWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteWebApplicationResponse\n     */\n    async deleteWebApplicationWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebApplicationRequest\n     * @returns DeleteWebApplicationResponse\n     */\n    async deleteWebApplication(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteWebApplicationWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebApplicationRevisionRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteWebApplicationRevisionResponse\n     */\n    async deleteWebApplicationRevisionWithOptions(ApplicationId, RevisionId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteWebApplicationRevision\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-revisions/${openapi_util_1.default.getEncodeParam(ApplicationId)}/revisions/${openapi_util_1.default.getEncodeParam(RevisionId)}`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteWebApplicationRevisionResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebApplicationRevisionRequest\n     * @returns DeleteWebApplicationRevisionResponse\n     */\n    async deleteWebApplicationRevision(ApplicationId, RevisionId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteWebApplicationRevisionWithOptions(ApplicationId, RevisionId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebCustomDomainRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeleteWebCustomDomainResponse\n     */\n    async deleteWebCustomDomainWithOptions(DomainName, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteWebCustomDomain\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/custom-domains/${openapi_util_1.default.getEncodeParam(DomainName)}`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteWebCustomDomainResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DeleteWebCustomDomainRequest\n     * @returns DeleteWebCustomDomainResponse\n     */\n    async deleteWebCustomDomain(DomainName, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deleteWebCustomDomainWithOptions(DomainName, request, headers, runtime);\n    }\n    /**\n     * Deploys an application.\n     *\n     * @param request - DeployApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DeployApplicationResponse\n     */\n    async deployApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.acrAssumeRoleArn)) {\n            query[\"AcrAssumeRoleArn\"] = request.acrAssumeRoleArn;\n        }\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.autoEnableApplicationScalingRule)) {\n            query[\"AutoEnableApplicationScalingRule\"] = request.autoEnableApplicationScalingRule;\n        }\n        if (!tea_util_1.default.isUnset(request.batchWaitTime)) {\n            query[\"BatchWaitTime\"] = request.batchWaitTime;\n        }\n        if (!tea_util_1.default.isUnset(request.changeOrderDesc)) {\n            query[\"ChangeOrderDesc\"] = request.changeOrderDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.command)) {\n            query[\"Command\"] = request.command;\n        }\n        if (!tea_util_1.default.isUnset(request.commandArgs)) {\n            query[\"CommandArgs\"] = request.commandArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.cpu)) {\n            query[\"Cpu\"] = request.cpu;\n        }\n        if (!tea_util_1.default.isUnset(request.customHostAlias)) {\n            query[\"CustomHostAlias\"] = request.customHostAlias;\n        }\n        if (!tea_util_1.default.isUnset(request.deploy)) {\n            query[\"Deploy\"] = request.deploy;\n        }\n        if (!tea_util_1.default.isUnset(request.edasContainerVersion)) {\n            query[\"EdasContainerVersion\"] = request.edasContainerVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.enableAhas)) {\n            query[\"EnableAhas\"] = request.enableAhas;\n        }\n        if (!tea_util_1.default.isUnset(request.enableGreyTagRoute)) {\n            query[\"EnableGreyTagRoute\"] = request.enableGreyTagRoute;\n        }\n        if (!tea_util_1.default.isUnset(request.envs)) {\n            query[\"Envs\"] = request.envs;\n        }\n        if (!tea_util_1.default.isUnset(request.imagePullSecrets)) {\n            query[\"ImagePullSecrets\"] = request.imagePullSecrets;\n        }\n        if (!tea_util_1.default.isUnset(request.imageUrl)) {\n            query[\"ImageUrl\"] = request.imageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartArgs)) {\n            query[\"JarStartArgs\"] = request.jarStartArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartOptions)) {\n            query[\"JarStartOptions\"] = request.jarStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.jdk)) {\n            query[\"Jdk\"] = request.jdk;\n        }\n        if (!tea_util_1.default.isUnset(request.kafkaConfigs)) {\n            query[\"KafkaConfigs\"] = request.kafkaConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.liveness)) {\n            query[\"Liveness\"] = request.liveness;\n        }\n        if (!tea_util_1.default.isUnset(request.memory)) {\n            query[\"Memory\"] = request.memory;\n        }\n        if (!tea_util_1.default.isUnset(request.microRegistration)) {\n            query[\"MicroRegistration\"] = request.microRegistration;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        if (!tea_util_1.default.isUnset(request.mountDesc)) {\n            query[\"MountDesc\"] = request.mountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.mountHost)) {\n            query[\"MountHost\"] = request.mountHost;\n        }\n        if (!tea_util_1.default.isUnset(request.nasConfigs)) {\n            query[\"NasConfigs\"] = request.nasConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.nasId)) {\n            query[\"NasId\"] = request.nasId;\n        }\n        if (!tea_util_1.default.isUnset(request.packageType)) {\n            query[\"PackageType\"] = request.packageType;\n        }\n        if (!tea_util_1.default.isUnset(request.packageUrl)) {\n            query[\"PackageUrl\"] = request.packageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.packageVersion)) {\n            query[\"PackageVersion\"] = request.packageVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.phpArmsConfigLocation)) {\n            query[\"PhpArmsConfigLocation\"] = request.phpArmsConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfigLocation)) {\n            query[\"PhpConfigLocation\"] = request.phpConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.postStart)) {\n            query[\"PostStart\"] = request.postStart;\n        }\n        if (!tea_util_1.default.isUnset(request.preStop)) {\n            query[\"PreStop\"] = request.preStop;\n        }\n        if (!tea_util_1.default.isUnset(request.pvtzDiscoverySvc)) {\n            query[\"PvtzDiscoverySvc\"] = request.pvtzDiscoverySvc;\n        }\n        if (!tea_util_1.default.isUnset(request.python)) {\n            query[\"Python\"] = request.python;\n        }\n        if (!tea_util_1.default.isUnset(request.pythonModules)) {\n            query[\"PythonModules\"] = request.pythonModules;\n        }\n        if (!tea_util_1.default.isUnset(request.readiness)) {\n            query[\"Readiness\"] = request.readiness;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        if (!tea_util_1.default.isUnset(request.securityGroupId)) {\n            query[\"SecurityGroupId\"] = request.securityGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.slsConfigs)) {\n            query[\"SlsConfigs\"] = request.slsConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.terminationGracePeriodSeconds)) {\n            query[\"TerminationGracePeriodSeconds\"] = request.terminationGracePeriodSeconds;\n        }\n        if (!tea_util_1.default.isUnset(request.timezone)) {\n            query[\"Timezone\"] = request.timezone;\n        }\n        if (!tea_util_1.default.isUnset(request.tomcatConfig)) {\n            query[\"TomcatConfig\"] = request.tomcatConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.updateStrategy)) {\n            query[\"UpdateStrategy\"] = request.updateStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.vSwitchId)) {\n            query[\"VSwitchId\"] = request.vSwitchId;\n        }\n        if (!tea_util_1.default.isUnset(request.warStartOptions)) {\n            query[\"WarStartOptions\"] = request.warStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.webContainer)) {\n            query[\"WebContainer\"] = request.webContainer;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.acrInstanceId)) {\n            body[\"AcrInstanceId\"] = request.acrInstanceId;\n        }\n        if (!tea_util_1.default.isUnset(request.associateEip)) {\n            body[\"AssociateEip\"] = request.associateEip;\n        }\n        if (!tea_util_1.default.isUnset(request.configMapMountDesc)) {\n            body[\"ConfigMapMountDesc\"] = request.configMapMountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.microRegistrationConfig)) {\n            body[\"MicroRegistrationConfig\"] = request.microRegistrationConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkId)) {\n            body[\"OssAkId\"] = request.ossAkId;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkSecret)) {\n            body[\"OssAkSecret\"] = request.ossAkSecret;\n        }\n        if (!tea_util_1.default.isUnset(request.ossMountDescs)) {\n            body[\"OssMountDescs\"] = request.ossMountDescs;\n        }\n        if (!tea_util_1.default.isUnset(request.php)) {\n            body[\"Php\"] = request.php;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfig)) {\n            body[\"PhpConfig\"] = request.phpConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceTags)) {\n            body[\"ServiceTags\"] = request.serviceTags;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeployApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/deployApplication`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeployApplicationResponse({}));\n    }\n    /**\n     * Deploys an application.\n     *\n     * @param request - DeployApplicationRequest\n     * @returns DeployApplicationResponse\n     */\n    async deployApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.deployApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the metadata details of the service of an application.\n     *\n     * @param request - DescribeAppServiceDetailRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeAppServiceDetailResponse\n     */\n    async describeAppServiceDetailWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.nacosInstanceId)) {\n            query[\"NacosInstanceId\"] = request.nacosInstanceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nacosNamespaceId)) {\n            query[\"NacosNamespaceId\"] = request.nacosNamespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceGroup)) {\n            query[\"ServiceGroup\"] = request.serviceGroup;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceName)) {\n            query[\"ServiceName\"] = request.serviceName;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceType)) {\n            query[\"ServiceType\"] = request.serviceType;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceVersion)) {\n            query[\"ServiceVersion\"] = request.serviceVersion;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeAppServiceDetail\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/service/describeAppServiceDetail`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAppServiceDetailResponse({}));\n    }\n    /**\n     * Queries the metadata details of the service of an application.\n     *\n     * @param request - DescribeAppServiceDetailRequest\n     * @returns DescribeAppServiceDetailResponse\n     */\n    async describeAppServiceDetail(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeAppServiceDetailWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the configurations of an application.\n     *\n     * @param request - DescribeApplicationConfigRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationConfigResponse\n     */\n    async describeApplicationConfigWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.versionId)) {\n            query[\"VersionId\"] = request.versionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationConfig\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/describeApplicationConfig`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationConfigResponse({}));\n    }\n    /**\n     * Queries the configurations of an application.\n     *\n     * @param request - DescribeApplicationConfigRequest\n     * @returns DescribeApplicationConfigResponse\n     */\n    async describeApplicationConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationConfigWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeApplicationGroupsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationGroupsResponse\n     */\n    async describeApplicationGroupsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationGroups\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/describeApplicationGroups`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationGroupsResponse({}));\n    }\n    /**\n     * @param request - DescribeApplicationGroupsRequest\n     * @returns DescribeApplicationGroupsResponse\n     */\n    async describeApplicationGroups(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationGroupsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the information about the image of an application.\n     *\n     * @param request - DescribeApplicationImageRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationImageResponse\n     */\n    async describeApplicationImageWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.imageUrl)) {\n            query[\"ImageUrl\"] = request.imageUrl;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationImage\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/container/describeApplicationImage`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationImageResponse({}));\n    }\n    /**\n     * Queries the information about the image of an application.\n     *\n     * @param request - DescribeApplicationImageRequest\n     * @returns DescribeApplicationImageResponse\n     */\n    async describeApplicationImage(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationImageWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries application instances.\n     *\n     * @param request - DescribeApplicationInstancesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationInstancesResponse\n     */\n    async describeApplicationInstancesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.groupId)) {\n            query[\"GroupId\"] = request.groupId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.reverse)) {\n            query[\"Reverse\"] = request.reverse;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationInstances\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/describeApplicationInstances`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationInstancesResponse({}));\n    }\n    /**\n     * Queries application instances.\n     *\n     * @param request - DescribeApplicationInstancesRequest\n     * @returns DescribeApplicationInstancesResponse\n     */\n    async describeApplicationInstances(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationInstancesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries a specified auto scaling policy of an application.\n     *\n     * @param request - DescribeApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationScalingRuleResponse\n     */\n    async describeApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/applicationScalingRule`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationScalingRuleResponse({}));\n    }\n    /**\n     * Queries a specified auto scaling policy of an application.\n     *\n     * @param request - DescribeApplicationScalingRuleRequest\n     * @returns DescribeApplicationScalingRuleResponse\n     */\n    async describeApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the auto scaling policies of an application.\n     *\n     * @param request - DescribeApplicationScalingRulesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationScalingRulesResponse\n     */\n    async describeApplicationScalingRulesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationScalingRules\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/applicationScalingRules`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationScalingRulesResponse({}));\n    }\n    /**\n     * Queries the auto scaling policies of an application.\n     *\n     * @param request - DescribeApplicationScalingRulesRequest\n     * @returns DescribeApplicationScalingRulesResponse\n     */\n    async describeApplicationScalingRules(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationScalingRulesWithOptions(request, headers, runtime);\n    }\n    /**\n     * 017f39b8-dfa4-4e16-a84b-1dcee4b1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - DescribeApplicationSlbsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationSlbsResponse\n     */\n    async describeApplicationSlbsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationSlbs\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/slb`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationSlbsResponse({}));\n    }\n    /**\n     * 017f39b8-dfa4-4e16-a84b-1dcee4b1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - DescribeApplicationSlbsRequest\n     * @returns DescribeApplicationSlbsResponse\n     */\n    async describeApplicationSlbs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationSlbsWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeApplicationStatusRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeApplicationStatusResponse\n     */\n    async describeApplicationStatusWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeApplicationStatus\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/describeApplicationStatus`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeApplicationStatusResponse({}));\n    }\n    /**\n     * @param request - DescribeApplicationStatusRequest\n     * @returns DescribeApplicationStatusResponse\n     */\n    async describeApplicationStatus(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeApplicationStatusWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeChangeOrderRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeChangeOrderResponse\n     */\n    async describeChangeOrderWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.changeOrderId)) {\n            query[\"ChangeOrderId\"] = request.changeOrderId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeChangeOrder\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/DescribeChangeOrder`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeChangeOrderResponse({}));\n    }\n    /**\n     * @param request - DescribeChangeOrderRequest\n     * @returns DescribeChangeOrderResponse\n     */\n    async describeChangeOrder(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeChangeOrderWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeComponentsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeComponentsResponse\n     */\n    async describeComponentsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.type)) {\n            query[\"Type\"] = request.type;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeComponents\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/resource/components`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeComponentsResponse({}));\n    }\n    /**\n     * @param request - DescribeComponentsRequest\n     * @returns DescribeComponentsResponse\n     */\n    async describeComponents(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeComponentsWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeConfigMapRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeConfigMapResponse\n     */\n    async describeConfigMapWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configMapId)) {\n            query[\"ConfigMapId\"] = request.configMapId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeConfigMap\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/configmap/configMap`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeConfigMapResponse({}));\n    }\n    /**\n     * @param request - DescribeConfigMapRequest\n     * @returns DescribeConfigMapResponse\n     */\n    async describeConfigMap(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeConfigMapWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeConfigurationPriceRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeConfigurationPriceResponse\n     */\n    async describeConfigurationPriceWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.cpu)) {\n            query[\"Cpu\"] = request.cpu;\n        }\n        if (!tea_util_1.default.isUnset(request.memory)) {\n            query[\"Memory\"] = request.memory;\n        }\n        if (!tea_util_1.default.isUnset(request.workload)) {\n            query[\"Workload\"] = request.workload;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeConfigurationPrice\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/configurationPrice`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeConfigurationPriceResponse({}));\n    }\n    /**\n     * @param request - DescribeConfigurationPriceRequest\n     * @returns DescribeConfigurationPriceResponse\n     */\n    async describeConfigurationPrice(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeConfigurationPriceWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeEdasContainersResponse\n     */\n    async describeEdasContainersWithOptions(headers, runtime) {\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeEdasContainers\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/resource/edasContainers`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEdasContainersResponse({}));\n    }\n    /**\n     * @returns DescribeEdasContainersResponse\n     */\n    async describeEdasContainers() {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeEdasContainersWithOptions(headers, runtime);\n    }\n    /**\n     * Queries the details of a canary release rule based on the specified rule ID.\n     *\n     * @param request - DescribeGreyTagRouteRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeGreyTagRouteResponse\n     */\n    async describeGreyTagRouteWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.greyTagRouteId)) {\n            query[\"GreyTagRouteId\"] = request.greyTagRouteId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeGreyTagRoute\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/tagroute/greyTagRoute`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeGreyTagRouteResponse({}));\n    }\n    /**\n     * Queries the details of a canary release rule based on the specified rule ID.\n     *\n     * @param request - DescribeGreyTagRouteRequest\n     * @returns DescribeGreyTagRouteResponse\n     */\n    async describeGreyTagRoute(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeGreyTagRouteWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeIngressRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeIngressResponse\n     */\n    async describeIngressWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ingressId)) {\n            query[\"IngressId\"] = request.ingressId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeIngress\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/ingress/Ingress`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeIngressResponse({}));\n    }\n    /**\n     * @param request - DescribeIngressRequest\n     * @returns DescribeIngressResponse\n     */\n    async describeIngress(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeIngressWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeInstanceLogRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeInstanceLogResponse\n     */\n    async describeInstanceLogWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.instanceId)) {\n            query[\"InstanceId\"] = request.instanceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeInstanceLog\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/instance/describeInstanceLog`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceLogResponse({}));\n    }\n    /**\n     * @param request - DescribeInstanceLogRequest\n     * @returns DescribeInstanceLogResponse\n     */\n    async describeInstanceLog(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeInstanceLogWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeInstanceSpecificationsResponse\n     */\n    async describeInstanceSpecificationsWithOptions(headers, runtime) {\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeInstanceSpecifications\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/quota/instanceSpecifications`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceSpecificationsResponse({}));\n    }\n    /**\n     * @returns DescribeInstanceSpecificationsResponse\n     */\n    async describeInstanceSpecifications() {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeInstanceSpecificationsWithOptions(headers, runtime);\n    }\n    /**\n     * Queries the configurations of a job template.\n     *\n     * @param request - DescribeJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeJobResponse\n     */\n    async describeJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.jobId)) {\n            query[\"JobId\"] = request.jobId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/describeJob`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeJobResponse({}));\n    }\n    /**\n     * Queries the configurations of a job template.\n     *\n     * @param request - DescribeJobRequest\n     * @returns DescribeJobResponse\n     */\n    async describeJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * Query the information about jobs.\n     *\n     * @param request - DescribeJobHistoryRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeJobHistoryResponse\n     */\n    async describeJobHistoryWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.state)) {\n            query[\"State\"] = request.state;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeJobHistory\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/describeJobHistory`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeJobHistoryResponse({}));\n    }\n    /**\n     * Query the information about jobs.\n     *\n     * @param request - DescribeJobHistoryRequest\n     * @returns DescribeJobHistoryResponse\n     */\n    async describeJobHistory(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeJobHistoryWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the status of a job.\n     *\n     * @param request - DescribeJobStatusRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeJobStatusResponse\n     */\n    async describeJobStatusWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.jobId)) {\n            query[\"JobId\"] = request.jobId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeJobStatus\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/describeJobStatus`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeJobStatusResponse({}));\n    }\n    /**\n     * Queries the status of a job.\n     *\n     * @param request - DescribeJobStatusRequest\n     * @returns DescribeJobStatusResponse\n     */\n    async describeJobStatus(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeJobStatusWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the details of a namespace.\n     *\n     * @param request - DescribeNamespaceRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeNamespaceResponse\n     */\n    async describeNamespaceWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeNamespace\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/namespace`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeNamespaceResponse({}));\n    }\n    /**\n     * Queries the details of a namespace.\n     *\n     * @param request - DescribeNamespaceRequest\n     * @returns DescribeNamespaceResponse\n     */\n    async describeNamespace(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeNamespaceWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries a list of namespaces.\n     *\n     * @param request - DescribeNamespaceListRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeNamespaceListResponse\n     */\n    async describeNamespaceListWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.containCustom)) {\n            query[\"ContainCustom\"] = request.containCustom;\n        }\n        if (!tea_util_1.default.isUnset(request.hybridCloudExclude)) {\n            query[\"HybridCloudExclude\"] = request.hybridCloudExclude;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeNamespaceList\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/namespace/describeNamespaceList`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeNamespaceListResponse({}));\n    }\n    /**\n     * Queries a list of namespaces.\n     *\n     * @param request - DescribeNamespaceListRequest\n     * @returns DescribeNamespaceListResponse\n     */\n    async describeNamespaceList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeNamespaceListWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - DescribeNamespaceResourcesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeNamespaceResourcesResponse\n     */\n    async describeNamespaceResourcesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeNamespaceResources\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/namespace/describeNamespaceResources`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeNamespaceResourcesResponse({}));\n    }\n    /**\n     * @param request - DescribeNamespaceResourcesRequest\n     * @returns DescribeNamespaceResourcesResponse\n     */\n    async describeNamespaceResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeNamespaceResourcesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the details of namespaces.\n     *\n     * @param request - DescribeNamespacesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeNamespacesResponse\n     */\n    async describeNamespacesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeNamespaces\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/namespaces`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeNamespacesResponse({}));\n    }\n    /**\n     * Queries the details of namespaces.\n     *\n     * @param request - DescribeNamespacesRequest\n     * @returns DescribeNamespacesResponse\n     */\n    async describeNamespaces(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeNamespacesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the information of a batch.\n     *\n     * @param request - DescribePipelineRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribePipelineResponse\n     */\n    async describePipelineWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.pipelineId)) {\n            query[\"PipelineId\"] = request.pipelineId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribePipeline\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/DescribePipeline`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribePipelineResponse({}));\n    }\n    /**\n     * Queries the information of a batch.\n     *\n     * @param request - DescribePipelineRequest\n     * @returns DescribePipelineResponse\n     */\n    async describePipeline(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describePipelineWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries available regions.\n     *\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeRegionsResponse\n     */\n    async describeRegionsWithOptions(headers, runtime) {\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRegions\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/regionConfig`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRegionsResponse({}));\n    }\n    /**\n     * Queries available regions.\n     * @returns DescribeRegionsResponse\n     */\n    async describeRegions() {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeRegionsWithOptions(headers, runtime);\n    }\n    /**\n     * Queries the details of a Secret instance.\n     *\n     * @param request - DescribeSecretRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeSecretResponse\n     */\n    async describeSecretWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.secretId)) {\n            query[\"SecretId\"] = request.secretId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeSecret\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/secret/secret`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSecretResponse({}));\n    }\n    /**\n     * Queries the details of a Secret instance.\n     *\n     * @param request - DescribeSecretRequest\n     * @returns DescribeSecretResponse\n     */\n    async describeSecret(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeSecretWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebApplicationResponse\n     */\n    async describeWebApplicationWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationRequest\n     * @returns DescribeWebApplicationResponse\n     */\n    async describeWebApplication(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebApplicationWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationResourceStaticsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebApplicationResourceStaticsResponse\n     */\n    async describeWebApplicationResourceStaticsWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebApplicationResourceStatics\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications-observability/${openapi_util_1.default.getEncodeParam(ApplicationId)}/resource`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebApplicationResourceStaticsResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationResourceStaticsRequest\n     * @returns DescribeWebApplicationResourceStaticsResponse\n     */\n    async describeWebApplicationResourceStatics(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebApplicationResourceStaticsWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationRevisionRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebApplicationRevisionResponse\n     */\n    async describeWebApplicationRevisionWithOptions(ApplicationId, RevisionId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebApplicationRevision\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-revisions/${openapi_util_1.default.getEncodeParam(ApplicationId)}/revisions/${openapi_util_1.default.getEncodeParam(RevisionId)}`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebApplicationRevisionResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationRevisionRequest\n     * @returns DescribeWebApplicationRevisionResponse\n     */\n    async describeWebApplicationRevision(ApplicationId, RevisionId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebApplicationRevisionWithOptions(ApplicationId, RevisionId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationScalingConfigRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebApplicationScalingConfigResponse\n     */\n    async describeWebApplicationScalingConfigWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebApplicationScalingConfig\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-scaling/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebApplicationScalingConfigResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationScalingConfigRequest\n     * @returns DescribeWebApplicationScalingConfigResponse\n     */\n    async describeWebApplicationScalingConfig(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebApplicationScalingConfigWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationTrafficConfigRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebApplicationTrafficConfigResponse\n     */\n    async describeWebApplicationTrafficConfigWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebApplicationTrafficConfig\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-traffic/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebApplicationTrafficConfigResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebApplicationTrafficConfigRequest\n     * @returns DescribeWebApplicationTrafficConfigResponse\n     */\n    async describeWebApplicationTrafficConfig(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebApplicationTrafficConfigWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * .\n     *\n     * @param request - DescribeWebCustomDomainRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebCustomDomainResponse\n     */\n    async describeWebCustomDomainWithOptions(DomainName, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebCustomDomain\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/custom-domains/${openapi_util_1.default.getEncodeParam(DomainName)}`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebCustomDomainResponse({}));\n    }\n    /**\n     * .\n     *\n     * @param request - DescribeWebCustomDomainRequest\n     * @returns DescribeWebCustomDomainResponse\n     */\n    async describeWebCustomDomain(DomainName, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebCustomDomainWithOptions(DomainName, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebInstanceLogsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DescribeWebInstanceLogsResponse\n     */\n    async describeWebInstanceLogsWithOptions(ApplicationId, InstanceId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeWebInstanceLogs\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications-observability/${openapi_util_1.default.getEncodeParam(ApplicationId)}/instances/${openapi_util_1.default.getEncodeParam(InstanceId)}/logs`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWebInstanceLogsResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - DescribeWebInstanceLogsRequest\n     * @returns DescribeWebInstanceLogsResponse\n     */\n    async describeWebInstanceLogs(ApplicationId, InstanceId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.describeWebInstanceLogsWithOptions(ApplicationId, InstanceId, request, headers, runtime);\n    }\n    /**\n     * @param request - DisableApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns DisableApplicationScalingRuleResponse\n     */\n    async disableApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DisableApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/disableApplicationScalingRule`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DisableApplicationScalingRuleResponse({}));\n    }\n    /**\n     * @param request - DisableApplicationScalingRuleRequest\n     * @returns DisableApplicationScalingRuleResponse\n     */\n    async disableApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.disableApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * Enables an auto scaling policy for an application.\n     *\n     * @param request - EnableApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns EnableApplicationScalingRuleResponse\n     */\n    async enableApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"EnableApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/enableApplicationScalingRule`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new EnableApplicationScalingRuleResponse({}));\n    }\n    /**\n     * Enables an auto scaling policy for an application.\n     *\n     * @param request - EnableApplicationScalingRuleRequest\n     * @returns EnableApplicationScalingRuleResponse\n     */\n    async enableApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.enableApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - ExecJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ExecJobResponse\n     */\n    async execJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.command)) {\n            query[\"Command\"] = request.command;\n        }\n        if (!tea_util_1.default.isUnset(request.commandArgs)) {\n            query[\"CommandArgs\"] = request.commandArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.envs)) {\n            query[\"Envs\"] = request.envs;\n        }\n        if (!tea_util_1.default.isUnset(request.eventId)) {\n            query[\"EventId\"] = request.eventId;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartArgs)) {\n            query[\"JarStartArgs\"] = request.jarStartArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartOptions)) {\n            query[\"JarStartOptions\"] = request.jarStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        if (!tea_util_1.default.isUnset(request.time)) {\n            query[\"Time\"] = request.time;\n        }\n        if (!tea_util_1.default.isUnset(request.warStartOptions)) {\n            query[\"WarStartOptions\"] = request.warStartOptions;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ExecJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/execJob`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ExecJobResponse({}));\n    }\n    /**\n     * @param request - ExecJobRequest\n     * @returns ExecJobResponse\n     */\n    async execJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.execJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the top N applications in Application Monitoring.\n     *\n     * @param request - GetArmsTopNMetricRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns GetArmsTopNMetricResponse\n     */\n    async getArmsTopNMetricWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.cpuStrategy)) {\n            query[\"CpuStrategy\"] = request.cpuStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.orderBy)) {\n            query[\"OrderBy\"] = request.orderBy;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"GetArmsTopNMetric\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/getArmsTopNMetric`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new GetArmsTopNMetricResponse({}));\n    }\n    /**\n     * Queries the top N applications in Application Monitoring.\n     *\n     * @param request - GetArmsTopNMetricRequest\n     * @returns GetArmsTopNMetricResponse\n     */\n    async getArmsTopNMetric(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.getArmsTopNMetricWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the top N applications in which abnormal instances exist. The applications are sorted by the total number of abnormal instances.\n     *\n     * @param request - GetAvailabilityMetricRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns GetAvailabilityMetricResponse\n     */\n    async getAvailabilityMetricWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.cpuStrategy)) {\n            query[\"CpuStrategy\"] = request.cpuStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"GetAvailabilityMetric\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/getAvailabilityMetric`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new GetAvailabilityMetricResponse({}));\n    }\n    /**\n     * Queries the top N applications in which abnormal instances exist. The applications are sorted by the total number of abnormal instances.\n     *\n     * @param request - GetAvailabilityMetricRequest\n     * @returns GetAvailabilityMetricResponse\n     */\n    async getAvailabilityMetric(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.getAvailabilityMetricWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries top N applications in abnormal change orders.\n     *\n     * @param request - GetChangeOrderMetricRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns GetChangeOrderMetricResponse\n     */\n    async getChangeOrderMetricWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.cpuStrategy)) {\n            query[\"CpuStrategy\"] = request.cpuStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.createTime)) {\n            query[\"CreateTime\"] = request.createTime;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.orderBy)) {\n            query[\"OrderBy\"] = request.orderBy;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"GetChangeOrderMetric\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/getChangeOrderMetric`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new GetChangeOrderMetricResponse({}));\n    }\n    /**\n     * Queries top N applications in abnormal change orders.\n     *\n     * @param request - GetChangeOrderMetricRequest\n     * @returns GetChangeOrderMetricResponse\n     */\n    async getChangeOrderMetric(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.getChangeOrderMetricWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the top N applications in which auto scaling takes effect.\n     *\n     * @param request - GetScaleAppMetricRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns GetScaleAppMetricResponse\n     */\n    async getScaleAppMetricWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.cpuStrategy)) {\n            query[\"CpuStrategy\"] = request.cpuStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"GetScaleAppMetric\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/getScaleAppMetric`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new GetScaleAppMetricResponse({}));\n    }\n    /**\n     * Queries the top N applications in which auto scaling takes effect.\n     *\n     * @param request - GetScaleAppMetricRequest\n     * @returns GetScaleAppMetricResponse\n     */\n    async getScaleAppMetric(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.getScaleAppMetricWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the top N applications in which Warning events occur.\n     *\n     * @param request - GetWarningEventMetricRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns GetWarningEventMetricResponse\n     */\n    async getWarningEventMetricWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.cpuStrategy)) {\n            query[\"CpuStrategy\"] = request.cpuStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"GetWarningEventMetric\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/getWarningEventMetric`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new GetWarningEventMetricResponse({}));\n    }\n    /**\n     * Queries the top N applications in which Warning events occur.\n     *\n     * @param request - GetWarningEventMetricRequest\n     * @returns GetWarningEventMetricResponse\n     */\n    async getWarningEventMetric(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.getWarningEventMetricWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the events that occurred in an application.\n     *\n     * @param request - ListAppEventsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListAppEventsResponse\n     */\n    async listAppEventsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.eventType)) {\n            query[\"EventType\"] = request.eventType;\n        }\n        if (!tea_util_1.default.isUnset(request.namespace)) {\n            query[\"Namespace\"] = request.namespace;\n        }\n        if (!tea_util_1.default.isUnset(request.objectKind)) {\n            query[\"ObjectKind\"] = request.objectKind;\n        }\n        if (!tea_util_1.default.isUnset(request.objectName)) {\n            query[\"ObjectName\"] = request.objectName;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.reason)) {\n            query[\"Reason\"] = request.reason;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListAppEvents\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/listAppEvents`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListAppEventsResponse({}));\n    }\n    /**\n     * Queries the events that occurred in an application.\n     *\n     * @param request - ListAppEventsRequest\n     * @returns ListAppEventsResponse\n     */\n    async listAppEvents(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listAppEventsWithOptions(request, headers, runtime);\n    }\n    /**\n     * 6dcc8c9e-d3da-478a-a066-86dcf820\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListAppServicesPageRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListAppServicesPageResponse\n     */\n    async listAppServicesPageWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.serviceType)) {\n            query[\"ServiceType\"] = request.serviceType;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListAppServicesPage\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/service/listAppServicesPage`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListAppServicesPageResponse({}));\n    }\n    /**\n     * 6dcc8c9e-d3da-478a-a066-86dcf820\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListAppServicesPageRequest\n     * @returns ListAppServicesPageResponse\n     */\n    async listAppServicesPage(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listAppServicesPageWithOptions(request, headers, runtime);\n    }\n    /**\n     * 7171a6ca-d1cd-4928-8642-7d5cfe69\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListAppVersionsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListAppVersionsResponse\n     */\n    async listAppVersionsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListAppVersions\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/listAppVersions`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListAppVersionsResponse({}));\n    }\n    /**\n     * 7171a6ca-d1cd-4928-8642-7d5cfe69\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListAppVersionsRequest\n     * @returns ListAppVersionsResponse\n     */\n    async listAppVersions(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listAppVersionsWithOptions(request, headers, runtime);\n    }\n    /**\n     * The ID of the namespace.\n     *\n     * @param request - ListApplicationsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListApplicationsResponse\n     */\n    async listApplicationsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appName)) {\n            query[\"AppName\"] = request.appName;\n        }\n        if (!tea_util_1.default.isUnset(request.appSource)) {\n            query[\"AppSource\"] = request.appSource;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.fieldType)) {\n            query[\"FieldType\"] = request.fieldType;\n        }\n        if (!tea_util_1.default.isUnset(request.fieldValue)) {\n            query[\"FieldValue\"] = request.fieldValue;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.orderBy)) {\n            query[\"OrderBy\"] = request.orderBy;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.reverse)) {\n            query[\"Reverse\"] = request.reverse;\n        }\n        if (!tea_util_1.default.isUnset(request.tags)) {\n            query[\"Tags\"] = request.tags;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListApplications\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/listApplications`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListApplicationsResponse({}));\n    }\n    /**\n     * The ID of the namespace.\n     *\n     * @param request - ListApplicationsRequest\n     * @returns ListApplicationsResponse\n     */\n    async listApplications(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listApplicationsWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - ListChangeOrdersRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListChangeOrdersResponse\n     */\n    async listChangeOrdersWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.coStatus)) {\n            query[\"CoStatus\"] = request.coStatus;\n        }\n        if (!tea_util_1.default.isUnset(request.coType)) {\n            query[\"CoType\"] = request.coType;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.key)) {\n            query[\"Key\"] = request.key;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListChangeOrders\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/ListChangeOrders`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListChangeOrdersResponse({}));\n    }\n    /**\n     * @param request - ListChangeOrdersRequest\n     * @returns ListChangeOrdersResponse\n     */\n    async listChangeOrders(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listChangeOrdersWithOptions(request, headers, runtime);\n    }\n    /**\n     * b2a8a925-477a-4ed7-b825-d5e22500\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListConsumedServicesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListConsumedServicesResponse\n     */\n    async listConsumedServicesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListConsumedServices\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/service/listConsumedServices`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListConsumedServicesResponse({}));\n    }\n    /**\n     * b2a8a925-477a-4ed7-b825-d5e22500\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListConsumedServicesRequest\n     * @returns ListConsumedServicesResponse\n     */\n    async listConsumedServices(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listConsumedServicesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the details of a canary release rule based on an application ID.\n     *\n     * @remarks\n     * >  You can configure only one canary release rule for each application.\n     *\n     * @param request - ListGreyTagRouteRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListGreyTagRouteResponse\n     */\n    async listGreyTagRouteWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListGreyTagRoute\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/tagroute/greyTagRouteList`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListGreyTagRouteResponse({}));\n    }\n    /**\n     * Queries the details of a canary release rule based on an application ID.\n     *\n     * @remarks\n     * >  You can configure only one canary release rule for each application.\n     *\n     * @param request - ListGreyTagRouteRequest\n     * @returns ListGreyTagRouteResponse\n     */\n    async listGreyTagRoute(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listGreyTagRouteWithOptions(request, headers, runtime);\n    }\n    /**\n     * The returned message.\n     * *   **success** is returned when the request succeeds.\n     * *   An error code is returned when the request fails.\n     *\n     * @param request - ListIngressesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListIngressesResponse\n     */\n    async listIngressesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListIngresses\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/ingress/IngressList`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListIngressesResponse({}));\n    }\n    /**\n     * The returned message.\n     * *   **success** is returned when the request succeeds.\n     * *   An error code is returned when the request fails.\n     *\n     * @param request - ListIngressesRequest\n     * @returns ListIngressesResponse\n     */\n    async listIngresses(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listIngressesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the information about job templates.\n     *\n     * @param request - ListJobsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListJobsResponse\n     */\n    async listJobsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appName)) {\n            query[\"AppName\"] = request.appName;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.fieldType)) {\n            query[\"FieldType\"] = request.fieldType;\n        }\n        if (!tea_util_1.default.isUnset(request.fieldValue)) {\n            query[\"FieldValue\"] = request.fieldValue;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.orderBy)) {\n            query[\"OrderBy\"] = request.orderBy;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.reverse)) {\n            query[\"Reverse\"] = request.reverse;\n        }\n        if (!tea_util_1.default.isUnset(request.tags)) {\n            query[\"Tags\"] = request.tags;\n        }\n        if (!tea_util_1.default.isUnset(request.workload)) {\n            query[\"Workload\"] = request.workload;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListJobs\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/listJobs`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListJobsResponse({}));\n    }\n    /**\n     * Queries the information about job templates.\n     *\n     * @param request - ListJobsRequest\n     * @returns ListJobsResponse\n     */\n    async listJobs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listJobsWithOptions(request, headers, runtime);\n    }\n    /**\n     * 56f77b65-788d-442a-9885-7f20d91f\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListLogConfigsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListLogConfigsResponse\n     */\n    async listLogConfigsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListLogConfigs\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/log/listLogConfigs`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListLogConfigsResponse({}));\n    }\n    /**\n     * 56f77b65-788d-442a-9885-7f20d91f\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListLogConfigsRequest\n     * @returns ListLogConfigsResponse\n     */\n    async listLogConfigs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listLogConfigsWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - ListNamespaceChangeOrdersRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListNamespaceChangeOrdersResponse\n     */\n    async listNamespaceChangeOrdersWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.coStatus)) {\n            query[\"CoStatus\"] = request.coStatus;\n        }\n        if (!tea_util_1.default.isUnset(request.coType)) {\n            query[\"CoType\"] = request.coType;\n        }\n        if (!tea_util_1.default.isUnset(request.currentPage)) {\n            query[\"CurrentPage\"] = request.currentPage;\n        }\n        if (!tea_util_1.default.isUnset(request.key)) {\n            query[\"Key\"] = request.key;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListNamespaceChangeOrders\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/changeorder/listNamespaceChangeOrders`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListNamespaceChangeOrdersResponse({}));\n    }\n    /**\n     * @param request - ListNamespaceChangeOrdersRequest\n     * @returns ListNamespaceChangeOrdersResponse\n     */\n    async listNamespaceChangeOrders(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listNamespaceChangeOrdersWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the ConfigMap instances in a namespace.\n     *\n     * @param request - ListNamespacedConfigMapsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListNamespacedConfigMapsResponse\n     */\n    async listNamespacedConfigMapsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListNamespacedConfigMaps\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/configmap/listNamespacedConfigMaps`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListNamespacedConfigMapsResponse({}));\n    }\n    /**\n     * Queries the ConfigMap instances in a namespace.\n     *\n     * @param request - ListNamespacedConfigMapsRequest\n     * @returns ListNamespacedConfigMapsResponse\n     */\n    async listNamespacedConfigMaps(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listNamespacedConfigMapsWithOptions(request, headers, runtime);\n    }\n    /**\n     * b2a8a925-477a-4ed7-b825-d5e22500\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListPublishedServicesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListPublishedServicesResponse\n     */\n    async listPublishedServicesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListPublishedServices\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/service/listPublishedServices`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListPublishedServicesResponse({}));\n    }\n    /**\n     * b2a8a925-477a-4ed7-b825-d5e22500\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - ListPublishedServicesRequest\n     * @returns ListPublishedServicesResponse\n     */\n    async listPublishedServices(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listPublishedServicesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the information about Secrets in a namespace.\n     *\n     * @param request - ListSecretsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListSecretsResponse\n     */\n    async listSecretsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListSecrets\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/secret/secrets`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListSecretsResponse({}));\n    }\n    /**\n     * Queries the information about Secrets in a namespace.\n     *\n     * @param request - ListSecretsRequest\n     * @returns ListSecretsResponse\n     */\n    async listSecrets(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listSecretsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Queries the mapping relationships between applications and tags.\n     *\n     * @param request - ListTagResourcesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListTagResourcesResponse\n     */\n    async listTagResourcesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.nextToken)) {\n            query[\"NextToken\"] = request.nextToken;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceIds)) {\n            query[\"ResourceIds\"] = request.resourceIds;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            query[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tags)) {\n            query[\"Tags\"] = request.tags;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListTagResources\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/tags`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));\n    }\n    /**\n     * Queries the mapping relationships between applications and tags.\n     *\n     * @param request - ListTagResourcesRequest\n     * @returns ListTagResourcesResponse\n     */\n    async listTagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listTagResourcesWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param tmpReq - ListWebApplicationInstancesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListWebApplicationInstancesResponse\n     */\n    async listWebApplicationInstancesWithOptions(ApplicationId, tmpReq, headers, runtime) {\n        tea_util_1.default.validateModel(tmpReq);\n        let request = new ListWebApplicationInstancesShrinkRequest({});\n        openapi_util_1.default.convert(tmpReq, request);\n        if (!tea_util_1.default.isUnset(tmpReq.instanceIds)) {\n            request.instanceIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, \"InstanceIds\", \"json\");\n        }\n        if (!tea_util_1.default.isUnset(tmpReq.statuses)) {\n            request.statusesShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.statuses, \"Statuses\", \"json\");\n        }\n        if (!tea_util_1.default.isUnset(tmpReq.versionIds)) {\n            request.versionIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.versionIds, \"VersionIds\", \"json\");\n        }\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.instanceIdsShrink)) {\n            query[\"InstanceIds\"] = request.instanceIdsShrink;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.statusesShrink)) {\n            query[\"Statuses\"] = request.statusesShrink;\n        }\n        if (!tea_util_1.default.isUnset(request.versionIdsShrink)) {\n            query[\"VersionIds\"] = request.versionIdsShrink;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListWebApplicationInstances\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications-observability/${openapi_util_1.default.getEncodeParam(ApplicationId)}/instances`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListWebApplicationInstancesResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - ListWebApplicationInstancesRequest\n     * @returns ListWebApplicationInstancesResponse\n     */\n    async listWebApplicationInstances(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listWebApplicationInstancesWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - ListWebApplicationRevisionsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListWebApplicationRevisionsResponse\n     */\n    async listWebApplicationRevisionsWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nextToken)) {\n            query[\"NextToken\"] = request.nextToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListWebApplicationRevisions\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-revisions/${openapi_util_1.default.getEncodeParam(ApplicationId)}/revisions`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListWebApplicationRevisionsResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - ListWebApplicationRevisionsRequest\n     * @returns ListWebApplicationRevisionsResponse\n     */\n    async listWebApplicationRevisions(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listWebApplicationRevisionsWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - ListWebApplicationsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListWebApplicationsResponse\n     */\n    async listWebApplicationsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nextToken)) {\n            query[\"NextToken\"] = request.nextToken;\n        }\n        if (!tea_util_1.default.isUnset(request.prefix)) {\n            query[\"Prefix\"] = request.prefix;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListWebApplications\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListWebApplicationsResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - ListWebApplicationsRequest\n     * @returns ListWebApplicationsResponse\n     */\n    async listWebApplications(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listWebApplicationsWithOptions(request, headers, runtime);\n    }\n    /**\n     * .\n     *\n     * @param request - ListWebCustomDomainsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ListWebCustomDomainsResponse\n     */\n    async listWebCustomDomainsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.applicationId)) {\n            query[\"ApplicationId\"] = request.applicationId;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.nextToken)) {\n            query[\"NextToken\"] = request.nextToken;\n        }\n        if (!tea_util_1.default.isUnset(request.prefix)) {\n            query[\"Prefix\"] = request.prefix;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListWebCustomDomains\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/custom-domains`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListWebCustomDomainsResponse({}));\n    }\n    /**\n     * .\n     *\n     * @param request - ListWebCustomDomainsRequest\n     * @returns ListWebCustomDomainsResponse\n     */\n    async listWebCustomDomains(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.listWebCustomDomainsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Activates the Serverless App Engine (SAE) service for free.\n     *\n     * @remarks\n     * > Make sure that your account balance is greater than 0. Otherwise, the SAE service cannot be activated.\n     *\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns OpenSaeServiceResponse\n     */\n    async openSaeServiceWithOptions(headers, runtime) {\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n        });\n        let params = new $OpenApi.Params({\n            action: \"OpenSaeService\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/service/open`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new OpenSaeServiceResponse({}));\n    }\n    /**\n     * Activates the Serverless App Engine (SAE) service for free.\n     *\n     * @remarks\n     * > Make sure that your account balance is greater than 0. Otherwise, the SAE service cannot be activated.\n     * @returns OpenSaeServiceResponse\n     */\n    async openSaeService() {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.openSaeServiceWithOptions(headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - PublishWebApplicationRevisionRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns PublishWebApplicationRevisionResponse\n     */\n    async publishWebApplicationRevisionWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"PublishWebApplicationRevision\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-revisions/${openapi_util_1.default.getEncodeParam(ApplicationId)}/revisions`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new PublishWebApplicationRevisionResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - PublishWebApplicationRevisionRequest\n     * @returns PublishWebApplicationRevisionResponse\n     */\n    async publishWebApplicationRevision(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.publishWebApplicationRevisionWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * Queries the resource usage of an application.\n     *\n     * @param request - QueryResourceStaticsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns QueryResourceStaticsResponse\n     */\n    async queryResourceStaticsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"QueryResourceStatics\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/quota/queryResourceStatics`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new QueryResourceStaticsResponse({}));\n    }\n    /**\n     * Queries the resource usage of an application.\n     *\n     * @param request - QueryResourceStaticsRequest\n     * @returns QueryResourceStaticsResponse\n     */\n    async queryResourceStatics(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.queryResourceStaticsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Reduces capacity by instance IDs.\n     *\n     * @param request - ReduceApplicationCapacityByInstanceIdsRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns ReduceApplicationCapacityByInstanceIdsResponse\n     */\n    async reduceApplicationCapacityByInstanceIdsWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.instanceIds)) {\n            query[\"InstanceIds\"] = request.instanceIds;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ReduceApplicationCapacityByInstanceIds\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/ScaleInApplicationWithInstanceIds`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ReduceApplicationCapacityByInstanceIdsResponse({}));\n    }\n    /**\n     * Reduces capacity by instance IDs.\n     *\n     * @param request - ReduceApplicationCapacityByInstanceIdsRequest\n     * @returns ReduceApplicationCapacityByInstanceIdsResponse\n     */\n    async reduceApplicationCapacityByInstanceIds(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.reduceApplicationCapacityByInstanceIdsWithOptions(request, headers, runtime);\n    }\n    /**\n     * Scales an application.\n     *\n     * @param request - RescaleApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns RescaleApplicationResponse\n     */\n    async rescaleApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.autoEnableApplicationScalingRule)) {\n            query[\"AutoEnableApplicationScalingRule\"] = request.autoEnableApplicationScalingRule;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RescaleApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/rescaleApplication`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RescaleApplicationResponse({}));\n    }\n    /**\n     * Scales an application.\n     *\n     * @param request - RescaleApplicationRequest\n     * @returns RescaleApplicationResponse\n     */\n    async rescaleApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.rescaleApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * Changes the instance specifications of an application.\n     *\n     * @param request - RescaleApplicationVerticallyRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns RescaleApplicationVerticallyResponse\n     */\n    async rescaleApplicationVerticallyWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.cpu)) {\n            query[\"Cpu\"] = request.cpu;\n        }\n        if (!tea_util_1.default.isUnset(request.memory)) {\n            query[\"Memory\"] = request.memory;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RescaleApplicationVertically\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/rescaleApplicationVertically`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RescaleApplicationVerticallyResponse({}));\n    }\n    /**\n     * Changes the instance specifications of an application.\n     *\n     * @param request - RescaleApplicationVerticallyRequest\n     * @returns RescaleApplicationVerticallyResponse\n     */\n    async rescaleApplicationVertically(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.rescaleApplicationVerticallyWithOptions(request, headers, runtime);\n    }\n    /**\n     * Restarts an application.\n     *\n     * @param request - RestartApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns RestartApplicationResponse\n     */\n    async restartApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.autoEnableApplicationScalingRule)) {\n            query[\"AutoEnableApplicationScalingRule\"] = request.autoEnableApplicationScalingRule;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RestartApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/restartApplication`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RestartApplicationResponse({}));\n    }\n    /**\n     * Restarts an application.\n     *\n     * @param request - RestartApplicationRequest\n     * @returns RestartApplicationResponse\n     */\n    async restartApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.restartApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * Restarts one or more instances in an application.\n     *\n     * @param request - RestartInstancesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns RestartInstancesResponse\n     */\n    async restartInstancesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.instanceIds)) {\n            query[\"InstanceIds\"] = request.instanceIds;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RestartInstances\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/restartInstances`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RestartInstancesResponse({}));\n    }\n    /**\n     * Restarts one or more instances in an application.\n     *\n     * @param request - RestartInstancesRequest\n     * @returns RestartInstancesResponse\n     */\n    async restartInstances(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.restartInstancesWithOptions(request, headers, runtime);\n    }\n    /**\n     * Rolls back an application.\n     *\n     * @param request - RollbackApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns RollbackApplicationResponse\n     */\n    async rollbackApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.autoEnableApplicationScalingRule)) {\n            query[\"AutoEnableApplicationScalingRule\"] = request.autoEnableApplicationScalingRule;\n        }\n        if (!tea_util_1.default.isUnset(request.batchWaitTime)) {\n            query[\"BatchWaitTime\"] = request.batchWaitTime;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        if (!tea_util_1.default.isUnset(request.updateStrategy)) {\n            query[\"UpdateStrategy\"] = request.updateStrategy;\n        }\n        if (!tea_util_1.default.isUnset(request.versionId)) {\n            query[\"VersionId\"] = request.versionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RollbackApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/rollbackApplication`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RollbackApplicationResponse({}));\n    }\n    /**\n     * Rolls back an application.\n     *\n     * @param request - RollbackApplicationRequest\n     * @returns RollbackApplicationResponse\n     */\n    async rollbackApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.rollbackApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * Starts an application.\n     *\n     * @param request - StartApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns StartApplicationResponse\n     */\n    async startApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StartApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/startApplication`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StartApplicationResponse({}));\n    }\n    /**\n     * Starts an application.\n     *\n     * @param request - StartApplicationRequest\n     * @returns StartApplicationResponse\n     */\n    async startApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.startApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - StartWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns StartWebApplicationResponse\n     */\n    async startWebApplicationWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StartWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-ops/${openapi_util_1.default.getEncodeParam(ApplicationId)}/start`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StartWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - StartWebApplicationRequest\n     * @returns StartWebApplicationResponse\n     */\n    async startWebApplication(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.startWebApplicationWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * 0099b7be-5f5b-4512-a7fc-56049ef1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - StopApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns StopApplicationResponse\n     */\n    async stopApplicationWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StopApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/stopApplication`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StopApplicationResponse({}));\n    }\n    /**\n     * 0099b7be-5f5b-4512-a7fc-56049ef1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - StopApplicationRequest\n     * @returns StopApplicationResponse\n     */\n    async stopApplication(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.stopApplicationWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - StopWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns StopWebApplicationResponse\n     */\n    async stopWebApplicationWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StopWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-ops/${openapi_util_1.default.getEncodeParam(ApplicationId)}/stop`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StopWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - StopWebApplicationRequest\n     * @returns StopWebApplicationResponse\n     */\n    async stopWebApplication(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.stopWebApplicationWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * Suspends a job.\n     *\n     * @param request - SuspendJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns SuspendJobResponse\n     */\n    async suspendJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.suspend)) {\n            query[\"Suspend\"] = request.suspend;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SuspendJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/suspendJob`,\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SuspendJobResponse({}));\n    }\n    /**\n     * Suspends a job.\n     *\n     * @param request - SuspendJobRequest\n     * @returns SuspendJobResponse\n     */\n    async suspendJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.suspendJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * cn-beijing\n     *\n     * @param request - TagResourcesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns TagResourcesResponse\n     */\n    async tagResourcesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            body[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceIds)) {\n            body[\"ResourceIds\"] = request.resourceIds;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            body[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tags)) {\n            body[\"Tags\"] = request.tags;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"TagResources\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/tags`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));\n    }\n    /**\n     * cn-beijing\n     *\n     * @param request - TagResourcesRequest\n     * @returns TagResourcesResponse\n     */\n    async tagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.tagResourcesWithOptions(request, headers, runtime);\n    }\n    /**\n     * 0099b7be-5f5b-4512-a7fc-56049ef1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - UnbindSlbRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UnbindSlbResponse\n     */\n    async unbindSlbWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.internet)) {\n            query[\"Internet\"] = request.internet;\n        }\n        if (!tea_util_1.default.isUnset(request.intranet)) {\n            query[\"Intranet\"] = request.intranet;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UnbindSlb\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/slb`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UnbindSlbResponse({}));\n    }\n    /**\n     * 0099b7be-5f5b-4512-a7fc-56049ef1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - UnbindSlbRequest\n     * @returns UnbindSlbResponse\n     */\n    async unbindSlb(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.unbindSlbWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - UntagResourcesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UntagResourcesResponse\n     */\n    async untagResourcesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.deleteAll)) {\n            query[\"DeleteAll\"] = request.deleteAll;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceIds)) {\n            query[\"ResourceIds\"] = request.resourceIds;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            query[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tagKeys)) {\n            query[\"TagKeys\"] = request.tagKeys;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UntagResources\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/tags`,\n            method: \"DELETE\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));\n    }\n    /**\n     * @param request - UntagResourcesRequest\n     * @returns UntagResourcesResponse\n     */\n    async untagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.untagResourcesWithOptions(request, headers, runtime);\n    }\n    /**\n     * 017f39b8-dfa4-4e16-a84b-1dcee4b1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - UpdateAppSecurityGroupRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateAppSecurityGroupResponse\n     */\n    async updateAppSecurityGroupWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityGroupId)) {\n            query[\"SecurityGroupId\"] = request.securityGroupId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateAppSecurityGroup\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/updateAppSecurityGroup`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateAppSecurityGroupResponse({}));\n    }\n    /**\n     * 017f39b8-dfa4-4e16-a84b-1dcee4b1\\\\*\\\\*\\\\*\\\\*\n     *\n     * @param request - UpdateAppSecurityGroupRequest\n     * @returns UpdateAppSecurityGroupResponse\n     */\n    async updateAppSecurityGroup(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateAppSecurityGroupWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - UpdateApplicationDescriptionRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateApplicationDescriptionResponse\n     */\n    async updateApplicationDescriptionWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appDescription)) {\n            query[\"AppDescription\"] = request.appDescription;\n        }\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateApplicationDescription\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/updateAppDescription`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateApplicationDescriptionResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - UpdateApplicationDescriptionRequest\n     * @returns UpdateApplicationDescriptionResponse\n     */\n    async updateApplicationDescription(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateApplicationDescriptionWithOptions(request, headers, runtime);\n    }\n    /**\n     * Updates the auto scaling policy of an application.\n     *\n     * @remarks\n     * ##\n     * If you want to configure more than 50 instances for an application, you must submit a [ticket](https://workorder.console.aliyun.com/#/ticket/createIndex) to add your account to the whitelist.\n     *\n     * @param request - UpdateApplicationScalingRuleRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateApplicationScalingRuleResponse\n     */\n    async updateApplicationScalingRuleWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstanceRatio)) {\n            query[\"MinReadyInstanceRatio\"] = request.minReadyInstanceRatio;\n        }\n        if (!tea_util_1.default.isUnset(request.minReadyInstances)) {\n            query[\"MinReadyInstances\"] = request.minReadyInstances;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleMetric)) {\n            query[\"ScalingRuleMetric\"] = request.scalingRuleMetric;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleName)) {\n            query[\"ScalingRuleName\"] = request.scalingRuleName;\n        }\n        if (!tea_util_1.default.isUnset(request.scalingRuleTimer)) {\n            query[\"ScalingRuleTimer\"] = request.scalingRuleTimer;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateApplicationScalingRule\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/scale/applicationScalingRule`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateApplicationScalingRuleResponse({}));\n    }\n    /**\n     * Updates the auto scaling policy of an application.\n     *\n     * @remarks\n     * ##\n     * If you want to configure more than 50 instances for an application, you must submit a [ticket](https://workorder.console.aliyun.com/#/ticket/createIndex) to add your account to the whitelist.\n     *\n     * @param request - UpdateApplicationScalingRuleRequest\n     * @returns UpdateApplicationScalingRuleResponse\n     */\n    async updateApplicationScalingRule(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateApplicationScalingRuleWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - UpdateApplicationVswitchesRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateApplicationVswitchesResponse\n     */\n    async updateApplicationVswitchesWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.vSwitchId)) {\n            query[\"VSwitchId\"] = request.vSwitchId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateApplicationVswitches\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/app/updateAppVswitches`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateApplicationVswitchesResponse({}));\n    }\n    /**\n     * @param request - UpdateApplicationVswitchesRequest\n     * @returns UpdateApplicationVswitchesResponse\n     */\n    async updateApplicationVswitches(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateApplicationVswitchesWithOptions(request, headers, runtime);\n    }\n    /**\n     * 1\n     *\n     * @param request - UpdateConfigMapRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateConfigMapResponse\n     */\n    async updateConfigMapWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configMapId)) {\n            query[\"ConfigMapId\"] = request.configMapId;\n        }\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.data)) {\n            body[\"Data\"] = request.data;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateConfigMap\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/configmap/configMap`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateConfigMapResponse({}));\n    }\n    /**\n     * 1\n     *\n     * @param request - UpdateConfigMapRequest\n     * @returns UpdateConfigMapResponse\n     */\n    async updateConfigMap(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateConfigMapWithOptions(request, headers, runtime);\n    }\n    /**\n     * Updates a canary release rule.\n     *\n     * @param request - UpdateGreyTagRouteRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateGreyTagRouteResponse\n     */\n    async updateGreyTagRouteWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.albRules)) {\n            query[\"AlbRules\"] = request.albRules;\n        }\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        if (!tea_util_1.default.isUnset(request.dubboRules)) {\n            query[\"DubboRules\"] = request.dubboRules;\n        }\n        if (!tea_util_1.default.isUnset(request.greyTagRouteId)) {\n            query[\"GreyTagRouteId\"] = request.greyTagRouteId;\n        }\n        if (!tea_util_1.default.isUnset(request.scRules)) {\n            query[\"ScRules\"] = request.scRules;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateGreyTagRoute\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/tagroute/greyTagRoute`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateGreyTagRouteResponse({}));\n    }\n    /**\n     * Updates a canary release rule.\n     *\n     * @param request - UpdateGreyTagRouteRequest\n     * @returns UpdateGreyTagRouteResponse\n     */\n    async updateGreyTagRoute(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateGreyTagRouteWithOptions(request, headers, runtime);\n    }\n    /**\n     * @param request - UpdateIngressRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateIngressResponse\n     */\n    async updateIngressWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certId)) {\n            query[\"CertId\"] = request.certId;\n        }\n        if (!tea_util_1.default.isUnset(request.certIds)) {\n            query[\"CertIds\"] = request.certIds;\n        }\n        if (!tea_util_1.default.isUnset(request.defaultRule)) {\n            query[\"DefaultRule\"] = request.defaultRule;\n        }\n        if (!tea_util_1.default.isUnset(request.description)) {\n            query[\"Description\"] = request.description;\n        }\n        if (!tea_util_1.default.isUnset(request.ingressId)) {\n            query[\"IngressId\"] = request.ingressId;\n        }\n        if (!tea_util_1.default.isUnset(request.listenerPort)) {\n            query[\"ListenerPort\"] = request.listenerPort;\n        }\n        if (!tea_util_1.default.isUnset(request.listenerProtocol)) {\n            query[\"ListenerProtocol\"] = request.listenerProtocol;\n        }\n        if (!tea_util_1.default.isUnset(request.loadBalanceType)) {\n            query[\"LoadBalanceType\"] = request.loadBalanceType;\n        }\n        if (!tea_util_1.default.isUnset(request.requestTimeout)) {\n            query[\"RequestTimeout\"] = request.requestTimeout;\n        }\n        if (!tea_util_1.default.isUnset(request.securityPolicyId)) {\n            query[\"SecurityPolicyId\"] = request.securityPolicyId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.rules)) {\n            body[\"Rules\"] = request.rules;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateIngress\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/ingress/Ingress`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateIngressResponse({}));\n    }\n    /**\n     * @param request - UpdateIngressRequest\n     * @returns UpdateIngressResponse\n     */\n    async updateIngress(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateIngressWithOptions(request, headers, runtime);\n    }\n    /**\n     * Updates a job template.\n     *\n     * @param request - UpdateJobRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateJobResponse\n     */\n    async updateJobWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.acrAssumeRoleArn)) {\n            query[\"AcrAssumeRoleArn\"] = request.acrAssumeRoleArn;\n        }\n        if (!tea_util_1.default.isUnset(request.appId)) {\n            query[\"AppId\"] = request.appId;\n        }\n        if (!tea_util_1.default.isUnset(request.backoffLimit)) {\n            query[\"BackoffLimit\"] = request.backoffLimit;\n        }\n        if (!tea_util_1.default.isUnset(request.command)) {\n            query[\"Command\"] = request.command;\n        }\n        if (!tea_util_1.default.isUnset(request.commandArgs)) {\n            query[\"CommandArgs\"] = request.commandArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.concurrencyPolicy)) {\n            query[\"ConcurrencyPolicy\"] = request.concurrencyPolicy;\n        }\n        if (!tea_util_1.default.isUnset(request.customHostAlias)) {\n            query[\"CustomHostAlias\"] = request.customHostAlias;\n        }\n        if (!tea_util_1.default.isUnset(request.edasContainerVersion)) {\n            query[\"EdasContainerVersion\"] = request.edasContainerVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.envs)) {\n            query[\"Envs\"] = request.envs;\n        }\n        if (!tea_util_1.default.isUnset(request.imagePullSecrets)) {\n            query[\"ImagePullSecrets\"] = request.imagePullSecrets;\n        }\n        if (!tea_util_1.default.isUnset(request.imageUrl)) {\n            query[\"ImageUrl\"] = request.imageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartArgs)) {\n            query[\"JarStartArgs\"] = request.jarStartArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.jarStartOptions)) {\n            query[\"JarStartOptions\"] = request.jarStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.jdk)) {\n            query[\"Jdk\"] = request.jdk;\n        }\n        if (!tea_util_1.default.isUnset(request.mountDesc)) {\n            query[\"MountDesc\"] = request.mountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.mountHost)) {\n            query[\"MountHost\"] = request.mountHost;\n        }\n        if (!tea_util_1.default.isUnset(request.nasId)) {\n            query[\"NasId\"] = request.nasId;\n        }\n        if (!tea_util_1.default.isUnset(request.packageUrl)) {\n            query[\"PackageUrl\"] = request.packageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.packageVersion)) {\n            query[\"PackageVersion\"] = request.packageVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfigLocation)) {\n            query[\"PhpConfigLocation\"] = request.phpConfigLocation;\n        }\n        if (!tea_util_1.default.isUnset(request.postStart)) {\n            query[\"PostStart\"] = request.postStart;\n        }\n        if (!tea_util_1.default.isUnset(request.preStop)) {\n            query[\"PreStop\"] = request.preStop;\n        }\n        if (!tea_util_1.default.isUnset(request.programmingLanguage)) {\n            query[\"ProgrammingLanguage\"] = request.programmingLanguage;\n        }\n        if (!tea_util_1.default.isUnset(request.python)) {\n            query[\"Python\"] = request.python;\n        }\n        if (!tea_util_1.default.isUnset(request.pythonModules)) {\n            query[\"PythonModules\"] = request.pythonModules;\n        }\n        if (!tea_util_1.default.isUnset(request.refAppId)) {\n            query[\"RefAppId\"] = request.refAppId;\n        }\n        if (!tea_util_1.default.isUnset(request.replicas)) {\n            query[\"Replicas\"] = request.replicas;\n        }\n        if (!tea_util_1.default.isUnset(request.slice)) {\n            query[\"Slice\"] = request.slice;\n        }\n        if (!tea_util_1.default.isUnset(request.sliceEnvs)) {\n            query[\"SliceEnvs\"] = request.sliceEnvs;\n        }\n        if (!tea_util_1.default.isUnset(request.slsConfigs)) {\n            query[\"SlsConfigs\"] = request.slsConfigs;\n        }\n        if (!tea_util_1.default.isUnset(request.terminationGracePeriodSeconds)) {\n            query[\"TerminationGracePeriodSeconds\"] = request.terminationGracePeriodSeconds;\n        }\n        if (!tea_util_1.default.isUnset(request.timeout)) {\n            query[\"Timeout\"] = request.timeout;\n        }\n        if (!tea_util_1.default.isUnset(request.timezone)) {\n            query[\"Timezone\"] = request.timezone;\n        }\n        if (!tea_util_1.default.isUnset(request.tomcatConfig)) {\n            query[\"TomcatConfig\"] = request.tomcatConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerConfig)) {\n            query[\"TriggerConfig\"] = request.triggerConfig;\n        }\n        if (!tea_util_1.default.isUnset(request.warStartOptions)) {\n            query[\"WarStartOptions\"] = request.warStartOptions;\n        }\n        if (!tea_util_1.default.isUnset(request.webContainer)) {\n            query[\"WebContainer\"] = request.webContainer;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.acrInstanceId)) {\n            body[\"AcrInstanceId\"] = request.acrInstanceId;\n        }\n        if (!tea_util_1.default.isUnset(request.configMapMountDesc)) {\n            body[\"ConfigMapMountDesc\"] = request.configMapMountDesc;\n        }\n        if (!tea_util_1.default.isUnset(request.enableImageAccl)) {\n            body[\"EnableImageAccl\"] = request.enableImageAccl;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkId)) {\n            body[\"OssAkId\"] = request.ossAkId;\n        }\n        if (!tea_util_1.default.isUnset(request.ossAkSecret)) {\n            body[\"OssAkSecret\"] = request.ossAkSecret;\n        }\n        if (!tea_util_1.default.isUnset(request.ossMountDescs)) {\n            body[\"OssMountDescs\"] = request.ossMountDescs;\n        }\n        if (!tea_util_1.default.isUnset(request.php)) {\n            body[\"Php\"] = request.php;\n        }\n        if (!tea_util_1.default.isUnset(request.phpConfig)) {\n            body[\"PhpConfig\"] = request.phpConfig;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateJob\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/job/updateJob`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateJobResponse({}));\n    }\n    /**\n     * Updates a job template.\n     *\n     * @param request - UpdateJobRequest\n     * @returns UpdateJobResponse\n     */\n    async updateJob(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateJobWithOptions(request, headers, runtime);\n    }\n    /**\n     * Updates the information about a namespace.\n     *\n     * @param request - UpdateNamespaceRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateNamespaceResponse\n     */\n    async updateNamespaceWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.enableMicroRegistration)) {\n            query[\"EnableMicroRegistration\"] = request.enableMicroRegistration;\n        }\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceDescription)) {\n            query[\"NamespaceDescription\"] = request.namespaceDescription;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceName)) {\n            query[\"NamespaceName\"] = request.namespaceName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateNamespace\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/paas/namespace`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateNamespaceResponse({}));\n    }\n    /**\n     * Updates the information about a namespace.\n     *\n     * @param request - UpdateNamespaceRequest\n     * @returns UpdateNamespaceResponse\n     */\n    async updateNamespace(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateNamespaceWithOptions(request, headers, runtime);\n    }\n    /**\n     * cn-beijing:test\n     *\n     * @param request - UpdateNamespaceVpcRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateNamespaceVpcResponse\n     */\n    async updateNamespaceVpcWithOptions(request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.nameSpaceShortId)) {\n            query[\"NameSpaceShortId\"] = request.nameSpaceShortId;\n        }\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.vpcId)) {\n            query[\"VpcId\"] = request.vpcId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateNamespaceVpc\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/namespace/updateNamespaceVpc`,\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateNamespaceVpcResponse({}));\n    }\n    /**\n     * cn-beijing:test\n     *\n     * @param request - UpdateNamespaceVpcRequest\n     * @returns UpdateNamespaceVpcResponse\n     */\n    async updateNamespaceVpc(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateNamespaceVpcWithOptions(request, headers, runtime);\n    }\n    /**\n     * The HTTP status code. Valid values:\n     * *   **2xx**: The call was successful.\n     * *   **3xx**: The call was redirected.\n     * *   **4xx**: The call failed.\n     * *   **5xx**: A server error occurred.\n     *\n     * @param tmpReq - UpdateSecretRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateSecretResponse\n     */\n    async updateSecretWithOptions(tmpReq, headers, runtime) {\n        tea_util_1.default.validateModel(tmpReq);\n        let request = new UpdateSecretShrinkRequest({});\n        openapi_util_1.default.convert(tmpReq, request);\n        if (!tea_util_1.default.isUnset(tmpReq.secretData)) {\n            request.secretDataShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.secretData, \"SecretData\", \"json\");\n        }\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        if (!tea_util_1.default.isUnset(request.secretDataShrink)) {\n            query[\"SecretData\"] = request.secretDataShrink;\n        }\n        if (!tea_util_1.default.isUnset(request.secretId)) {\n            query[\"SecretId\"] = request.secretId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateSecret\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v1/sam/secret/secret`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSecretResponse({}));\n    }\n    /**\n     * The HTTP status code. Valid values:\n     * *   **2xx**: The call was successful.\n     * *   **3xx**: The call was redirected.\n     * *   **4xx**: The call failed.\n     * *   **5xx**: A server error occurred.\n     *\n     * @param request - UpdateSecretRequest\n     * @returns UpdateSecretResponse\n     */\n    async updateSecret(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateSecretWithOptions(request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateWebApplicationResponse\n     */\n    async updateWebApplicationWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateWebApplication\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/applications/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateWebApplicationResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationRequest\n     * @returns UpdateWebApplicationResponse\n     */\n    async updateWebApplication(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateWebApplicationWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationScalingConfigRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateWebApplicationScalingConfigResponse\n     */\n    async updateWebApplicationScalingConfigWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateWebApplicationScalingConfig\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-scaling/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateWebApplicationScalingConfigResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationScalingConfigRequest\n     * @returns UpdateWebApplicationScalingConfigResponse\n     */\n    async updateWebApplicationScalingConfig(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateWebApplicationScalingConfigWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationTrafficConfigRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateWebApplicationTrafficConfigResponse\n     */\n    async updateWebApplicationTrafficConfigWithOptions(ApplicationId, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateWebApplicationTrafficConfig\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/application-traffic/${openapi_util_1.default.getEncodeParam(ApplicationId)}`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateWebApplicationTrafficConfigResponse({}));\n    }\n    /**\n     * \n     *\n     * @param request - UpdateWebApplicationTrafficConfigRequest\n     * @returns UpdateWebApplicationTrafficConfigResponse\n     */\n    async updateWebApplicationTrafficConfig(ApplicationId, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateWebApplicationTrafficConfigWithOptions(ApplicationId, request, headers, runtime);\n    }\n    /**\n     * .\n     *\n     * @param request - UpdateWebCustomDomainRequest\n     * @param headers - map\n     * @param runtime - runtime options for this request RuntimeOptions\n     * @returns UpdateWebCustomDomainResponse\n     */\n    async updateWebCustomDomainWithOptions(DomainName, request, headers, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.namespaceId)) {\n            query[\"NamespaceId\"] = request.namespaceId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            headers: headers,\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(request.body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateWebCustomDomain\",\n            version: \"2019-05-06\",\n            protocol: \"HTTPS\",\n            pathname: `/pop/v2/api/web/custom-domains/${openapi_util_1.default.getEncodeParam(DomainName)}`,\n            method: \"PUT\",\n            authType: \"AK\",\n            style: \"ROA\",\n            reqBodyType: \"json\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateWebCustomDomainResponse({}));\n    }\n    /**\n     * .\n     *\n     * @param request - UpdateWebCustomDomainRequest\n     * @returns UpdateWebCustomDomainResponse\n     */\n    async updateWebCustomDomain(DomainName, request) {\n        let runtime = new $Util.RuntimeOptions({});\n        let headers = {};\n        return await this.updateWebCustomDomainWithOptions(DomainName, request, headers, runtime);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isRetryable = exports.retryError = exports.newUnretryableError = exports.getBackoffTime = exports.allowRetry = exports.sleep = exports.cast = exports.Model = exports.toMap = exports.newError = exports.doAction = exports.Response = exports.Request = exports.BytesReadable = void 0;\nvar querystring = __importStar(require(\"querystring\"));\nvar http_1 = require(\"http\");\nvar https_1 = require(\"https\");\nvar stream_1 = require(\"stream\");\nvar httpx = __importStar(require(\"httpx\"));\nvar url_1 = require(\"url\");\nvar BytesReadable = /** @class */ (function (_super) {\n    __extends(BytesReadable, _super);\n    function BytesReadable(value) {\n        var _this = _super.call(this) || this;\n        if (typeof value === 'string') {\n            _this.value = Buffer.from(value);\n        }\n        else if (Buffer.isBuffer(value)) {\n            _this.value = value;\n        }\n        return _this;\n    }\n    BytesReadable.prototype._read = function () {\n        this.push(this.value);\n        this.push(null);\n    };\n    return BytesReadable;\n}(stream_1.Readable));\nexports.BytesReadable = BytesReadable;\nvar Request = /** @class */ (function () {\n    function Request() {\n        this.headers = {};\n        this.query = {};\n    }\n    return Request;\n}());\nexports.Request = Request;\nvar Response = /** @class */ (function () {\n    function Response(httpResponse) {\n        this.statusCode = httpResponse.statusCode;\n        this.statusMessage = httpResponse.statusMessage;\n        this.headers = this.convertHeaders(httpResponse.headers);\n        this.body = httpResponse;\n    }\n    Response.prototype.convertHeaders = function (headers) {\n        var results = {};\n        var keys = Object.keys(headers);\n        for (var index = 0; index < keys.length; index++) {\n            var key = keys[index];\n            results[key] = headers[key];\n        }\n        return results;\n    };\n    Response.prototype.readBytes = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var buff;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, httpx.read(this.body, '')];\n                    case 1:\n                        buff = _a.sent();\n                        return [2 /*return*/, buff];\n                }\n            });\n        });\n    };\n    return Response;\n}());\nexports.Response = Response;\nfunction buildURL(request) {\n    var url = request.protocol + \"://\" + request.headers['host'];\n    if (request.port) {\n        url += \":\" + request.port;\n    }\n    url += \"\" + request.pathname;\n    var urlInfo = url_1.parse(url);\n    if (request.query && Object.keys(request.query).length > 0) {\n        if (urlInfo.query) {\n            url += \"&\" + querystring.stringify(request.query);\n        }\n        else {\n            url += \"?\" + querystring.stringify(request.query);\n        }\n    }\n    return url;\n}\nfunction isModelClass(t) {\n    if (!t) {\n        return false;\n    }\n    return typeof t.types === 'function' && typeof t.names === 'function';\n}\nfunction doAction(request, runtime) {\n    if (runtime === void 0) { runtime = null; }\n    return __awaiter(this, void 0, void 0, function () {\n        var url, method, options, agentOptions, response;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    url = buildURL(request);\n                    method = (request.method || 'GET').toUpperCase();\n                    options = {\n                        method: method,\n                        headers: request.headers\n                    };\n                    if (method !== 'GET' && method !== 'HEAD') {\n                        options.data = request.body;\n                    }\n                    if (runtime) {\n                        if (typeof runtime.timeout !== 'undefined') {\n                            options.timeout = Number(runtime.timeout);\n                        }\n                        if (typeof runtime.readTimeout !== 'undefined') {\n                            options.readTimeout = Number(runtime.readTimeout);\n                        }\n                        if (typeof runtime.connectTimeout !== 'undefined') {\n                            options.connectTimeout = Number(runtime.connectTimeout);\n                        }\n                        if (typeof runtime.ignoreSSL !== 'undefined') {\n                            options.rejectUnauthorized = !runtime.ignoreSSL;\n                        }\n                        if (typeof runtime.key !== 'undefined') {\n                            options.key = String(runtime.key);\n                        }\n                        if (typeof runtime.cert !== 'undefined') {\n                            options.cert = String(runtime.cert);\n                        }\n                        if (typeof runtime.ca !== 'undefined') {\n                            options.ca = String(runtime.ca);\n                        }\n                        agentOptions = {\n                            keepAlive: true,\n                        };\n                        if (typeof runtime.keepAlive !== 'undefined') {\n                            agentOptions.keepAlive = runtime.keepAlive;\n                            if (request.protocol && request.protocol.toLowerCase() === 'https') {\n                                options.agent = new https_1.Agent(agentOptions);\n                            }\n                            else {\n                                options.agent = new http_1.Agent(agentOptions);\n                            }\n                        }\n                    }\n                    return [4 /*yield*/, httpx.request(url, options)];\n                case 1:\n                    response = _a.sent();\n                    return [2 /*return*/, new Response(response)];\n            }\n        });\n    });\n}\nexports.doAction = doAction;\nvar ResponseError = /** @class */ (function (_super) {\n    __extends(ResponseError, _super);\n    function ResponseError(map) {\n        var _this = _super.call(this, map.code + \": \" + map.message) || this;\n        _this.code = map.code;\n        _this.data = map.data;\n        _this.description = map.description;\n        _this.accessDeniedDetail = map.accessDeniedDetail;\n        if (_this.data && _this.data.statusCode) {\n            _this.statusCode = Number(_this.data.statusCode);\n        }\n        return _this;\n    }\n    return ResponseError;\n}(Error));\nfunction newError(data) {\n    return new ResponseError(data);\n}\nexports.newError = newError;\nfunction getValue(type, value) {\n    if (typeof type === 'string') {\n        // basic type\n        return value;\n    }\n    if (type.type === 'array') {\n        if (!Array.isArray(value)) {\n            throw new Error(\"expect: array, actual: \" + typeof value);\n        }\n        return value.map(function (item) {\n            return getValue(type.itemType, item);\n        });\n    }\n    if (typeof type === 'function') {\n        if (isModelClass(type)) {\n            return new type(value);\n        }\n        return value;\n    }\n    return value;\n}\nfunction toMap(value) {\n    if (value === void 0) { value = undefined; }\n    if (typeof value === 'undefined' || value == null) {\n        return null;\n    }\n    if (value instanceof Model) {\n        return value.toMap();\n    }\n    //  tea-typescript  modelinstanceof \n    // \n    if (typeof value.toMap === 'function') {\n        return value.toMap();\n    }\n    if (Array.isArray(value)) {\n        return value.map(function (item) {\n            return toMap(item);\n        });\n    }\n    return value;\n}\nexports.toMap = toMap;\nvar Model = /** @class */ (function () {\n    function Model(map) {\n        var _this = this;\n        if (map == null) {\n            return;\n        }\n        var clz = this.constructor;\n        var names = clz.names();\n        var types = clz.types();\n        Object.keys(names).forEach((function (name) {\n            var value = map[name];\n            if (value === undefined || value === null) {\n                return;\n            }\n            var type = types[name];\n            _this[name] = getValue(type, value);\n        }));\n    }\n    Model.prototype.toMap = function () {\n        var _this = this;\n        var map = {};\n        var clz = this.constructor;\n        var names = clz.names();\n        Object.keys(names).forEach((function (name) {\n            var originName = names[name];\n            var value = _this[name];\n            if (typeof value === 'undefined' || value == null) {\n                return;\n            }\n            map[originName] = toMap(value);\n        }));\n        return map;\n    };\n    return Model;\n}());\nexports.Model = Model;\nfunction cast(obj, t) {\n    if (!obj) {\n        throw new Error('can not cast to Map');\n    }\n    if (typeof obj !== 'object') {\n        throw new Error('can not cast to Map');\n    }\n    var map = obj;\n    var clz = t.constructor;\n    var names = clz.names();\n    var types = clz.types();\n    Object.keys(names).forEach(function (key) {\n        var originName = names[key];\n        var value = map[originName];\n        var type = types[key];\n        if (typeof value === 'undefined' || value == null) {\n            return;\n        }\n        if (typeof type === 'string') {\n            if (type === 'Readable' ||\n                type === 'map' ||\n                type === 'Buffer' ||\n                type === 'any' ||\n                typeof value === type) {\n                t[key] = value;\n                return;\n            }\n            if (type === 'string' &&\n                (typeof value === 'number' ||\n                    typeof value === 'boolean')) {\n                t[key] = value.toString();\n                return;\n            }\n            if (type === 'boolean') {\n                if (value === 1 || value === 0) {\n                    t[key] = !!value;\n                    return;\n                }\n                if (value === 'true' || value === 'false') {\n                    t[key] = value === 'true';\n                    return;\n                }\n            }\n            if (type === 'number' && typeof value === 'string') {\n                if (value.match(/^\\d*$/)) {\n                    t[key] = parseInt(value);\n                    return;\n                }\n                if (value.match(/^[\\.\\d]*$/)) {\n                    t[key] = parseFloat(value);\n                    return;\n                }\n            }\n            throw new Error(\"type of \" + key + \" is mismatch, expect \" + type + \", but \" + typeof value);\n        }\n        else if (type.type === 'map') {\n            if (!(value instanceof Object)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect object, but \" + typeof value);\n            }\n            t[key] = value;\n        }\n        else if (type.type === 'array') {\n            if (!Array.isArray(value)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect array, but \" + typeof value);\n            }\n            if (typeof type.itemType === 'function') {\n                t[key] = value.map(function (d) {\n                    if (isModelClass(type.itemType)) {\n                        return cast(d, new type.itemType({}));\n                    }\n                    return d;\n                });\n            }\n            else {\n                t[key] = value;\n            }\n        }\n        else if (typeof type === 'function') {\n            if (!(value instanceof Object)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect object, but \" + typeof value);\n            }\n            if (isModelClass(type)) {\n                t[key] = cast(value, new type({}));\n                return;\n            }\n            t[key] = value;\n        }\n        else {\n        }\n    });\n    return t;\n}\nexports.cast = cast;\nfunction sleep(ms) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\nexports.sleep = sleep;\nfunction allowRetry(retry, retryTimes, startTime) {\n    // \n    if (retryTimes === 0) {\n        return true;\n    }\n    if (retry.retryable !== true) {\n        return false;\n    }\n    if (retry.policy === 'never') {\n        return false;\n    }\n    if (retry.policy === 'always') {\n        return true;\n    }\n    if (retry.policy === 'simple') {\n        return (retryTimes < retry['maxAttempts']);\n    }\n    if (retry.policy === 'timeout') {\n        return Date.now() - startTime < retry.timeout;\n    }\n    if (retry.maxAttempts && typeof retry.maxAttempts === 'number') {\n        return retry.maxAttempts >= retryTimes;\n    }\n    // \n    return false;\n}\nexports.allowRetry = allowRetry;\nfunction getBackoffTime(backoff, retryTimes) {\n    if (retryTimes === 0) {\n        // \n        return 0;\n    }\n    if (backoff.policy === 'no') {\n        // \n        return 0;\n    }\n    if (backoff.policy === 'fixed') {\n        // \n        return backoff.period;\n    }\n    if (backoff.policy === 'random') {\n        // \n        var min = backoff['minPeriod'];\n        var max = backoff['maxPeriod'];\n        return min + (max - min) * Math.random();\n    }\n    if (backoff.policy === 'exponential') {\n        // \n        var init = backoff.initial;\n        var multiplier = backoff.multiplier;\n        var time = init * Math.pow(1 + multiplier, retryTimes - 1);\n        var max = backoff.max;\n        return Math.min(time, max);\n    }\n    if (backoff.policy === 'exponential_random') {\n        // \n        var init = backoff.initial;\n        var multiplier = backoff.multiplier;\n        var time = init * Math.pow(1 + multiplier, retryTimes - 1);\n        var max = backoff.max;\n        return Math.min(time * (0.5 + Math.random()), max);\n    }\n    return 0;\n}\nexports.getBackoffTime = getBackoffTime;\nvar UnretryableError = /** @class */ (function (_super) {\n    __extends(UnretryableError, _super);\n    function UnretryableError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'UnretryableError';\n        return _this;\n    }\n    return UnretryableError;\n}(Error));\nfunction newUnretryableError(request) {\n    var e = new UnretryableError('');\n    e.data = {\n        lastRequest: request\n    };\n    return e;\n}\nexports.newUnretryableError = newUnretryableError;\nvar RetryError = /** @class */ (function (_super) {\n    __extends(RetryError, _super);\n    function RetryError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RetryError';\n        return _this;\n    }\n    return RetryError;\n}(Error));\nfunction retryError(request, response) {\n    var e = new RetryError('');\n    e.data = {\n        request: request,\n        response: response\n    };\n    return e;\n}\nexports.retryError = retryError;\nfunction isRetryable(err) {\n    if (typeof err === 'undefined' || err === null) {\n        return false;\n    }\n    return err.name === 'RetryError';\n}\nexports.isRetryable = isRetryable;\n//# sourceMappingURL=tea.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RuntimeOptions = exports.ExtendsParameters = void 0;\nconst stream_1 = require(\"stream\");\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst os_1 = require(\"os\");\nconst DEFAULT_USER_AGENT = `AlibabaCloud (${os_1.platform()}; ${os_1.arch()}) Node.js/${process.version} Core/1.0.1 TeaDSL/1`;\nclass ExtendsParameters extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            queries: 'queries',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            queries: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n        };\n    }\n}\nexports.ExtendsParameters = ExtendsParameters;\nclass RuntimeOptions extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            autoretry: 'autoretry',\n            ignoreSSL: 'ignoreSSL',\n            key: 'key',\n            cert: 'cert',\n            ca: 'ca',\n            maxAttempts: 'max_attempts',\n            backoffPolicy: 'backoff_policy',\n            backoffPeriod: 'backoff_period',\n            readTimeout: 'readTimeout',\n            connectTimeout: 'connectTimeout',\n            httpProxy: 'httpProxy',\n            httpsProxy: 'httpsProxy',\n            noProxy: 'noProxy',\n            maxIdleConns: 'maxIdleConns',\n            keepAlive: 'keepAlive',\n            extendsParameters: 'extendsParameters',\n        };\n    }\n    static types() {\n        return {\n            autoretry: 'boolean',\n            ignoreSSL: 'boolean',\n            key: 'string',\n            cert: 'string',\n            ca: 'string',\n            maxAttempts: 'number',\n            backoffPolicy: 'string',\n            backoffPeriod: 'number',\n            readTimeout: 'number',\n            connectTimeout: 'number',\n            httpProxy: 'string',\n            httpsProxy: 'string',\n            noProxy: 'string',\n            maxIdleConns: 'number',\n            keepAlive: 'boolean',\n            extendsParameters: ExtendsParameters,\n        };\n    }\n}\nexports.RuntimeOptions = RuntimeOptions;\nfunction read(readable) {\n    return new Promise((resolve, reject) => {\n        let onData, onError, onEnd;\n        var cleanup = function () {\n            // cleanup\n            readable.removeListener('error', onError);\n            readable.removeListener('data', onData);\n            readable.removeListener('end', onEnd);\n        };\n        var bufs = [];\n        var size = 0;\n        onData = function (buf) {\n            bufs.push(buf);\n            size += buf.length;\n        };\n        onError = function (err) {\n            cleanup();\n            reject(err);\n        };\n        onEnd = function () {\n            cleanup();\n            resolve(Buffer.concat(bufs, size));\n        };\n        readable.on('error', onError);\n        readable.on('data', onData);\n        readable.on('end', onEnd);\n    });\n}\nclass Client {\n    static toString(buff) {\n        return buff.toString();\n    }\n    static parseJSON(text) {\n        return JSON.parse(text);\n    }\n    static async readAsBytes(stream) {\n        return await read(stream);\n    }\n    static async readAsString(stream) {\n        let buff = await Client.readAsBytes(stream);\n        return Client.toString(buff);\n    }\n    static async readAsJSON(stream) {\n        return Client.parseJSON(await Client.readAsString(stream));\n    }\n    static getNonce() {\n        return kitx.makeNonce();\n    }\n    static getDateUTCString() {\n        const now = new Date();\n        return now.toUTCString();\n    }\n    static defaultString(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static defaultNumber(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static toFormString(val) {\n        return querystring_1.default.stringify(val);\n    }\n    static toJSONString(val) {\n        if (typeof val === 'string') {\n            return val;\n        }\n        return JSON.stringify(val);\n    }\n    static toBytes(val) {\n        return Buffer.from(val);\n    }\n    static empty(val) {\n        return !val;\n    }\n    static equalString(val1, val2) {\n        return val1 === val2;\n    }\n    static equalNumber(val1, val2) {\n        return val1 === val2;\n    }\n    static isUnset(value) {\n        if (typeof value === 'undefined') {\n            return true;\n        }\n        if (value === null) {\n            return true;\n        }\n        return false;\n    }\n    static stringifyMapValue(m) {\n        if (!m) {\n            return m;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(m)) {\n            if (typeof value === 'undefined' || value === null) {\n                continue;\n            }\n            result[key] = String(value);\n        }\n        return result;\n    }\n    static anyifyMapValue(m) {\n        return m;\n    }\n    static assertAsBoolean(value) {\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        throw new Error(`The value is not a boolean`);\n    }\n    static assertAsString(value) {\n        if (typeof value === 'string') {\n            return value;\n        }\n        throw new Error(`The value is not a string`);\n    }\n    static assertAsNumber(value) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        throw new Error(`The value is not a number`);\n    }\n    /**\n     * Assert a value, if it is a integer, return it, otherwise throws\n     * @return the integer value\n     */\n    static assertAsInteger(value) {\n        if (Number.isInteger(value)) {\n            return value;\n        }\n        throw new Error(`The value is not a int number`);\n    }\n    static assertAsMap(value) {\n        if (value && typeof value === 'object' && !Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not a object`);\n    }\n    static assertAsArray(value) {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not array`);\n    }\n    static assertAsBytes(value) {\n        if (Buffer.isBuffer(value)) {\n            return value;\n        }\n        throw new Error(`The value is not bytes`);\n    }\n    static getUserAgent(userAgent) {\n        if (!userAgent || !userAgent.length) {\n            return DEFAULT_USER_AGENT;\n        }\n        return DEFAULT_USER_AGENT + \" \" + userAgent;\n    }\n    static is2xx(code) {\n        return code >= 200 && code < 300;\n    }\n    static is3xx(code) {\n        return code >= 300 && code < 400;\n    }\n    static is4xx(code) {\n        return code >= 400 && code < 500;\n    }\n    static is5xx(code) {\n        return code >= 500 && code < 600;\n    }\n    static validateModel(m) {\n    }\n    static toMap(inputModel) {\n        return $tea.toMap(inputModel);\n    }\n    static async sleep(millisecond) {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve();\n            }, millisecond);\n        });\n    }\n    static toArray(input) {\n        if (!(input instanceof Array)) {\n            return null;\n        }\n        let ret = [];\n        input.forEach((model) => {\n            if (!model) {\n                return;\n            }\n            ret.push($tea.toMap(model));\n        });\n        return ret;\n    }\n    /**\n     * Assert a value, if it is a readable, return it, otherwise throws\n     * @return the readable value\n     */\n    static assertAsReadable(value) {\n        if (value instanceof stream_1.Readable) {\n            return value;\n        }\n        throw new Error(`The value is not a readable`);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst xml2js_1 = require(\"xml2js\");\nclass Client {\n    static parseXml(body, response) {\n        let ret = this._parseXML(body);\n        if (response !== null && typeof response !== 'undefined') {\n            ret = this._xmlCast(ret, response);\n        }\n        return ret;\n    }\n    static toXML(body) {\n        const builder = new xml2js_1.Builder();\n        return builder.buildObject(body);\n    }\n    static _parseXML(body) {\n        let parser = new xml2js_1.Parser({ explicitArray: false });\n        let result = {};\n        parser.parseString(body, function (err, output) {\n            result.err = err;\n            result.output = output;\n        });\n        if (result.err) {\n            throw result.err;\n        }\n        return result.output;\n    }\n    static _xmlCast(obj, clazz) {\n        obj = obj || {};\n        let ret = {};\n        let clz = clazz;\n        let names = clz.names();\n        let types = clz.types();\n        Object.keys(names).forEach((key) => {\n            let originName = names[key];\n            let value = obj[originName];\n            let type = types[key];\n            switch (type) {\n                case 'boolean':\n                    if (!value) {\n                        ret[originName] = false;\n                        return;\n                    }\n                    ret[originName] = value === 'false' ? false : true;\n                    return;\n                case 'number':\n                    if (value != 0 && !value) {\n                        ret[originName] = NaN;\n                        return;\n                    }\n                    ret[originName] = +value;\n                    return;\n                case 'string':\n                    if (!value) {\n                        ret[originName] = '';\n                        return;\n                    }\n                    ret[originName] = value.toString();\n                    return;\n                default:\n                    if (type.type === 'array') {\n                        if (!value) {\n                            ret[originName] = [];\n                            return;\n                        }\n                        if (!Array.isArray(value)) {\n                            value = [value];\n                        }\n                        if (typeof type.itemType === 'function') {\n                            ret[originName] = value.map((d) => {\n                                return this._xmlCast(d, type.itemType);\n                            });\n                        }\n                        else {\n                            ret[originName] = value;\n                        }\n                    }\n                    else if (typeof type === 'function') {\n                        if (!value) {\n                            value = {};\n                        }\n                        ret[originName] = this._xmlCast(value, type);\n                    }\n                    else {\n                        ret[originName] = value;\n                    }\n            }\n        });\n        return ret;\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","'use strict';\n\nconst zlib = require('zlib');\nconst http = require('http');\nconst https = require('https');\nconst parse = require('url').parse;\nconst format = require('url').format;\n\nconst debugBody = require('debug')('httpx:body');\nconst debugHeader = require('debug')('httpx:header');\n\nconst httpAgent = new http.Agent({ keepAlive: true });\nconst httpsAgent = new https.Agent({ keepAlive: true });\n\nconst TIMEOUT = 3000; // 3s\n\nconst READ_TIMER = Symbol('TIMER::READ_TIMER');\nconst READ_TIME_OUT = Symbol('TIMER::READ_TIME_OUT');\nconst READ_TIMER_START_AT = Symbol('TIMER::READ_TIMER_START_AT');\n\n/**\n * Check the content-encoding header, and auto decompress it.\n * @param {Readable} response http response\n * @returns Readable\n */\nfunction decompress(response) {\n  switch (response.headers['content-encoding']) {\n  // or, just use zlib.createUnzip() to handle both cases\n  case 'gzip':\n    return response.pipe(zlib.createGunzip());\n  case 'deflate':\n    return response.pipe(zlib.createInflate());\n  default:\n    return response;\n  }\n}\n\nvar append = function (err, name, message) {\n  err.name = name + err.name;\n  err.message = `${message}. ${err.message}`;\n  return err;\n};\n\nconst isNumber = function (num) {\n  return num !== null && !isNaN(num);\n};\n\nexports.request = function (url, opts) {\n  opts || (opts = {});\n\n  const parsed = typeof url === 'string' ? parse(url) : url;\n\n  let readTimeout, connectTimeout;\n  if (isNumber(opts.readTimeout) || isNumber(opts.connectTimeout)) {\n    readTimeout = isNumber(opts.readTimeout) ? Number(opts.readTimeout) : TIMEOUT;\n    connectTimeout = isNumber(opts.connectTimeout) ? Number(opts.connectTimeout) : TIMEOUT;\n  } else if (isNumber(opts.timeout)) {\n    readTimeout = connectTimeout = Number(opts.timeout);\n  } else {\n    readTimeout = connectTimeout = TIMEOUT;\n  }\n\n  const isHttps = parsed.protocol === 'https:';\n  const method = (opts.method || 'GET').toUpperCase();\n  const defaultAgent = isHttps ? httpsAgent : httpAgent;\n  const agent = opts.agent || defaultAgent;\n\n  var options = {\n    host: parsed.hostname || 'localhost',\n    path: parsed.path || '/',\n    method: method,\n    port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),\n    agent: agent,\n    headers: opts.headers || {},\n    // ssl config\n    key: opts.key || '',\n    cert: opts.cert || '',\n    ca: opts.ca || '',\n    // connect timerout\n    timeout: connectTimeout\n  };\n\n  if (isHttps && typeof opts.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = opts.rejectUnauthorized;\n  }\n\n  if (opts.compression) {\n    options.headers['accept-encoding'] = 'gzip,deflate';\n  }\n\n  const httplib = isHttps ? https : http;\n\n  if (typeof opts.beforeRequest === 'function') {\n    options = opts.beforeRequest(options);\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = httplib.request(options);\n    const body = opts.data;\n\n    var fulfilled = (response) => {\n      if (debugHeader.enabled) {\n        const requestHeaders = response.req._header;\n        requestHeaders.split('\\r\\n').forEach((line) => {\n          debugHeader('> %s', line);\n        });\n\n        debugHeader('< HTTP/%s %s %s', response.httpVersion, response.statusCode, response.statusMessage);\n        Object.keys(response.headers).forEach((key) => {\n          debugHeader('< %s: %s', key, response.headers[key]);\n        });\n      }\n      resolve(response);\n    };\n\n    var rejected = (err) => {\n      err.message += `${method} ${format(parsed)} failed.`;\n      // clear response timer when error\n      if (request.socket && request.socket[READ_TIMER]) {\n        clearTimeout(request.socket[READ_TIMER]);\n      }\n      reject(err);\n    };\n\n    var abort = (err) => {\n      request.abort();\n      rejected(err);\n    };\n\n    const startResponseTimer = function (socket) {\n      const timer = setTimeout(() => {\n        if (socket[READ_TIMER]) {\n          clearTimeout(socket[READ_TIMER]);\n          socket[READ_TIMER] = null;\n        }\n        var err = new Error();\n        var message = `ReadTimeout(${readTimeout})`;\n        abort(append(err, 'RequestTimeout', message));\n      }, readTimeout);\n      // start read-timer\n      socket[READ_TIME_OUT] = readTimeout;\n      socket[READ_TIMER] = timer;\n      socket[READ_TIMER_START_AT] = Date.now();\n      // don't block the loop\n      timer.unref();\n    };\n\n    // string\n    if (!body || 'string' === typeof body || body instanceof Buffer) {\n      if (debugBody.enabled) {\n        if (!body) {\n          debugBody('<no request body>');\n        } else if ('string' === typeof body) {\n          debugBody(body);\n        } else {\n          debugBody(`Buffer <ignored>, Buffer length: ${body.length}`);\n        }\n      }\n      request.end(body);\n    } else if ('function' === typeof body.pipe) { // stream\n      body.pipe(request);\n      if (debugBody.enabled) {\n        debugBody('<request body is a stream>');\n      }\n      body.once('error', (err) => {\n        abort(append(err, 'HttpX', 'Stream occor error'));\n      });\n    }\n\n    request.on('response', fulfilled);\n    request.on('error', rejected);\n    request.once('socket', function (socket) {\n      // reuse socket\n      if (socket.readyState === 'opening') {\n        socket.once('connect', function () {\n          startResponseTimer(socket);\n        });\n      } else {\n        startResponseTimer(socket);\n      }\n    });\n  });\n};\n\nexports.read = function (response, encoding) {\n  const readable = decompress(response);\n\n  return new Promise((resolve, reject) => {\n    // node.js 14 use response.client\n    const socket = response.socket || response.client;\n\n    const makeReadTimeoutError = () => {\n      const req = response.req;\n      var err = new Error();\n      err.name = 'RequestTimeoutError';\n      err.message = `ReadTimeout: ${socket[READ_TIME_OUT]}. ${req.method} ${req.path} failed.`;\n      return err;\n    };\n    // check read-timer\n    let readTimer;\n    const oldReadTimer = socket[READ_TIMER];\n    if (!oldReadTimer) {\n      reject(makeReadTimeoutError());\n      return;\n    }\n    const remainTime = socket[READ_TIME_OUT] - (Date.now() - socket[READ_TIMER_START_AT]);\n    clearTimeout(oldReadTimer);\n    if (remainTime <= 0) {\n      reject(makeReadTimeoutError());\n      return;\n    }\n    readTimer = setTimeout(function () {\n      reject(makeReadTimeoutError());\n    }, remainTime);\n\n    // start reading data\n    var onError, onData, onEnd;\n    var cleanup = function () {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('data', onData);\n      readable.removeListener('end', onEnd);\n      // clear read timer\n      if (readTimer) {\n        clearTimeout(readTimer);\n      }\n    };\n\n    const bufs = [];\n    var size = 0;\n\n    onData = function (buf) {\n      bufs.push(buf);\n      size += buf.length;\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    onEnd = function () {\n      cleanup();\n      var buff = Buffer.concat(bufs, size);\n\n      debugBody('');\n      if (encoding) {\n        const result = buff.toString(encoding);\n        debugBody(result);\n        return resolve(result);\n      }\n\n      if (debugBody.enabled) {\n        debugBody(buff.toString());\n      }\n      resolve(buff);\n    };\n\n    readable.on('error', onError);\n    readable.on('data', onData);\n    readable.on('end', onEnd);\n  });\n};\n\nfunction readyToRead(readable) {\n  return new Promise((resolve, reject) => {\n    var onReadable, onEnd, onError;\n    var cleanup = function () {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('end', onEnd);\n      readable.removeListener('readable', onReadable);\n    };\n\n    onReadable = function () {\n      cleanup();\n      resolve(false);\n    };\n\n    onEnd = function () {\n      cleanup();\n      resolve(true);\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    readable.once('readable', onReadable);\n    readable.once('end', onEnd);\n    readable.once('error', onError);\n  });\n}\n\nclass Event {\n  constructor(id, event, data, retry) {\n    this.id = id;\n    this.event = event;\n    this.data = data;\n    this.retry = retry;\n  }\n}\n\nexports.Event = Event;\n\nconst DATA_PREFIX = 'data:';\nconst EVENT_PREFIX = 'event:';\nconst ID_PREFIX = 'id:';\nconst RETRY_PREFIX = 'retry:';\n\nfunction isDigitsOnly(str) {\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charAt(i);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return str.length > 0;\n}\n\nfunction tryGetEvents(head, chunk) {\n  const all = head + chunk;\n  let start = 0;\n  const events = [];\n  for (let i = 0; i < all.length - 1; i++) {\n    const c = all[i];\n    const c2 = all[i + 1];\n    if (c === '\\n' && c2 === '\\n') {\n      const part = all.substring(start, i);\n      const lines = part.split('\\n');\n      const event = new Event();\n      lines.forEach((line) => {\n        if (line.startsWith(DATA_PREFIX)) {\n          event.data = line.substring(DATA_PREFIX.length).trim();\n        } else if (line.startsWith(EVENT_PREFIX)) {\n          event.event = line.substring(EVENT_PREFIX.length).trim();\n        } else if (line.startsWith(ID_PREFIX)) {\n          event.id = line.substring(ID_PREFIX.length).trim();\n        } else if (line.startsWith(RETRY_PREFIX)) {\n          const retry = line.substring(RETRY_PREFIX.length).trim();\n          if (isDigitsOnly(retry)) {\n            event.retry = parseInt(retry, 10);\n          }\n        } else if (line.startsWith(':')) {\n          // ignore the line\n        }\n      });\n      events.push(event);\n      start = i + 2;\n    }\n  }\n\n  const rest = all.substring(start);\n  return [events, rest];\n}\n\n/**\n * consume response and parse to event stream\n * @param {ReadableStream} response \n * @returns AsyncGenerator<Event, void, unknown>\n */\nexports.readAsSSE = async function* (response) {\n  const readable = decompress(response);\n\n  const socket = response.socket || response.client;\n  clearTimeout(socket[READ_TIMER]);\n\n  let rest = '';\n\n  while (true) {\n    const ended = await readyToRead(readable);\n    if (ended) {\n      return;\n    }\n\n    let chunk;\n    while (null !== (chunk = readable.read())) {\n      const [ events, remain ] = tryGetEvents(rest, chunk.toString());\n      rest = remain;\n      if (events && events.length > 0) {\n        for (const event of events) {\n          yield event;\n        }\n      }\n    }\n  }\n};\n","exports.parse = exports.decode = decode\n\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nfunction encode (obj, opt) {\n  var children = []\n  var out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || {}\n    opt.whitespace = opt.whitespace === true\n  }\n\n  var separator = opt.whitespace ? ' = ' : '='\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n      })\n    } else if (val && typeof val === 'object')\n      children.push(k)\n    else\n      out += safe(k) + separator + safe(val) + eol\n  })\n\n  if (opt.section && out.length)\n    out = '[' + safe(opt.section) + ']' + eol + out\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var section = (opt.section ? opt.section + '.' : '') + nk\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace,\n    })\n    if (out.length && child.length)\n      out += eol\n\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./).map(function (part) {\n      return part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n    })\n}\n\nfunction decode (str) {\n  var out = {}\n  var p = out\n  var section = null\n  //          section     |key      = value\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  var lines = str.split(/[\\r\\n]+/g)\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/))\n      return\n    var match = line.match(re)\n    if (!match)\n      return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = {}\n        return\n      }\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n    if (key === '__proto__')\n      return\n    var value = match[3] ? unsafe(match[4]) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2)\n      if (key === '__proto__')\n        return\n      if (!p[key])\n        p[key] = []\n      else if (!Array.isArray(p[key]))\n        p[key] = [p[key]]\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key]))\n      p[key].push(value)\n    else\n      p[key] = value\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k]))\n      return false\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n    var p = out\n    var l = parts.pop()\n    var nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (part === '__proto__')\n        return\n      if (!p[part] || typeof p[part] !== 'object')\n        p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l)\n      return false\n\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n    ? JSON.stringify(val)\n    : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\")\n      val = val.substr(1, val.length - 2)\n\n    try {\n      val = JSON.parse(val)\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = ''\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += '\\\\' + c\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1)\n        break\n      else if (c === '\\\\')\n        esc = true\n      else\n        unesc += c\n    }\n    if (esc)\n      unesc += '\\\\'\n\n    return unesc.trim()\n  }\n  return val\n}\n","'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst crypto = require('crypto');\n\n/**\n * Load *.json file synchronous. Don't use require('*.json')\n * to load *.json files, it will cached in process.\n * @param {String} filename absolute file path\n * @return {Object} a parsed object\n */\nexports.loadJSONSync = function (filename) {\n  // strip BOM\n  var content = fs.readFileSync(filename, 'utf8');\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  try {\n    return JSON.parse(content);\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n/**\n * Encoding a string to Buffer safely\n * @param {String} str string.\n * @param {String} encoding. optional.\n * @return {Buffer} encoded buffer\n */\nexports.encode = function (str, encoding) {\n  if (typeof str !== 'string') {\n    str = '' + str;\n  }\n\n  return Buffer.from(str, encoding);\n};\n\n/**\n * Generate a haser with specfied algorithm\n * @param {String} algorithm can be md5, etc.\n * @return {Function} a haser with specfied algorithm\n */\nexports.makeHasher = function (algorithm) {\n  return function (data, encoding) {\n    var shasum = crypto.createHash(algorithm);\n    shasum.update(data);\n    return shasum.digest(encoding);\n  };\n};\n\nexports.createHash = exports.makeHasher;\n\n/**\n * Get md5 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} encoding optional. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.md5 = exports.makeHasher('md5');\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.createHmac = function (algorithm) {\n  return function (data, key, encoding) {\n    return crypto.createHmac(algorithm, key).update(data).digest(encoding);\n  };\n};\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.sha1 = exports.createHmac('sha1');\n\n/**\n * Get a random value in a range\n * @param {Number} min range start.\n * @param {Number} max range end.\n */\nexports.random = function (min, max) {\n  return Math.floor(min + Math.random() * (max - min));\n};\n\n/**\n * Generate a nonce string\n * @return {String} a nonce string.\n */\nexports.makeNonce = (function () {\n  var counter = 0;\n  var last;\n  const machine = os.hostname();\n  const pid = process.pid;\n\n  return function () {\n    var val = Math.floor(Math.random() * 1000000000000);\n    if (val === last) {\n      counter++;\n    } else {\n      counter = 0;\n    }\n\n    last = val;\n\n    var uid = `${machine}${pid}${val}${counter}`;\n    return exports.md5(uid, 'hex');\n  };\n}());\n\n/**\n * Pad a number as \\d\\d format\n * @param {Number} num a number that less than 100.\n * @return {String} if number less than 10, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad2 = function (num) {\n  if (num < 10) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Pad a number as \\d\\d\\d format\n * @param {Number} num a number that less than 1000.\n * @return {String} if number less than 100, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad3 = function (num) {\n  if (num < 10) {\n    return '00' + num;\n  } else if (num < 100) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Return the YYYYMMDD format of a date.\n * @param {Date} date a Date object.\n * @return {String} the YYYYMMDD format.\n */\nexports.getYYYYMMDD = function (date) {\n  var YYYY = date.getFullYear();\n  var MM = exports.pad2(date.getMonth() + 1);\n  var DD = exports.pad2(date.getDate());\n  return '' + YYYY + MM + DD;\n};\n\n/**\n * sleep a while.\n * @param {Number} in milliseconds\n * @return {Promise} a Promise\n */\nexports.sleep = function (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\n/**\n * Get the IPv4 address\n * @return {String} the IPv4 address, or empty string\n */\nexports.getIPv4 = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.address;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '';\n};\n\n/**\n * Get the Mac address\n * @return {String} the Mac address\n */\nexports.getMac = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.mac;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '00:00:00:00:00:00';\n};\n\n/**\n * Read all bytes from a readable\n * @return {Readable} the readable stream\n * @return {Promise} a Promise with all bytes\n */\nexports.readAll = function (readable) {\n  return new Promise((resolve, reject) => {\n    var onError, onData, onEnd;\n    var cleanup = function (err) {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('data', onData);\n      readable.removeListener('end', onEnd);\n    };\n\n    var bufs = [];\n    var size = 0;\n\n    onData = function (buf) {\n      bufs.push(buf);\n      size += buf.length;\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    onEnd = function () {\n      cleanup();\n      resolve(Buffer.concat(bufs, size));\n    };\n\n    readable.on('error', onError);\n    readable.on('data', onData);\n    readable.on('end', onEnd);\n  });\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // disallow unquoted attribute values if not otherwise configured\n    // and strict mode is true\n    if (parser.opt.unquotedAttributeValues === undefined) {\n      parser.opt.unquotedAttributeValues = !strict;\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n  if (!Stream) Stream = function () {}\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n            continue;\n          }\n\n          if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {\n            parser.state = S.DOCTYPE_DTD\n            parser.doctype += '<!' + parser.sgmlDecl + c\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          if (c === ']') {\n            parser.doctype += c\n            parser.state = S.DOCTYPE\n          } else if (c === '<') {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else if (isQuote(c)) {\n            parser.doctype += c\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          } else {\n            parser.doctype += c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else if (parser.doctype && parser.doctype !== true) {\n            parser.state = S.DOCTYPE_DTD\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            if (!parser.opt.unquotedAttributeValues) {\n              error(parser, 'Unquoted attribute value')\n            }\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            var parsedEntity = parseEntity(parser)\n            if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {\n              parser.entity = ''\n              parser.state = returnState\n              parser.write(parsedEntity)\n            } else {\n              parser[buffer] += parsedEntity\n              parser.entity = ''\n              parser.state = returnState\n            }\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  exports.stripBOM = function(str) {\n    if (str[0] === '\\uFEFF') {\n      return str.substring(1);\n    } else {\n      return str;\n    }\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,\n    hasProp = {}.hasOwnProperty;\n\n  builder = require('xmlbuilder');\n\n  defaults = require('./defaults').defaults;\n\n  requiresCDATA = function(entry) {\n    return typeof entry === \"string\" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);\n  };\n\n  wrapCDATA = function(entry) {\n    return \"<![CDATA[\" + (escapeCDATA(entry)) + \"]]>\";\n  };\n\n  escapeCDATA = function(entry) {\n    return entry.replace(']]>', ']]]]><![CDATA[>');\n  };\n\n  exports.Builder = (function() {\n    function Builder(opts) {\n      var key, ref, value;\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n    }\n\n    Builder.prototype.buildObject = function(rootObj) {\n      var attrkey, charkey, render, rootElement, rootName;\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {\n        rootName = Object.keys(rootObj)[0];\n        rootObj = rootObj[rootName];\n      } else {\n        rootName = this.options.rootName;\n      }\n      render = (function(_this) {\n        return function(element, obj) {\n          var attr, child, entry, index, key, value;\n          if (typeof obj !== 'object') {\n            if (_this.options.cdata && requiresCDATA(obj)) {\n              element.raw(wrapCDATA(obj));\n            } else {\n              element.txt(obj);\n            }\n          } else if (Array.isArray(obj)) {\n            for (index in obj) {\n              if (!hasProp.call(obj, index)) continue;\n              child = obj[index];\n              for (key in child) {\n                entry = child[key];\n                element = render(element.ele(key), entry).up();\n              }\n            }\n          } else {\n            for (key in obj) {\n              if (!hasProp.call(obj, key)) continue;\n              child = obj[key];\n              if (key === attrkey) {\n                if (typeof child === \"object\") {\n                  for (attr in child) {\n                    value = child[attr];\n                    element = element.att(attr, value);\n                  }\n                }\n              } else if (key === charkey) {\n                if (_this.options.cdata && requiresCDATA(child)) {\n                  element = element.raw(wrapCDATA(child));\n                } else {\n                  element = element.txt(child);\n                }\n              } else if (Array.isArray(child)) {\n                for (index in child) {\n                  if (!hasProp.call(child, index)) continue;\n                  entry = child[index];\n                  if (typeof entry === 'string') {\n                    if (_this.options.cdata && requiresCDATA(entry)) {\n                      element = element.ele(key).raw(wrapCDATA(entry)).up();\n                    } else {\n                      element = element.ele(key, entry).up();\n                    }\n                  } else {\n                    element = render(element.ele(key), entry).up();\n                  }\n                }\n              } else if (typeof child === \"object\") {\n                element = render(element.ele(key), child).up();\n              } else {\n                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {\n                  element = element.ele(key).raw(wrapCDATA(child)).up();\n                } else {\n                  if (child == null) {\n                    child = '';\n                  }\n                  element = element.ele(key, child.toString()).up();\n                }\n              }\n            }\n          }\n          return element;\n        };\n      })(this);\n      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {\n        headless: this.options.headless,\n        allowSurrogateChars: this.options.allowSurrogateChars\n      });\n      return render(rootElement, rootObj).end(this.options.renderOpts);\n    };\n\n    return Builder;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  exports.defaults = {\n    \"0.1\": {\n      explicitCharkey: false,\n      trim: true,\n      normalize: true,\n      normalizeTags: false,\n      attrkey: \"@\",\n      charkey: \"#\",\n      explicitArray: false,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: false,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      childkey: '@@',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      emptyTag: ''\n    },\n    \"0.2\": {\n      explicitCharkey: false,\n      trim: false,\n      normalize: false,\n      normalizeTags: false,\n      attrkey: \"$\",\n      charkey: \"_\",\n      explicitArray: true,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: true,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      preserveChildrenOrder: false,\n      childkey: '$$',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      rootName: 'root',\n      xmldec: {\n        'version': '1.0',\n        'encoding': 'UTF-8',\n        'standalone': true\n      },\n      doctype: null,\n      renderOpts: {\n        'pretty': true,\n        'indent': '  ',\n        'newline': '\\n'\n      },\n      headless: false,\n      chunkSize: 10000,\n      emptyTag: '',\n      cdata: false\n    }\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  sax = require('sax');\n\n  events = require('events');\n\n  bom = require('./bom');\n\n  processors = require('./processors');\n\n  setImmediate = require('timers').setImmediate;\n\n  defaults = require('./defaults').defaults;\n\n  isEmpty = function(thing) {\n    return typeof thing === \"object\" && (thing != null) && Object.keys(thing).length === 0;\n  };\n\n  processItem = function(processors, item, key) {\n    var i, len, process;\n    for (i = 0, len = processors.length; i < len; i++) {\n      process = processors[i];\n      item = process(item, key);\n    }\n    return item;\n  };\n\n  defineProperty = function(obj, key, value) {\n    var descriptor;\n    descriptor = Object.create(null);\n    descriptor.value = value;\n    descriptor.writable = true;\n    descriptor.enumerable = true;\n    descriptor.configurable = true;\n    return Object.defineProperty(obj, key, descriptor);\n  };\n\n  exports.Parser = (function(superClass) {\n    extend(Parser, superClass);\n\n    function Parser(opts) {\n      this.parseStringPromise = bind(this.parseStringPromise, this);\n      this.parseString = bind(this.parseString, this);\n      this.reset = bind(this.reset, this);\n      this.assignOrPush = bind(this.assignOrPush, this);\n      this.processAsync = bind(this.processAsync, this);\n      var key, ref, value;\n      if (!(this instanceof exports.Parser)) {\n        return new exports.Parser(opts);\n      }\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n      if (this.options.xmlns) {\n        this.options.xmlnskey = this.options.attrkey + \"ns\";\n      }\n      if (this.options.normalizeTags) {\n        if (!this.options.tagNameProcessors) {\n          this.options.tagNameProcessors = [];\n        }\n        this.options.tagNameProcessors.unshift(processors.normalize);\n      }\n      this.reset();\n    }\n\n    Parser.prototype.processAsync = function() {\n      var chunk, err;\n      try {\n        if (this.remaining.length <= this.options.chunkSize) {\n          chunk = this.remaining;\n          this.remaining = '';\n          this.saxParser = this.saxParser.write(chunk);\n          return this.saxParser.close();\n        } else {\n          chunk = this.remaining.substr(0, this.options.chunkSize);\n          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);\n          this.saxParser = this.saxParser.write(chunk);\n          return setImmediate(this.processAsync);\n        }\n      } catch (error1) {\n        err = error1;\n        if (!this.saxParser.errThrown) {\n          this.saxParser.errThrown = true;\n          return this.emit(err);\n        }\n      }\n    };\n\n    Parser.prototype.assignOrPush = function(obj, key, newValue) {\n      if (!(key in obj)) {\n        if (!this.options.explicitArray) {\n          return defineProperty(obj, key, newValue);\n        } else {\n          return defineProperty(obj, key, [newValue]);\n        }\n      } else {\n        if (!(obj[key] instanceof Array)) {\n          defineProperty(obj, key, [obj[key]]);\n        }\n        return obj[key].push(newValue);\n      }\n    };\n\n    Parser.prototype.reset = function() {\n      var attrkey, charkey, ontext, stack;\n      this.removeAllListeners();\n      this.saxParser = sax.parser(this.options.strict, {\n        trim: false,\n        normalize: false,\n        xmlns: this.options.xmlns\n      });\n      this.saxParser.errThrown = false;\n      this.saxParser.onerror = (function(_this) {\n        return function(error) {\n          _this.saxParser.resume();\n          if (!_this.saxParser.errThrown) {\n            _this.saxParser.errThrown = true;\n            return _this.emit(\"error\", error);\n          }\n        };\n      })(this);\n      this.saxParser.onend = (function(_this) {\n        return function() {\n          if (!_this.saxParser.ended) {\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      this.saxParser.ended = false;\n      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n      this.resultObject = null;\n      stack = [];\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      this.saxParser.onopentag = (function(_this) {\n        return function(node) {\n          var key, newValue, obj, processedKey, ref;\n          obj = {};\n          obj[charkey] = \"\";\n          if (!_this.options.ignoreAttrs) {\n            ref = node.attributes;\n            for (key in ref) {\n              if (!hasProp.call(ref, key)) continue;\n              if (!(attrkey in obj) && !_this.options.mergeAttrs) {\n                obj[attrkey] = {};\n              }\n              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];\n              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;\n              if (_this.options.mergeAttrs) {\n                _this.assignOrPush(obj, processedKey, newValue);\n              } else {\n                defineProperty(obj[attrkey], processedKey, newValue);\n              }\n            }\n          }\n          obj[\"#name\"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;\n          if (_this.options.xmlns) {\n            obj[_this.options.xmlnskey] = {\n              uri: node.uri,\n              local: node.local\n            };\n          }\n          return stack.push(obj);\n        };\n      })(this);\n      this.saxParser.onclosetag = (function(_this) {\n        return function() {\n          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;\n          obj = stack.pop();\n          nodeName = obj[\"#name\"];\n          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {\n            delete obj[\"#name\"];\n          }\n          if (obj.cdata === true) {\n            cdata = obj.cdata;\n            delete obj.cdata;\n          }\n          s = stack[stack.length - 1];\n          if (obj[charkey].match(/^\\s*$/) && !cdata) {\n            emptyStr = obj[charkey];\n            delete obj[charkey];\n          } else {\n            if (_this.options.trim) {\n              obj[charkey] = obj[charkey].trim();\n            }\n            if (_this.options.normalize) {\n              obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n            }\n            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];\n            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n              obj = obj[charkey];\n            }\n          }\n          if (isEmpty(obj)) {\n            if (typeof _this.options.emptyTag === 'function') {\n              obj = _this.options.emptyTag();\n            } else {\n              obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;\n            }\n          }\n          if (_this.options.validator != null) {\n            xpath = \"/\" + ((function() {\n              var i, len, results;\n              results = [];\n              for (i = 0, len = stack.length; i < len; i++) {\n                node = stack[i];\n                results.push(node[\"#name\"]);\n              }\n              return results;\n            })()).concat(nodeName).join(\"/\");\n            (function() {\n              var err;\n              try {\n                return obj = _this.options.validator(xpath, s && s[nodeName], obj);\n              } catch (error1) {\n                err = error1;\n                return _this.emit(\"error\", err);\n              }\n            })();\n          }\n          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {\n            if (!_this.options.preserveChildrenOrder) {\n              node = {};\n              if (_this.options.attrkey in obj) {\n                node[_this.options.attrkey] = obj[_this.options.attrkey];\n                delete obj[_this.options.attrkey];\n              }\n              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {\n                node[_this.options.charkey] = obj[_this.options.charkey];\n                delete obj[_this.options.charkey];\n              }\n              if (Object.getOwnPropertyNames(obj).length > 0) {\n                node[_this.options.childkey] = obj;\n              }\n              obj = node;\n            } else if (s) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              objClone = {};\n              for (key in obj) {\n                if (!hasProp.call(obj, key)) continue;\n                defineProperty(objClone, key, obj[key]);\n              }\n              s[_this.options.childkey].push(objClone);\n              delete obj[\"#name\"];\n              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n                obj = obj[charkey];\n              }\n            }\n          }\n          if (stack.length > 0) {\n            return _this.assignOrPush(s, nodeName, obj);\n          } else {\n            if (_this.options.explicitRoot) {\n              old = obj;\n              obj = {};\n              defineProperty(obj, nodeName, old);\n            }\n            _this.resultObject = obj;\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      ontext = (function(_this) {\n        return function(text) {\n          var charChild, s;\n          s = stack[stack.length - 1];\n          if (s) {\n            s[charkey] += text;\n            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\\\n/g, '').trim() !== '')) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              charChild = {\n                '#name': '__text__'\n              };\n              charChild[charkey] = text;\n              if (_this.options.normalize) {\n                charChild[charkey] = charChild[charkey].replace(/\\s{2,}/g, \" \").trim();\n              }\n              s[_this.options.childkey].push(charChild);\n            }\n            return s;\n          }\n        };\n      })(this);\n      this.saxParser.ontext = ontext;\n      return this.saxParser.oncdata = (function(_this) {\n        return function(text) {\n          var s;\n          s = ontext(text);\n          if (s) {\n            return s.cdata = true;\n          }\n        };\n      })(this);\n    };\n\n    Parser.prototype.parseString = function(str, cb) {\n      var err;\n      if ((cb != null) && typeof cb === \"function\") {\n        this.on(\"end\", function(result) {\n          this.reset();\n          return cb(null, result);\n        });\n        this.on(\"error\", function(err) {\n          this.reset();\n          return cb(err);\n        });\n      }\n      try {\n        str = str.toString();\n        if (str.trim() === '') {\n          this.emit(\"end\", null);\n          return true;\n        }\n        str = bom.stripBOM(str);\n        if (this.options.async) {\n          this.remaining = str;\n          setImmediate(this.processAsync);\n          return this.saxParser;\n        }\n        return this.saxParser.write(str).close();\n      } catch (error1) {\n        err = error1;\n        if (!(this.saxParser.errThrown || this.saxParser.ended)) {\n          this.emit('error', err);\n          return this.saxParser.errThrown = true;\n        } else if (this.saxParser.ended) {\n          throw err;\n        }\n      }\n    };\n\n    Parser.prototype.parseStringPromise = function(str) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.parseString(str, function(err, value) {\n            if (err) {\n              return reject(err);\n            } else {\n              return resolve(value);\n            }\n          });\n        };\n      })(this));\n    };\n\n    return Parser;\n\n  })(events);\n\n  exports.parseString = function(str, a, b) {\n    var cb, options, parser;\n    if (b != null) {\n      if (typeof b === 'function') {\n        cb = b;\n      }\n      if (typeof a === 'object') {\n        options = a;\n      }\n    } else {\n      if (typeof a === 'function') {\n        cb = a;\n      }\n      options = {};\n    }\n    parser = new exports.Parser(options);\n    return parser.parseString(str, cb);\n  };\n\n  exports.parseStringPromise = function(str, a) {\n    var options, parser;\n    if (typeof a === 'object') {\n      options = a;\n    }\n    parser = new exports.Parser(options);\n    return parser.parseStringPromise(str);\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var prefixMatch;\n\n  prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n\n  exports.normalize = function(str) {\n    return str.toLowerCase();\n  };\n\n  exports.firstCharLowerCase = function(str) {\n    return str.charAt(0).toLowerCase() + str.slice(1);\n  };\n\n  exports.stripPrefix = function(str) {\n    return str.replace(prefixMatch, '');\n  };\n\n  exports.parseNumbers = function(str) {\n    if (!isNaN(str)) {\n      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);\n    }\n    return str;\n  };\n\n  exports.parseBooleans = function(str) {\n    if (/^(?:true|false)$/i.test(str)) {\n      str = str.toLowerCase() === 'true';\n    }\n    return str;\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, parser, processors,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  defaults = require('./defaults');\n\n  builder = require('./builder');\n\n  parser = require('./parser');\n\n  processors = require('./processors');\n\n  exports.defaults = defaults.defaults;\n\n  exports.processors = processors;\n\n  exports.ValidationError = (function(superClass) {\n    extend(ValidationError, superClass);\n\n    function ValidationError(message) {\n      this.message = message;\n    }\n\n    return ValidationError;\n\n  })(Error);\n\n  exports.Builder = builder.Builder;\n\n  exports.Parser = parser.Parser;\n\n  exports.parseString = parser.parseString;\n\n  exports.parseStringPromise = parser.parseStringPromise;\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    Disconnected: 1,\n    Preceding: 2,\n    Following: 4,\n    Contains: 8,\n    ContainedBy: 16,\n    ImplementationSpecific: 32\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    Element: 1,\n    Attribute: 2,\n    Text: 3,\n    CData: 4,\n    EntityReference: 5,\n    EntityDeclaration: 6,\n    ProcessingInstruction: 7,\n    Comment: 8,\n    Document: 9,\n    DocType: 10,\n    DocumentFragment: 11,\n    NotationDeclaration: 12,\n    Declaration: 201,\n    Raw: 202,\n    AttributeDeclaration: 203,\n    ElementDeclaration: 204,\n    Dummy: 205\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n\n  assign = function() {\n    var i, key, len, source, sources, target;\n    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (isFunction(Object.assign)) {\n      Object.assign.apply(null, arguments);\n    } else {\n      for (i = 0, len = sources.length; i < len; i++) {\n        source = sources[i];\n        if (source != null) {\n          for (key in source) {\n            if (!hasProp.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n\n  isFunction = function(val) {\n    return !!val && Object.prototype.toString.call(val) === '[object Function]';\n  };\n\n  isObject = function(val) {\n    var ref;\n    return !!val && ((ref = typeof val) === 'function' || ref === 'object');\n  };\n\n  isArray = function(val) {\n    if (isFunction(Array.isArray)) {\n      return Array.isArray(val);\n    } else {\n      return Object.prototype.toString.call(val) === '[object Array]';\n    }\n  };\n\n  isEmpty = function(val) {\n    var key;\n    if (isArray(val)) {\n      return !val.length;\n    } else {\n      for (key in val) {\n        if (!hasProp.call(val, key)) continue;\n        return false;\n      }\n      return true;\n    }\n  };\n\n  isPlainObject = function(val) {\n    var ctor, proto;\n    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n  };\n\n  getValue = function(obj) {\n    if (isFunction(obj.valueOf)) {\n      return obj.valueOf();\n    } else {\n      return obj;\n    }\n  };\n\n  module.exports.assign = assign;\n\n  module.exports.isFunction = isFunction;\n\n  module.exports.isObject = isObject;\n\n  module.exports.isArray = isArray;\n\n  module.exports.isEmpty = isEmpty;\n\n  module.exports.isPlainObject = isPlainObject;\n\n  module.exports.getValue = getValue;\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    None: 0,\n    OpenTag: 1,\n    InsideTag: 2,\n    CloseTag: 3\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLAttribute, XMLNode;\n\n  NodeType = require('./NodeType');\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.parent = parent;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      if (name == null) {\n        throw new Error(\"Missing attribute name. \" + this.debugInfo(name));\n      }\n      this.name = this.stringify.name(name);\n      this.value = this.stringify.attValue(value);\n      this.type = NodeType.Attribute;\n      this.isId = false;\n      this.schemaTypeInfo = null;\n    }\n\n    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'textContent', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'prefix', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'localName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'specified', {\n      get: function() {\n        return true;\n      }\n    });\n\n    XMLAttribute.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLAttribute.prototype.toString = function(options) {\n      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLAttribute.prototype.debugInfo = function(name) {\n      name = name || this.name;\n      if (name == null) {\n        return \"parent: <\" + this.parent.name + \">\";\n      } else {\n        return \"attribute: {\" + name + \"}, parent: <\" + this.parent.name + \">\";\n      }\n    };\n\n    XMLAttribute.prototype.isEqualNode = function(node) {\n      if (node.namespaceURI !== this.namespaceURI) {\n        return false;\n      }\n      if (node.prefix !== this.prefix) {\n        return false;\n      }\n      if (node.localName !== this.localName) {\n        return false;\n      }\n      if (node.value !== this.value) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCData, XMLCharacterData,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing CDATA text. \" + this.debugInfo());\n      }\n      this.name = \"#cdata-section\";\n      this.type = NodeType.CData;\n      this.value = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCData.prototype.toString = function(options) {\n      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLCData;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCharacterData, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLCharacterData = (function(superClass) {\n    extend(XMLCharacterData, superClass);\n\n    function XMLCharacterData(parent) {\n      XMLCharacterData.__super__.constructor.call(this, parent);\n      this.value = '';\n    }\n\n    Object.defineProperty(XMLCharacterData.prototype, 'data', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    Object.defineProperty(XMLCharacterData.prototype, 'length', {\n      get: function() {\n        return this.value.length;\n      }\n    });\n\n    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    XMLCharacterData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCharacterData.prototype.substringData = function(offset, count) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.appendData = function(arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.insertData = function(offset, arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.deleteData = function(offset, count) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.isEqualNode = function(node) {\n      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.data !== this.data) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLCharacterData;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLComment,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing comment text. \" + this.debugInfo());\n      }\n      this.name = \"#comment\";\n      this.type = NodeType.Comment;\n      this.value = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLComment.prototype.toString = function(options) {\n      return this.options.writer.comment(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLComment;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;\n\n  XMLDOMErrorHandler = require('./XMLDOMErrorHandler');\n\n  XMLDOMStringList = require('./XMLDOMStringList');\n\n  module.exports = XMLDOMConfiguration = (function() {\n    function XMLDOMConfiguration() {\n      var clonedSelf;\n      this.defaultParams = {\n        \"canonical-form\": false,\n        \"cdata-sections\": false,\n        \"comments\": false,\n        \"datatype-normalization\": false,\n        \"element-content-whitespace\": true,\n        \"entities\": true,\n        \"error-handler\": new XMLDOMErrorHandler(),\n        \"infoset\": true,\n        \"validate-if-schema\": false,\n        \"namespaces\": true,\n        \"namespace-declarations\": true,\n        \"normalize-characters\": false,\n        \"schema-location\": '',\n        \"schema-type\": '',\n        \"split-cdata-sections\": true,\n        \"validate\": false,\n        \"well-formed\": true\n      };\n      this.params = clonedSelf = Object.create(this.defaultParams);\n    }\n\n    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {\n      get: function() {\n        return new XMLDOMStringList(Object.keys(this.defaultParams));\n      }\n    });\n\n    XMLDOMConfiguration.prototype.getParameter = function(name) {\n      if (this.params.hasOwnProperty(name)) {\n        return this.params[name];\n      } else {\n        return null;\n      }\n    };\n\n    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {\n      return true;\n    };\n\n    XMLDOMConfiguration.prototype.setParameter = function(name, value) {\n      if (value != null) {\n        return this.params[name] = value;\n      } else {\n        return delete this.params[name];\n      }\n    };\n\n    return XMLDOMConfiguration;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMErrorHandler;\n\n  module.exports = XMLDOMErrorHandler = (function() {\n    function XMLDOMErrorHandler() {}\n\n    XMLDOMErrorHandler.prototype.handleError = function(error) {\n      throw new Error(error);\n    };\n\n    return XMLDOMErrorHandler;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMImplementation;\n\n  module.exports = XMLDOMImplementation = (function() {\n    function XMLDOMImplementation() {}\n\n    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {\n      return true;\n    };\n\n    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.getFeature = function(feature, version) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    return XMLDOMImplementation;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMStringList;\n\n  module.exports = XMLDOMStringList = (function() {\n    function XMLDOMStringList(arr) {\n      this.arr = arr || [];\n    }\n\n    Object.defineProperty(XMLDOMStringList.prototype, 'length', {\n      get: function() {\n        return this.arr.length;\n      }\n    });\n\n    XMLDOMStringList.prototype.item = function(index) {\n      return this.arr[index] || null;\n    };\n\n    XMLDOMStringList.prototype.contains = function(str) {\n      return this.arr.indexOf(str) !== -1;\n    };\n\n    return XMLDOMStringList;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDAttList, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDAttList = (function(superClass) {\n    extend(XMLDTDAttList, superClass);\n\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      XMLDTDAttList.__super__.constructor.call(this, parent);\n      if (elementName == null) {\n        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n      }\n      if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name. \" + this.debugInfo(elementName));\n      }\n      if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type. \" + this.debugInfo(elementName));\n      }\n      if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default. \" + this.debugInfo(elementName));\n      }\n      if (defaultValueType.indexOf('#') !== 0) {\n        defaultValueType = '#' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n      }\n      this.elementName = this.stringify.name(elementName);\n      this.type = NodeType.AttributeDeclaration;\n      this.attributeName = this.stringify.name(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      if (defaultValue) {\n        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      }\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.toString = function(options) {\n      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDAttList;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDElement, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDElement = (function(superClass) {\n    extend(XMLDTDElement, superClass);\n\n    function XMLDTDElement(parent, name, value) {\n      XMLDTDElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n      }\n      if (!value) {\n        value = '(#PCDATA)';\n      }\n      if (Array.isArray(value)) {\n        value = '(' + value.join(',') + ')';\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.ElementDeclaration;\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.toString = function(options) {\n      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDElement;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDEntity, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDEntity = (function(superClass) {\n    extend(XMLDTDEntity, superClass);\n\n    function XMLDTDEntity(parent, pe, name, value) {\n      XMLDTDEntity.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD entity name. \" + this.debugInfo(name));\n      }\n      if (value == null) {\n        throw new Error(\"Missing DTD entity value. \" + this.debugInfo(name));\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.name(name);\n      this.type = NodeType.EntityDeclaration;\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n        this.internal = true;\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error(\"Public and/or system identifiers are required for an external entity. \" + this.debugInfo(name));\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error(\"System identifier is required for a public external entity. \" + this.debugInfo(name));\n        }\n        this.internal = false;\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error(\"Notation declaration is not allowed in a parameter entity. \" + this.debugInfo(name));\n        }\n      }\n    }\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {\n      get: function() {\n        return this.nData || null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {\n      get: function() {\n        return null;\n      }\n    });\n\n    XMLDTDEntity.prototype.toString = function(options) {\n      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDEntity;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDNotation, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDNotation = (function(superClass) {\n    extend(XMLDTDNotation, superClass);\n\n    function XMLDTDNotation(parent, name, value) {\n      XMLDTDNotation.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD notation name. \" + this.debugInfo(name));\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity. \" + this.debugInfo(name));\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.NotationDeclaration;\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    XMLDTDNotation.prototype.toString = function(options) {\n      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDNotation;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDeclaration, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = '1.0';\n      }\n      this.type = NodeType.Declaration;\n      this.version = this.stringify.xmlVersion(version);\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.toString = function(options) {\n      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLNamedNodeMap = require('./XMLNamedNodeMap');\n\n  module.exports = XMLDocType = (function(superClass) {\n    extend(XMLDocType, superClass);\n\n    function XMLDocType(parent, pubID, sysID) {\n      var child, i, len, ref, ref1, ref2;\n      XMLDocType.__super__.constructor.call(this, parent);\n      this.type = NodeType.DocType;\n      if (parent.children) {\n        ref = parent.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.Element) {\n            this.name = child.name;\n            break;\n          }\n        }\n      }\n      this.documentObject = parent;\n      if (isObject(pubID)) {\n        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;\n      }\n      if (sysID == null) {\n        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    Object.defineProperty(XMLDocType.prototype, 'entities', {\n      get: function() {\n        var child, i, len, nodes, ref;\n        nodes = {};\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {\n            nodes[child.name] = child;\n          }\n        }\n        return new XMLNamedNodeMap(nodes);\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'notations', {\n      get: function() {\n        var child, i, len, nodes, ref;\n        nodes = {};\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.NotationDeclaration) {\n            nodes[child.name] = child;\n          }\n        }\n        return new XMLNamedNodeMap(nodes);\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.toString = function(options) {\n      return this.options.writer.docType(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root() || this.documentObject;\n    };\n\n    XMLDocType.prototype.isEqualNode = function(node) {\n      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.name !== this.name) {\n        return false;\n      }\n      if (node.publicId !== this.publicId) {\n        return false;\n      }\n      if (node.systemId !== this.systemId) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLDocType;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isPlainObject = require('./Utility').isPlainObject;\n\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n\n  XMLDOMConfiguration = require('./XMLDOMConfiguration');\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  module.exports = XMLDocument = (function(superClass) {\n    extend(XMLDocument, superClass);\n\n    function XMLDocument(options) {\n      XMLDocument.__super__.constructor.call(this, null);\n      this.name = \"#document\";\n      this.type = NodeType.Document;\n      this.documentURI = null;\n      this.domConfig = new XMLDOMConfiguration();\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n    }\n\n    Object.defineProperty(XMLDocument.prototype, 'implementation', {\n      value: new XMLDOMImplementation()\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'doctype', {\n      get: function() {\n        var child, i, len, ref;\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.DocType) {\n            return child;\n          }\n        }\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'documentElement', {\n      get: function() {\n        return this.rootObject || null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {\n      get: function() {\n        return false;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].encoding;\n        } else {\n          return null;\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].standalone === 'yes';\n        } else {\n          return false;\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].version;\n        } else {\n          return \"1.0\";\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'URL', {\n      get: function() {\n        return this.documentURI;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'origin', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'compatMode', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'characterSet', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'contentType', {\n      get: function() {\n        return null;\n      }\n    });\n\n    XMLDocument.prototype.end = function(writer) {\n      var writerOptions;\n      writerOptions = {};\n      if (!writer) {\n        writer = this.options.writer;\n      } else if (isPlainObject(writer)) {\n        writerOptions = writer;\n        writer = this.options.writer;\n      }\n      return writer.document(this, writer.filterOptions(writerOptions));\n    };\n\n    XMLDocument.prototype.toString = function(options) {\n      return this.options.writer.document(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLDocument.prototype.createElement = function(tagName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createDocumentFragment = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createTextNode = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createComment = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createCDATASection = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createProcessingInstruction = function(target, data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createAttribute = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createEntityReference = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByTagName = function(tagname) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.importNode = function(importedNode, deep) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementById = function(elementId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.adoptNode = function(source) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.normalizeDocument = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByClassName = function(classNames) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createEvent = function(eventInterface) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createRange = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    return XMLDocument;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLDocumentCB = (function() {\n    function XMLDocumentCB(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    XMLDocumentCB.prototype.createChildNode = function(node) {\n      var att, attName, attributes, child, i, len, ref1, ref2;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref1 = node.attribs;\n          for (attName in ref1) {\n            if (!hasProp.call(ref1, attName)) continue;\n            att = ref1[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref2 = node.children;\n      for (i = 0, len = ref2.length; i < len; i++) {\n        child = ref2[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dummy = function() {\n      return this;\n    };\n\n    XMLDocumentCB.prototype.node = function(name, attributes, text) {\n      var ref1;\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.element = function(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref1, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement.apply(this, arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref1 = root.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.text = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.cdata = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.comment = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.raw = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dtdElement = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.entity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.pEntity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.notation = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.up = function() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.end = function() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    };\n\n    XMLDocumentCB.prototype.openCurrent = function() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    };\n\n    XMLDocumentCB.prototype.openNode = function(node) {\n      var att, chunk, name, ref1;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref1 = node.attribs;\n          for (name in ref1) {\n            if (!hasProp.call(ref1, name)) continue;\n            att = ref1[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag;\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.closeNode = function(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.onData = function(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    };\n\n    XMLDocumentCB.prototype.onEnd = function() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    };\n\n    XMLDocumentCB.prototype.debugInfo = function(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    };\n\n    XMLDocumentCB.prototype.ele = function() {\n      return this.element.apply(this, arguments);\n    };\n\n    XMLDocumentCB.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    };\n\n    XMLDocumentCB.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLDocumentCB.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.att = function() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.a = function() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocumentCB.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocumentCB.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    return XMLDocumentCB;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDummy, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDummy = (function(superClass) {\n    extend(XMLDummy, superClass);\n\n    function XMLDummy(parent) {\n      XMLDummy.__super__.constructor.call(this, parent);\n      this.type = NodeType.Dummy;\n    }\n\n    XMLDummy.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLDummy.prototype.toString = function(options) {\n      return '';\n    };\n\n    return XMLDummy;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLNamedNodeMap = require('./XMLNamedNodeMap');\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      var child, j, len, ref1;\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing element name. \" + this.debugInfo());\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.Element;\n      this.attribs = {};\n      this.schemaTypeInfo = null;\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n      if (parent.type === NodeType.Document) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n        if (parent.children) {\n          ref1 = parent.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.type === NodeType.DocType) {\n              child.name = this.name;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    Object.defineProperty(XMLElement.prototype, 'tagName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'prefix', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'localName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'id', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'className', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'classList', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'attributes', {\n      get: function() {\n        if (!this.attributeMap || !this.attributeMap.nodes) {\n          this.attributeMap = new XMLNamedNodeMap(this.attribs);\n        }\n        return this.attributeMap;\n      }\n    });\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, ref1;\n      clonedSelf = Object.create(this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attribs = {};\n      ref1 = this.attribs;\n      for (attName in ref1) {\n        if (!hasProp.call(ref1, attName)) continue;\n        att = ref1[attName];\n        clonedSelf.attribs[attName] = att.clone();\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, j, len;\n      if (name == null) {\n        throw new Error(\"Missing attribute name. \" + this.debugInfo());\n      }\n      name = getValue(name);\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          attName = name[j];\n          delete this.attribs[attName];\n        }\n      } else {\n        delete this.attribs[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options) {\n      return this.options.writer.element(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.getAttribute = function(name) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name].value;\n      } else {\n        return null;\n      }\n    };\n\n    XMLElement.prototype.setAttribute = function(name, value) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNode = function(name) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name];\n      } else {\n        return null;\n      }\n    };\n\n    XMLElement.prototype.setAttributeNode = function(newAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.removeAttributeNode = function(oldAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagName = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.hasAttribute = function(name) {\n      return this.attribs.hasOwnProperty(name);\n    };\n\n    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setIdAttribute = function(name, isId) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name].isId;\n      } else {\n        return isId;\n      }\n    };\n\n    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagName = function(tagname) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByClassName = function(classNames) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.isEqualNode = function(node) {\n      var i, j, ref1;\n      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.namespaceURI !== this.namespaceURI) {\n        return false;\n      }\n      if (node.prefix !== this.prefix) {\n        return false;\n      }\n      if (node.localName !== this.localName) {\n        return false;\n      }\n      if (node.attribs.length !== this.attribs.length) {\n        return false;\n      }\n      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n        if (!this.attribs[i].isEqualNode(node.attribs[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNamedNodeMap;\n\n  module.exports = XMLNamedNodeMap = (function() {\n    function XMLNamedNodeMap(nodes) {\n      this.nodes = nodes;\n    }\n\n    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {\n      get: function() {\n        return Object.keys(this.nodes).length || 0;\n      }\n    });\n\n    XMLNamedNodeMap.prototype.clone = function() {\n      return this.nodes = null;\n    };\n\n    XMLNamedNodeMap.prototype.getNamedItem = function(name) {\n      return this.nodes[name];\n    };\n\n    XMLNamedNodeMap.prototype.setNamedItem = function(node) {\n      var oldNode;\n      oldNode = this.nodes[node.nodeName];\n      this.nodes[node.nodeName] = node;\n      return oldNode || null;\n    };\n\n    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {\n      var oldNode;\n      oldNode = this.nodes[name];\n      delete this.nodes[name];\n      return oldNode || null;\n    };\n\n    XMLNamedNodeMap.prototype.item = function(index) {\n      return this.nodes[Object.keys(this.nodes)[index]] || null;\n    };\n\n    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    return XMLNamedNodeMap;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,\n    hasProp = {}.hasOwnProperty;\n\n  ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent1) {\n      this.parent = parent1;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      this.value = null;\n      this.children = [];\n      this.baseURI = null;\n      if (!XMLElement) {\n        XMLElement = require('./XMLElement');\n        XMLCData = require('./XMLCData');\n        XMLComment = require('./XMLComment');\n        XMLDeclaration = require('./XMLDeclaration');\n        XMLDocType = require('./XMLDocType');\n        XMLRaw = require('./XMLRaw');\n        XMLText = require('./XMLText');\n        XMLProcessingInstruction = require('./XMLProcessingInstruction');\n        XMLDummy = require('./XMLDummy');\n        NodeType = require('./NodeType');\n        XMLNodeList = require('./XMLNodeList');\n        XMLNamedNodeMap = require('./XMLNamedNodeMap');\n        DocumentPosition = require('./DocumentPosition');\n      }\n    }\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref2, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref2 = this.children;\n          for (j = 0, len = ref2.length; j < len; j++) {\n            child = ref2[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    XMLNode.prototype.setParent = function(parent) {\n      var child, j, len, ref2, results;\n      this.parent = parent;\n      if (parent) {\n        this.options = parent.options;\n        this.stringify = parent.stringify;\n      }\n      ref2 = this.children;\n      results = [];\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        results.push(child.setParent(this));\n      }\n      return results;\n    };\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;\n      lastChild = null;\n      if (attributes === null && (text == null)) {\n        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];\n      }\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n            lastChild = this.dummy();\n          } else if (isObject(val) && isEmpty(val)) {\n            lastChild = this.element(key);\n          } else if (!this.options.keepNullNodes && (val == null)) {\n            lastChild = this.dummy();\n          } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n            for (k = 0, len1 = val.length; k < len1; k++) {\n              item = val[k];\n              childNode = {};\n              childNode[key] = item;\n              lastChild = this.element(childNode);\n            }\n          } else if (isObject(val)) {\n            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n              lastChild = this.element(val);\n            } else {\n              lastChild = this.element(key);\n              lastChild.element(val);\n            }\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else if (!this.options.keepNullNodes && text === null) {\n        lastChild = this.dummy();\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, newChild, refChild, removed;\n      if (name != null ? name.type : void 0) {\n        newChild = name;\n        refChild = attributes;\n        newChild.setParent(this);\n        if (refChild) {\n          i = children.indexOf(refChild);\n          removed = children.splice(i);\n          children.push(newChild);\n          Array.prototype.push.apply(children, removed);\n        } else {\n          children.push(newChild);\n        }\n        return newChild;\n      } else {\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        child = this.parent.element(name, attributes, text);\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref2;\n      if (this.isRoot) {\n        throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref2;\n      if (name != null) {\n        name = getValue(name);\n      }\n      attributes || (attributes = {});\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      if (isObject(value)) {\n        this.element(value);\n      }\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.commentBefore = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.commentAfter = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.dummy = function() {\n      var child;\n      child = new XMLDummy(this);\n      return child;\n    };\n\n    XMLNode.prototype.instruction = function(target, value) {\n      var insTarget, insValue, instruction, j, len;\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) {\n        for (j = 0, len = target.length; j < len; j++) {\n          insTarget = target[j];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.children.push(instruction);\n      }\n      return this;\n    };\n\n    XMLNode.prototype.instructionBefore = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.instructionAfter = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      if (doc.children.length === 0) {\n        doc.children.unshift(xmldec);\n      } else if (doc.children[0].type === NodeType.Declaration) {\n        doc.children[0] = xmldec;\n      } else {\n        doc.children.unshift(xmldec);\n      }\n      return doc.root() || doc;\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      ref2 = doc.children;\n      for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n        child = ref2[i];\n        if (child.type === NodeType.DocType) {\n          doc.children[i] = doctype;\n          return doctype;\n        }\n      }\n      ref3 = doc.children;\n      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {\n        child = ref3[i];\n        if (child.isRoot) {\n          doc.children.splice(i, 0, doctype);\n          return doctype;\n        }\n      }\n      doc.children.push(doctype);\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.type === NodeType.Document) {\n          return node.rootObject;\n        } else if (node.isRoot) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.document = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.type === NodeType.Document) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().end(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error(\"Already at the first node. \" + this.debugInfo());\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error(\"Already at the last node. \" + this.debugInfo());\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importDocument = function(doc) {\n      var clonedRoot;\n      clonedRoot = doc.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.debugInfo = function(name) {\n      var ref2, ref3;\n      name = name || this.name;\n      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {\n        return \"\";\n      } else if (name == null) {\n        return \"parent: <\" + this.parent.name + \">\";\n      } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {\n        return \"node: <\" + name + \">\";\n      } else {\n        return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n      }\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(doc) {\n      return this.importDocument(doc);\n    };\n\n    XMLNode.prototype.replaceChild = function(newChild, oldChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.removeChild = function(oldChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.appendChild = function(newChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.hasChildNodes = function() {\n      return this.children.length !== 0;\n    };\n\n    XMLNode.prototype.cloneNode = function(deep) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.normalize = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isSupported = function(feature, version) {\n      return true;\n    };\n\n    XMLNode.prototype.hasAttributes = function() {\n      return this.attribs.length !== 0;\n    };\n\n    XMLNode.prototype.compareDocumentPosition = function(other) {\n      var ref, res;\n      ref = this;\n      if (ref === other) {\n        return 0;\n      } else if (this.document() !== other.document()) {\n        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n        if (Math.random() < 0.5) {\n          res |= DocumentPosition.Preceding;\n        } else {\n          res |= DocumentPosition.Following;\n        }\n        return res;\n      } else if (ref.isAncestor(other)) {\n        return DocumentPosition.Contains | DocumentPosition.Preceding;\n      } else if (ref.isDescendant(other)) {\n        return DocumentPosition.Contains | DocumentPosition.Following;\n      } else if (ref.isPreceding(other)) {\n        return DocumentPosition.Preceding;\n      } else {\n        return DocumentPosition.Following;\n      }\n    };\n\n    XMLNode.prototype.isSameNode = function(other) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.lookupPrefix = function(namespaceURI) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.lookupNamespaceURI = function(prefix) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isEqualNode = function(node) {\n      var i, j, ref2;\n      if (node.nodeType !== this.nodeType) {\n        return false;\n      }\n      if (node.children.length !== this.children.length) {\n        return false;\n      }\n      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {\n        if (!this.children[i].isEqualNode(node.children[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    XMLNode.prototype.getFeature = function(feature, version) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.setUserData = function(key, data, handler) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.getUserData = function(key) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.contains = function(other) {\n      if (!other) {\n        return false;\n      }\n      return other === this || this.isDescendant(other);\n    };\n\n    XMLNode.prototype.isDescendant = function(node) {\n      var child, isDescendantChild, j, len, ref2;\n      ref2 = this.children;\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        if (node === child) {\n          return true;\n        }\n        isDescendantChild = child.isDescendant(node);\n        if (isDescendantChild) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    XMLNode.prototype.isAncestor = function(node) {\n      return node.isDescendant(this);\n    };\n\n    XMLNode.prototype.isPreceding = function(node) {\n      var nodePos, thisPos;\n      nodePos = this.treePosition(node);\n      thisPos = this.treePosition(this);\n      if (nodePos === -1 || thisPos === -1) {\n        return false;\n      } else {\n        return nodePos < thisPos;\n      }\n    };\n\n    XMLNode.prototype.isFollowing = function(node) {\n      var nodePos, thisPos;\n      nodePos = this.treePosition(node);\n      thisPos = this.treePosition(this);\n      if (nodePos === -1 || thisPos === -1) {\n        return false;\n      } else {\n        return nodePos > thisPos;\n      }\n    };\n\n    XMLNode.prototype.treePosition = function(node) {\n      var found, pos;\n      pos = 0;\n      found = false;\n      this.foreachTreeNode(this.document(), function(childNode) {\n        pos++;\n        if (!found && childNode === node) {\n          return found = true;\n        }\n      });\n      if (found) {\n        return pos;\n      } else {\n        return -1;\n      }\n    };\n\n    XMLNode.prototype.foreachTreeNode = function(node, func) {\n      var child, j, len, ref2, res;\n      node || (node = this.document());\n      ref2 = node.children;\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        if (res = func(child)) {\n          return res;\n        } else {\n          res = this.foreachTreeNode(child, func);\n          if (res) {\n            return res;\n          }\n        }\n      }\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNodeList;\n\n  module.exports = XMLNodeList = (function() {\n    function XMLNodeList(nodes) {\n      this.nodes = nodes;\n    }\n\n    Object.defineProperty(XMLNodeList.prototype, 'length', {\n      get: function() {\n        return this.nodes.length || 0;\n      }\n    });\n\n    XMLNodeList.prototype.clone = function() {\n      return this.nodes = null;\n    };\n\n    XMLNodeList.prototype.item = function(index) {\n      return this.nodes[index] || null;\n    };\n\n    return XMLNodeList;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLProcessingInstruction,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLProcessingInstruction = (function(superClass) {\n    extend(XMLProcessingInstruction, superClass);\n\n    function XMLProcessingInstruction(parent, target, value) {\n      XMLProcessingInstruction.__super__.constructor.call(this, parent);\n      if (target == null) {\n        throw new Error(\"Missing instruction target. \" + this.debugInfo());\n      }\n      this.type = NodeType.ProcessingInstruction;\n      this.target = this.stringify.insTarget(target);\n      this.name = this.target;\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options) {\n      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLProcessingInstruction.prototype.isEqualNode = function(node) {\n      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.target !== this.target) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLProcessingInstruction;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLNode, XMLRaw,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing raw text. \" + this.debugInfo());\n      }\n      this.type = NodeType.Raw;\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLRaw.prototype.toString = function(options) {\n      return this.options.writer.raw(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLStreamWriter = (function(superClass) {\n    extend(XMLStreamWriter, superClass);\n\n    function XMLStreamWriter(stream, options) {\n      this.stream = stream;\n      XMLStreamWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStreamWriter.prototype.endline = function(node, options, level) {\n      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n        return '';\n      } else {\n        return XMLStreamWriter.__super__.endline.call(this, node, options, level);\n      }\n    };\n\n    XMLStreamWriter.prototype.document = function(doc, options) {\n      var child, i, j, k, len, len1, ref, ref1, results;\n      ref = doc.children;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        child = ref[i];\n        child.isLastRootNode = i === doc.children.length - 1;\n      }\n      options = this.filterOptions(options);\n      ref1 = doc.children;\n      results = [];\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        child = ref1[k];\n        results.push(this.writeChildNode(child, options, 0));\n      }\n      return results;\n    };\n\n    XMLStreamWriter.prototype.attribute = function(att, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));\n    };\n\n    XMLStreamWriter.prototype.cdata = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.comment = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.declaration = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.docType = function(node, options, level) {\n      var child, j, len, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (j = 0, len = ref.length; j < len; j++) {\n          child = ref[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(']');\n      }\n      options.state = WriterState.CloseTag;\n      this.stream.write(options.spaceBeforeSlash + '>');\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    };\n\n    XMLStreamWriter.prototype.element = function(node, options, level) {\n      var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level) + '<' + node.name);\n      ref = node.attribs;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        this.attribute(att, options, level);\n      }\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        if (options.allowEmpty) {\n          this.stream.write('>');\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          options.state = WriterState.CloseTag;\n          this.stream.write(options.spaceBeforeSlash + '/>');\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        this.stream.write('>');\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n      }\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    };\n\n    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.raw = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.text = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));\n    };\n\n    return XMLStreamWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringWriter, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  module.exports = XMLStringWriter = (function(superClass) {\n    extend(XMLStringWriter, superClass);\n\n    function XMLStringWriter(options) {\n      XMLStringWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStringWriter.prototype.document = function(doc, options) {\n      var child, i, len, r, ref;\n      options = this.filterOptions(options);\n      r = '';\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        r += this.writeChildNode(child, options, 0);\n      }\n      if (options.pretty && r.slice(-options.newline.length) === options.newline) {\n        r = r.slice(0, -options.newline.length);\n      }\n      return r;\n    };\n\n    return XMLStringWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalName = bind(this.assertLegalName, this);\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      options || (options = {});\n      this.options = options;\n      if (!this.options.version) {\n        this.options.version = '1.0';\n      }\n      ref = options.stringify || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.name = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalName('' + val || '');\n    };\n\n    XMLStringifier.prototype.text = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar(this.textEscape('' + val || ''));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      val = val.replace(']]>', ']]]]><![CDATA[>');\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (val.match(/--/)) {\n        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar(this.attEscape(val = '' + val || ''));\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (val.match(/\\?>/)) {\n        throw new Error(\"Invalid processing instruction value: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error(\"Invalid version number: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {\n        throw new Error(\"Invalid encoding: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      if (val) {\n        return \"yes\";\n      } else {\n        return \"no\";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.convertAttKey = '@';\n\n    XMLStringifier.prototype.convertPIKey = '?';\n\n    XMLStringifier.prototype.convertTextKey = '#text';\n\n    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n    XMLStringifier.prototype.convertRawKey = '#raw';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var regex, res;\n      if (this.options.noValidation) {\n        return str;\n      }\n      regex = '';\n      if (this.options.version === '1.0') {\n        regex = /[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        if (res = str.match(regex)) {\n          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n        }\n      } else if (this.options.version === '1.1') {\n        regex = /[\\0\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        if (res = str.match(regex)) {\n          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n        }\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.assertLegalName = function(str) {\n      var regex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      this.assertLegalChar(str);\n      regex = /^([:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])([\\x2D\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n      if (!str.match(regex)) {\n        throw new Error(\"Invalid character in name\");\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.textEscape = function(str) {\n      var ampregex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      var ampregex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLText,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing element text. \" + this.debugInfo());\n      }\n      this.name = \"#text\";\n      this.type = NodeType.Text;\n      this.value = this.stringify.text(text);\n    }\n\n    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLText.prototype, 'wholeText', {\n      get: function() {\n        var next, prev, str;\n        str = '';\n        prev = this.previousSibling;\n        while (prev) {\n          str = prev.data + str;\n          prev = prev.previousSibling;\n        }\n        str += this.data;\n        next = this.nextSibling;\n        while (next) {\n          str = str + next.data;\n          next = next.nextSibling;\n        }\n        return str;\n      }\n    });\n\n    XMLText.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLText.prototype.toString = function(options) {\n      return this.options.writer.text(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLText.prototype.splitText = function(offset) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLText.prototype.replaceWholeText = function(content) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    return XMLText;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign,\n    hasProp = {}.hasOwnProperty;\n\n  assign = require('./Utility').assign;\n\n  NodeType = require('./NodeType');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLElement = require('./XMLElement');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDummy = require('./XMLDummy');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLWriterBase = (function() {\n    function XMLWriterBase(options) {\n      var key, ref, value;\n      options || (options = {});\n      this.options = options;\n      ref = options.writer || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[\"_\" + key] = this[key];\n        this[key] = value;\n      }\n    }\n\n    XMLWriterBase.prototype.filterOptions = function(options) {\n      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n      options || (options = {});\n      options = assign({}, this.options, options);\n      filteredOptions = {\n        writer: this\n      };\n      filteredOptions.pretty = options.pretty || false;\n      filteredOptions.allowEmpty = options.allowEmpty || false;\n      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';\n      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\\n';\n      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;\n      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;\n      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';\n      if (filteredOptions.spaceBeforeSlash === true) {\n        filteredOptions.spaceBeforeSlash = ' ';\n      }\n      filteredOptions.suppressPrettyCount = 0;\n      filteredOptions.user = {};\n      filteredOptions.state = WriterState.None;\n      return filteredOptions;\n    };\n\n    XMLWriterBase.prototype.indent = function(node, options, level) {\n      var indentLevel;\n      if (!options.pretty || options.suppressPrettyCount) {\n        return '';\n      } else if (options.pretty) {\n        indentLevel = (level || 0) + options.offset + 1;\n        if (indentLevel > 0) {\n          return new Array(indentLevel).join(options.indent);\n        }\n      }\n      return '';\n    };\n\n    XMLWriterBase.prototype.endline = function(node, options, level) {\n      if (!options.pretty || options.suppressPrettyCount) {\n        return '';\n      } else {\n        return options.newline;\n      }\n    };\n\n    XMLWriterBase.prototype.attribute = function(att, options, level) {\n      var r;\n      this.openAttribute(att, options, level);\n      r = ' ' + att.name + '=\"' + att.value + '\"';\n      this.closeAttribute(att, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.cdata = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<![CDATA[';\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += ']]>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.comment = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!-- ';\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += ' -->' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.declaration = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<?xml';\n      options.state = WriterState.InsideTag;\n      r += ' version=\"' + node.version + '\"';\n      if (node.encoding != null) {\n        r += ' encoding=\"' + node.encoding + '\"';\n      }\n      if (node.standalone != null) {\n        r += ' standalone=\"' + node.standalone + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '?>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.docType = function(node, options, level) {\n      var child, i, len, r, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      r += '<!DOCTYPE ' + node.root().name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      if (node.children.length > 0) {\n        r += ' [';\n        r += this.endline(node, options, level);\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          r += this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        r += ']';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.element = function(node, options, level) {\n      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;\n      level || (level = 0);\n      prettySuppressed = false;\n      r = '';\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r += this.indent(node, options, level) + '<' + node.name;\n      ref = node.attribs;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        r += this.attribute(att, options, level);\n      }\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        if (options.allowEmpty) {\n          r += '>';\n          options.state = WriterState.CloseTag;\n          r += '</' + node.name + '>' + this.endline(node, options, level);\n        } else {\n          options.state = WriterState.CloseTag;\n          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        r += '>';\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        r += this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        r += '</' + node.name + '>' + this.endline(node, options, level);\n      } else {\n        if (options.dontPrettyTextNodes) {\n          ref1 = node.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {\n              options.suppressPrettyCount++;\n              prettySuppressed = true;\n              break;\n            }\n          }\n        }\n        r += '>' + this.endline(node, options, level);\n        options.state = WriterState.InsideTag;\n        ref2 = node.children;\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          r += this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        r += this.indent(node, options, level) + '</' + node.name + '>';\n        if (prettySuppressed) {\n          options.suppressPrettyCount--;\n        }\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n      }\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {\n      switch (node.type) {\n        case NodeType.CData:\n          return this.cdata(node, options, level);\n        case NodeType.Comment:\n          return this.comment(node, options, level);\n        case NodeType.Element:\n          return this.element(node, options, level);\n        case NodeType.Raw:\n          return this.raw(node, options, level);\n        case NodeType.Text:\n          return this.text(node, options, level);\n        case NodeType.ProcessingInstruction:\n          return this.processingInstruction(node, options, level);\n        case NodeType.Dummy:\n          return '';\n        case NodeType.Declaration:\n          return this.declaration(node, options, level);\n        case NodeType.DocType:\n          return this.docType(node, options, level);\n        case NodeType.AttributeDeclaration:\n          return this.dtdAttList(node, options, level);\n        case NodeType.ElementDeclaration:\n          return this.dtdElement(node, options, level);\n        case NodeType.EntityDeclaration:\n          return this.dtdEntity(node, options, level);\n        case NodeType.NotationDeclaration:\n          return this.dtdNotation(node, options, level);\n        default:\n          throw new Error(\"Unknown XML node type: \" + node.constructor.name);\n      }\n    };\n\n    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<?';\n      options.state = WriterState.InsideTag;\n      r += node.target;\n      if (node.value) {\n        r += ' ' + node.value;\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '?>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.raw = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.text = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ATTLIST';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n      if (node.defaultValueType !== '#DEFAULT') {\n        r += ' ' + node.defaultValueType;\n      }\n      if (node.defaultValue) {\n        r += ' \"' + node.defaultValue + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdElement = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ELEMENT';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.name + ' ' + node.value;\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ENTITY';\n      options.state = WriterState.InsideTag;\n      if (node.pe) {\n        r += ' %';\n      }\n      r += ' ' + node.name;\n      if (node.value) {\n        r += ' \"' + node.value + '\"';\n      } else {\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        if (node.nData) {\n          r += ' NDATA ' + node.nData;\n        }\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!NOTATION';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.pubID) {\n        r += ' PUBLIC \"' + node.pubID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.openNode = function(node, options, level) {};\n\n    XMLWriterBase.prototype.closeNode = function(node, options, level) {};\n\n    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};\n\n    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};\n\n    return XMLWriterBase;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;\n\n  ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;\n\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLDocumentCB = require('./XMLDocumentCB');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  XMLStreamWriter = require('./XMLStreamWriter');\n\n  NodeType = require('./NodeType');\n\n  WriterState = require('./WriterState');\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    var doc, root;\n    if (name == null) {\n      throw new Error(\"Root element needs a name.\");\n    }\n    options = assign({}, xmldec, doctype, options);\n    doc = new XMLDocument(options);\n    root = doc.element(name);\n    if (!options.headless) {\n      doc.declaration(options);\n      if ((options.pubID != null) || (options.sysID != null)) {\n        doc.dtd(options);\n      }\n    }\n    return root;\n  };\n\n  module.exports.begin = function(options, onData, onEnd) {\n    var ref1;\n    if (isFunction(options)) {\n      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];\n      options = {};\n    }\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function(options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function(stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n  module.exports.implementation = new XMLDOMImplementation();\n\n  module.exports.nodeType = NodeType;\n\n  module.exports.writerState = WriterState;\n\n}).call(this);\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"timers\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst io = require('@actions/io');\n\n// This file is auto-generated, don't edit it\n// Dependent modules can be viewed by downloading the module dependency file in the project or obtaining SDK dependency information in the upper right corner\nconst SAEClient = require('@alicloud/sae20190506');\nconst OpenApi = require('@alicloud/openapi-client');\nconst Util = require('@alicloud/tea-util');\n\n// class Client {\n//\n//     /**\n//      * Initialize the Client with the AccessKey of the account\n//      * @return Client\n//      * @throws Exception\n//      */\n//     static createClient() {\n//         // The project code leakage may result in the leakage of AccessKey, posing a threat to the security of all resources under the account. The following code examples are for reference only.\n//         // It is recommended to use the more secure STS credential. For more credentials, please refer to: https://www.alibabacloud.com/help/en/alibaba-cloud-sdk-262060/latest/credentials-settings-5.\n//         let config = new OpenApi.Config({\n//             // Required, please ensure that the environment variables ALIBABA_CLOUD_ACCESS_KEY_ID is set.\n//             accessKeyId: this.accessKeyId, // Required, please ensure that the environment variables ALIBABA_CLOUD_ACCESS_KEY_SECRET is set.\n//             accessKeySecret: this.accessKeySecret,\n//         });\n//         // See https://api.alibabacloud.com/product/sae.\n//         config.regionId = this.regionId;\n//         return new SAEClient.default(config);\n//     }\n//\n//     static async main() {\n//         this.accessKeyId = core.getInput('access-key-id', { required: false });\n//         this.accessKeySecret = core.getInput('access-key-secret', { required: false });\n//         this.regionId = core.getInput('region-id', { required: false });\n//         this.appId = core.getInput('app-id', { required: false });\n//         this.imageUrl = core.getInput('image-url', { required: false });\n//\n//         let client = Client.createClient();\n//         let deployApplicationRequest = new SAEClient.DeployApplicationRequest({});\n//         deployApplicationRequest.appId = this.appId;\n//         deployApplicationRequest.imageUrl = this.imageUrl;\n//         let runtime = new Util.RuntimeOptions({});\n//         let headers = { 'Content-Type': 'application/json' };\n//         try {\n//             // Copy the code to run, please print the return value of the API by yourself.\n//             await client.deployApplicationWithOptions(deployApplicationRequest, headers, runtime);\n//         } catch (error) {\n//             // Only a printing example. Please be careful about exception handling and do not ignore exceptions directly in engineering projects.\n//             // print error message\n//             console.log(error.message);\n//             // Please click on the link below for diagnosis.\n//             console.log(error.data.Recommend);\n//             Util.default.assertAsString(error.message);\n//         }\n//     }\n// }\n\n// Client.main().catch(e => core.setFailed(e));\n\nasync function main() {\n    const accessKeyId = core.getInput('access-key-id', { required: false });\n    const accessKeySecret = core.getInput('access-key-secret', { required: false });\n    const regionId = core.getInput('region-id', { required: false });\n    const appId = core.getInput('app-id', { required: false });\n    const imageUrl = core.getInput('image-url', { required: false });\n    console.log(accessKeyId);\n    console.log(accessKeySecret);\n    console.log(regionId);\n    console.log(appId);\n    console.log(imageUrl);\n}\n\nmain().catch(e => core.setFailed(e))"],"names":[],"sourceRoot":""}